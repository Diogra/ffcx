Uflacs test framework
=====================

By Martin Sandve Alnaes
   martinal@simula.no
   Simula Research Laboratory

This file explains how to run, add, and edit unittests
in this cross-language python/C++ unittest framework.


How to run existing tests
-------------------------
Standing in uflacs/tests/, run
  ./test.sh
to run all tests with output to screen, or
  ./test.py
to run all tests with output to files, as used by the buildbot.


Code generation unittest framework
----------------------------------
This directory contains tests of code generation utilities.
The main idea is to use the python unittest framework to
test the python side of things, and allow the python tests
to emit C++ unittests based on generated code.

The motivation for this structure instead of using python
wrapping tools from python is that the tests of C++ code
needs to be done at a fairly fine grained scale, such as
testing just the generation of a single expression without
any surrounding class or function. The number of such test
cases can be quite large, and the python wrapping adds a
massive overhead, causing the time to run such tests to go
from seconds to tens of minutes.


Folder structure
----------------
NB! Everything under generated/ will be overwritten regularly
and should not be edited manually or added to version control.
Everything under py/ and cpp/ should be added to version control.

The python unittests are named 'py/test_*.py'.
The easiest way to add another python test file
is to copy one of these, rename the class to match
the new filename, and remove the existing 'def test_*'
to replace with your own. The docstrings of these tests
are parsed to define parts of the generated C++ unittests.


How to add new test files
-------------------------
After adding a file py/test_foo.py, run
  ./test.sh
to generate cpp/test_foo.h, and run
  bzr add cpp/test_foo.h py/test_foo.py
to add the new files to the version control system.

The file cpp/test_foo.h can be edited manually to
add pure C++ unittests if wanted, it will not be
overwritten by the test framework if it already exists.

The C++ unittests are written in the Google Test framework.
By editing cpp/test_foo.h you can write manual C++ tests
using regular Google Test syntax. To see how to generate
C++ tests from py/test_foo.py, see below and look at existing
tests for examples.


Structure of python unittests which emit C++ unittests
------------------------------------------------------

1) Let the test suite class subclass CodegenTestCase

2) Let the test suite class docstring contain a line marke
   HEADER:
   followed by C++ code such as includes, which will be inserted
   verbatim at the top of the generated/gc_test_foo.h file.

3) Define test cases the usual python unittest way, but with the structure

   def test_casename(self):
       '''Docstring (see point below).'''

       # Replace the 'code =' part with calls to code generation
       code = 'int generated_code_variable = 456;'

       self.emit_test(code)

   Here the call to emit_test at the end will result in docstring
   sections and the passed code to be formatted into a C++ unittest.

4) Define test case docstring sections separated by the line markers:
   '''Regular docstring comments, pasted into C++ test comments.

   PRE:
   // This section will be inserted _before_ the generated code
   int declaration_of_cpp_test_setup_code = 123;

   POST:
   // This section will be inserted _after_ the generated code
   // Postprocessing of generated code results and Google Test assertions
   ASSERT_EQ(declaration_of_cpp_test_setup_code, 123);
   ASSERT_EQ(generated_code_variable, 456);
   '''
   Inspect existing matching files
     py/test_*.py
     cpp/test_*.h
     generated/gc_test_*.h
   to see how this fits together. The PRE part is the setup,
   the code passed to emit_test is the CUT (Code Under Test),
   and the POST part is the assertions and eventual teardown.

Happy testing!
