// This code conforms with the UFC specification version 2018.2.0.dev0
// and was automatically generated by FFC version 2019.2.0.dev0.
//
// This code was generated with the following parameters:
//
//  {'epsilon': 1e-14,
//   'external_include_dirs': '',
//   'external_includes': '',
//   'precision': None,
//   'quadrature_degree': None,
//   'quadrature_rule': None,
//   'representation': 'uflacs',
//   'scalar_type': 'double',
//   'timeout': 10}


typedef double fenics_scalar_t;
#include <fenics_interface.h>
#include <math.h>
#include <stdalign.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

// Code for element ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main

int value_dimension_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(int i)
{
  return 1;
}

int reference_value_dimension_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(int i)
{
  return 1;
}

int evaluate_reference_basis_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
for (int64_t k = 0; k < num_points * 3; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 3; ++r)
        reference_values[3 * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[3 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[3 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(2, order);
for (int64_t l0 = 0; l0 < num_points * 3 * num_derivatives; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[2][3][3] =
    { { { 0.0, 0.0, 0.0 },
        { 4.8989794855663495, 0.0, 0.0 },
        { 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0 },
        { 2.449489742783182, 0.0, 0.0 },
        { 4.242640687119285, 0.0, 0.0 } } };
static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
const int64_t reference_offset[3] = { 0 };
const int64_t num_components[3] = { 1, 1, 1 };
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Loop over all dofs
    for (int64_t i = 0; i < 3; ++i)
    {
        double derivatives[2] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[3 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives_t = pow(2, order);
const int64_t num_derivatives_g = pow(3, order);
// Precomputed combinations
const int64_t combinations_t[1][2][1] =
    { { { 0 },
        { 1 } } };
// Precomputed combinations
const int64_t combinations_g[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t l = 0; l < num_points * 3 * num_derivatives_g; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[3] = { 0 };
const int64_t physical_offsets[3] = { 0 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[3][2];
    for (int64_t r = 0; r < num_derivatives_g; ++r)
        for (int64_t s = 0; s < num_derivatives_t; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives_g; ++r)
        for (int64_t s = 0; s < num_derivatives_t; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[2 * 3 * ip + 3 * combinations_t[order - 1][s][k] + combinations_g[order - 1][r][k]];
    for (int64_t d = 0; d < 3; ++d)
    {
        for (int64_t s = 0; s < num_derivatives_t; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[3 * num_derivatives_t * ip + num_derivatives_t * d + s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives_g; ++r)
                    values[3 * num_derivatives_g * ip + num_derivatives_g * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[1];
reference_values[2] = physical_values[2];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[6] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
memcpy(reference_dof_coordinates, dof_X, 6*sizeof(double));
return 0;
}


fenics_finite_element* create_sub_element_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(int i)
{
  return NULL;
}

fenics_finite_element* create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "FiniteElement('Lagrange', Cell('triangle', 3), 1)";
  element->cell_shape = triangle;
  element->topological_dimension = 2;
  element->geometric_dimension = 3;
  element->space_dimension = 3;
  element->value_rank = 0;
  element->value_dimension = value_dimension_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main;
  element->value_size = 1;
  element->reference_value_rank = 0;
  element->reference_value_dimension = reference_value_dimension_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main;
  element->reference_value_size = 1;
  element->degree = 1;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main;
  element->transform_values = transform_values_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main;
  element->num_sub_elements = 0;
  element->create_sub_element = create_sub_element_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main;
  element->create = create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main;

  return element;
};

// End of code for element ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main

// Code for element ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main

int value_dimension_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int reference_value_dimension_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int evaluate_reference_basis_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
for (int64_t k = 0; k < num_points * 9 * 3; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 3; ++r)
        reference_values[9 * 3 * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[9 * 3 * ip + 3] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[9 * 3 * ip + 3 * 2] += coefficients2[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[9 * 3 * ip + 3 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[9 * 3 * ip + 3 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[9 * 3 * ip + 3 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[9 * 3 * ip + 3 * 6 + 2] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[9 * 3 * ip + 3 * 7 + 2] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[9 * 3 * ip + 3 * 8 + 2] += coefficients2[0][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(2, order);
for (int64_t l0 = 0; l0 < num_points * 9 * num_derivatives * 3; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[2][3][3] =
    { { { 0.0, 0.0, 0.0 },
        { 4.8989794855663495, 0.0, 0.0 },
        { 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0 },
        { 2.449489742783182, 0.0, 0.0 },
        { 4.242640687119285, 0.0, 0.0 } } };
static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
const int64_t reference_offset[9] = { 0, 0, 0, 1, 1, 1, 2, 2, 2 };
const int64_t num_components[9] = { 1, 1, 1, 1, 1, 1, 1, 1, 1 };
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Loop over all dofs
    for (int64_t i = 0; i < 9; ++i)
    {
        double derivatives[2] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 4:
            // Compute reference derivatives for dof 4.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 5:
            // Compute reference derivatives for dof 5.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 6:
            // Compute reference derivatives for dof 6.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 7:
            // Compute reference derivatives for dof 7.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 8:
            // Compute reference derivatives for dof 8.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[9 * (num_derivatives * 3) * ip + num_derivatives * 3 * i + 3 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives_t = pow(2, order);
const int64_t num_derivatives_g = pow(3, order);
// Precomputed combinations
const int64_t combinations_t[1][2][1] =
    { { { 0 },
        { 1 } } };
// Precomputed combinations
const int64_t combinations_g[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t l = 0; l < num_points * 9 * num_derivatives_g * 3; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[9] = { 0, 0, 0, 1, 1, 1, 2, 2, 2 };
const int64_t physical_offsets[9] = { 0, 0, 0, 1, 1, 1, 2, 2, 2 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[3][2];
    for (int64_t r = 0; r < num_derivatives_g; ++r)
        for (int64_t s = 0; s < num_derivatives_t; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives_g; ++r)
        for (int64_t s = 0; s < num_derivatives_t; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[2 * 3 * ip + 3 * combinations_t[order - 1][s][k] + combinations_g[order - 1][r][k]];
    for (int64_t d = 0; d < 9; ++d)
    {
        for (int64_t s = 0; s < num_derivatives_t; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[9 * (num_derivatives_t * 3) * ip + num_derivatives_t * 3 * d + 3 * s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives_g; ++r)
                    values[9 * (num_derivatives_g * 3) * ip + num_derivatives_g * 3 * d + 3 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[3];
reference_values[2] = physical_values[6];
reference_values[3] = physical_values[10];
reference_values[4] = physical_values[13];
reference_values[5] = physical_values[16];
reference_values[6] = physical_values[20];
reference_values[7] = physical_values[23];
reference_values[8] = physical_values[26];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[18] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
memcpy(reference_dof_coordinates, dof_X, 18*sizeof(double));
return 0;
}

fenics_finite_element* create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(void);

fenics_finite_element* create_sub_element_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(int i)
{
  switch (i)
{
case 0:
    return create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main();
case 1:
    return create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main();
case 2:
    return create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main();
default:
    return NULL;
}
}

fenics_finite_element* create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "VectorElement(FiniteElement('Lagrange', Cell('triangle', 3), 1), dim=3)";
  element->cell_shape = triangle;
  element->topological_dimension = 2;
  element->geometric_dimension = 3;
  element->space_dimension = 9;
  element->value_rank = 1;
  element->value_dimension = value_dimension_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main;
  element->value_size = 3;
  element->reference_value_rank = 1;
  element->reference_value_dimension = reference_value_dimension_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main;
  element->reference_value_size = 3;
  element->degree = 1;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main;
  element->transform_values = transform_values_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main;
  element->num_sub_elements = 3;
  element->create_sub_element = create_sub_element_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main;
  element->create = create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main;

  return element;
};

// End of code for element ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main

// Code for element ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main

int value_dimension_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int reference_value_dimension_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(int i)
{
  static const int return_values[1] = { 2 };
if (i >= 1)
    return 1;
return return_values[i];
}

int evaluate_reference_basis_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[2][3] =
    { { 0.47140452079103173, 0.288675134594813, -0.16666666666666669 },
      { 0.47140452079103135, 0.0, 0.3333333333333332 } };
static const double coefficients1[2][3] =
    { { 0.9428090415820631, -0.2886751345948131, 0.1666666666666667 },
      { -0.47140452079103146, 0.0, -0.33333333333333326 } };
static const double coefficients2[2][3] =
    { { 0.47140452079103184, 0.288675134594813, -0.1666666666666667 },
      { -0.9428090415820635, 0.0, 0.33333333333333326 } };
for (int64_t k = 0; k < num_points * 3 * 2; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Accumulate products of coefficients and basisvalues
    for (int64_t c = 0; c < 2; ++c)
        for (int64_t r = 0; r < 3; ++r)
            reference_values[3 * 2 * ip + c] += coefficients0[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 2; ++c)
        for (int64_t r = 0; r < 3; ++r)
            reference_values[3 * 2 * ip + 2 + c] += coefficients1[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 2; ++c)
        for (int64_t r = 0; r < 3; ++r)
            reference_values[3 * 2 * ip + 2 * 2 + c] += coefficients2[c][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(2, order);
for (int64_t l0 = 0; l0 < num_points * 3 * num_derivatives * 2; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[2][3][3] =
    { { { 0.0, 0.0, 0.0 },
        { 4.8989794855663495, 0.0, 0.0 },
        { 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0 },
        { 2.449489742783182, 0.0, 0.0 },
        { 4.242640687119285, 0.0, 0.0 } } };
static const double coefficients0[2][3] =
    { { 0.47140452079103173, 0.288675134594813, -0.16666666666666669 },
      { 0.47140452079103135, 0.0, 0.3333333333333332 } };
static const double coefficients1[2][3] =
    { { 0.9428090415820631, -0.2886751345948131, 0.1666666666666667 },
      { -0.47140452079103146, 0.0, -0.33333333333333326 } };
static const double coefficients2[2][3] =
    { { 0.47140452079103184, 0.288675134594813, -0.1666666666666667 },
      { -0.9428090415820635, 0.0, 0.33333333333333326 } };
const int64_t reference_offset[3] = { 0 };
const int64_t num_components[3] = { 2, 2, 2 };
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Loop over all dofs
    for (int64_t i = 0; i < 3; ++i)
    {
        double derivatives[4] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                {
                    derivatives[r] += coefficients0[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients0[1][s] * aux[s];
                }
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                {
                    derivatives[r] += coefficients1[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients1[1][s] * aux[s];
                }
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                {
                    derivatives[r] += coefficients2[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients2[1][s] * aux[s];
                }
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[3 * (num_derivatives * 2) * ip + num_derivatives * 2 * i + 2 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives_t = pow(2, order);
const int64_t num_derivatives_g = pow(3, order);
// Precomputed combinations
const int64_t combinations_t[1][2][1] =
    { { { 0 },
        { 1 } } };
// Precomputed combinations
const int64_t combinations_g[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t l = 0; l < num_points * 3 * num_derivatives_g * 3; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[3] = { 0 };
const int64_t physical_offsets[3] = { 0 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[3][2];
    for (int64_t r = 0; r < num_derivatives_g; ++r)
        for (int64_t s = 0; s < num_derivatives_t; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives_g; ++r)
        for (int64_t s = 0; s < num_derivatives_t; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[2 * 3 * ip + 3 * combinations_t[order - 1][s][k] + combinations_g[order - 1][r][k]];
    for (int64_t d = 0; d < 3; ++d)
    {
        for (int64_t s = 0; s < num_derivatives_t; ++s)
        {
            for (int64_t i = 0; i < 3; ++i)
            {
                // Using contravariant Piola transform to map values back to the physical element.
                const double mapped_value = 1.0 / detJ[ip] * (J[3 * 2 * ip + 2 * i] * reference_values[3 * (num_derivatives_t * 2) * ip + num_derivatives_t * 2 * d + 2 * s + reference_offsets[d]] + J[3 * 2 * ip + 2 * i + 1] * reference_values[3 * (num_derivatives_t * 2) * ip + num_derivatives_t * 2 * d + 2 * s + (reference_offsets[d] + 1)]);
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives_g; ++r)
                    values[3 * (num_derivatives_g * 3) * ip + num_derivatives_g * 3 * d + 3 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using contravariant Piola transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  // Compute Jacobian
double J[6];
compute_jacobian_triangle_3d(J, coordinate_dofs);
// Compute Inverse Jacobian and determinant
double K[6];
double detJ;
compute_jacobian_inverse_triangle_3d(K, &detJ, J);
// Check orientation and return error code
if (cell_orientation == -1)
    return -1;
// (If cell_orientation == 1 = down, multiply det(J) by -1)
else if (cell_orientation == 1)
{
    detJ *= -1;
}
reference_values[0] = (physical_values[0] * K[0] + physical_values[1] * K[1] + physical_values[2] * K[2]) * detJ + (physical_values[0] * K[3] + physical_values[1] * K[3 + 1] + physical_values[2] * K[3 + 2]) * detJ;
reference_values[1] = (physical_values[3] * K[0] + physical_values[4] * K[1] + physical_values[5] * K[2]) * detJ;
reference_values[2] = -((physical_values[6] * K[3] + physical_values[7] * K[3 + 1] + physical_values[8] * K[3 + 2]) * detJ);
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[6] = { 0.5, 0.5, 0.0, 0.5, 0.5, 0.0 };
memcpy(reference_dof_coordinates, dof_X, 6*sizeof(double));
return 0;
}


fenics_finite_element* create_sub_element_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(int i)
{
  return NULL;
}

fenics_finite_element* create_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "FiniteElement('Raviart-Thomas', Cell('triangle', 3), 1)";
  element->cell_shape = triangle;
  element->topological_dimension = 2;
  element->geometric_dimension = 3;
  element->space_dimension = 3;
  element->value_rank = 1;
  element->value_dimension = value_dimension_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main;
  element->value_size = 3;
  element->reference_value_rank = 1;
  element->reference_value_dimension = reference_value_dimension_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main;
  element->reference_value_size = 2;
  element->degree = 1;
  element->family = "Raviart-Thomas";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main;
  element->transform_values = transform_values_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main;
  element->num_sub_elements = 0;
  element->create_sub_element = create_sub_element_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main;
  element->create = create_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main;

  return element;
};

// End of code for element ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main

// Code for element ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main

int value_dimension_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(int i)
{
  return 1;
}

int reference_value_dimension_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(int i)
{
  return 1;
}

int evaluate_reference_basis_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][1] = { { 1.0 } };
for (int64_t k = 0; k < num_points; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Compute basisvalues for each relevant embedded degree
    double basisvalues0[1] = { 0 };
    basisvalues0[0] = 1.0;
    // Accumulate products of coefficients and basisvalues
    reference_values[ip] += coefficients0[0][0] * basisvalues0[0];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(2, order);
for (int64_t l0 = 0; l0 < num_points * num_derivatives; ++l0)
    reference_values[l0] = 0.0;
if (order > 0)
    return 0;
return 0;
}

int transform_reference_basis_derivatives_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  for (int64_t l = 0; l < num_points; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[1] = { 0 };
const int64_t physical_offsets[1] = { 0 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[1][1];
    for (int64_t r = 0; r < 1; ++r)
        for (int64_t s = 0; s < 1; ++s)
            transform[r][s] = 1.0;
    for (int64_t d = 0; d < 1; ++d)
    {
        for (int64_t s = 0; s < 1; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[ip + d + s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < 1; ++r)
                    values[ip + d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[2] = { 0.3333333333333333, 0.3333333333333333 };
memcpy(reference_dof_coordinates, dof_X, 2*sizeof(double));
return 0;
}


fenics_finite_element* create_sub_element_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(int i)
{
  return NULL;
}

fenics_finite_element* create_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "FiniteElement('Discontinuous Lagrange', Cell('triangle', 3), 0)";
  element->cell_shape = triangle;
  element->topological_dimension = 2;
  element->geometric_dimension = 3;
  element->space_dimension = 1;
  element->value_rank = 0;
  element->value_dimension = value_dimension_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main;
  element->value_size = 1;
  element->reference_value_rank = 0;
  element->reference_value_dimension = reference_value_dimension_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main;
  element->reference_value_size = 1;
  element->degree = 0;
  element->family = "Discontinuous Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main;
  element->transform_values = transform_values_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main;
  element->num_sub_elements = 0;
  element->create_sub_element = create_sub_element_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main;
  element->create = create_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main;

  return element;
};

// End of code for element ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main

// Code for element ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main

int value_dimension_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(int i)
{
  static const int return_values[1] = { 4 };
if (i >= 1)
    return 1;
return return_values[i];
}

int reference_value_dimension_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int evaluate_reference_basis_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[2][3] =
    { { 0.47140452079103173, 0.288675134594813, -0.16666666666666669 },
      { 0.47140452079103135, 0.0, 0.3333333333333332 } };
static const double coefficients1[2][3] =
    { { 0.9428090415820631, -0.2886751345948131, 0.1666666666666667 },
      { -0.47140452079103146, 0.0, -0.33333333333333326 } };
static const double coefficients2[2][3] =
    { { 0.47140452079103184, 0.288675134594813, -0.1666666666666667 },
      { -0.9428090415820635, 0.0, 0.33333333333333326 } };
static const double coefficients3[1][1] = { { 1.0 } };
for (int64_t k = 0; k < num_points * 4 * 3; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    double basisvalues0[1] = { 0 };
    basisvalues0[0] = 1.0;
    // Accumulate products of coefficients and basisvalues
    for (int64_t c = 0; c < 2; ++c)
        for (int64_t r = 0; r < 3; ++r)
            reference_values[4 * 3 * ip + c] += coefficients0[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 2; ++c)
        for (int64_t r = 0; r < 3; ++r)
            reference_values[4 * 3 * ip + 3 + c] += coefficients1[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 2; ++c)
        for (int64_t r = 0; r < 3; ++r)
            reference_values[4 * 3 * ip + 3 * 2 + c] += coefficients2[c][r] * basisvalues1[r];
    reference_values[4 * 3 * ip + 3 * 3 + 2] += coefficients3[0][0] * basisvalues0[0];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(2, order);
for (int64_t l0 = 0; l0 < num_points * 4 * num_derivatives * 3; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[2][3][3] =
    { { { 0.0, 0.0, 0.0 },
        { 4.8989794855663495, 0.0, 0.0 },
        { 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0 },
        { 2.449489742783182, 0.0, 0.0 },
        { 4.242640687119285, 0.0, 0.0 } } };
alignas(32) static const double dmats3[2][1][1] = {{{ 0 }}};
static const double coefficients0[2][3] =
    { { 0.47140452079103173, 0.288675134594813, -0.16666666666666669 },
      { 0.47140452079103135, 0.0, 0.3333333333333332 } };
static const double coefficients1[2][3] =
    { { 0.9428090415820631, -0.2886751345948131, 0.1666666666666667 },
      { -0.47140452079103146, 0.0, -0.33333333333333326 } };
static const double coefficients2[2][3] =
    { { 0.47140452079103184, 0.288675134594813, -0.1666666666666667 },
      { -0.9428090415820635, 0.0, 0.33333333333333326 } };
static const double coefficients3[1][1] = { { 1.0 } };
const int64_t reference_offset[4] = { 0, 0, 0, 2 };
const int64_t num_components[4] = { 2, 2, 2, 1 };
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    double basisvalues0[1] = { 0 };
    basisvalues0[0] = 1.0;
    // Loop over all dofs
    for (int64_t i = 0; i < 4; ++i)
    {
        double derivatives[4] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                {
                    derivatives[r] += coefficients0[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients0[1][s] * aux[s];
                }
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                {
                    derivatives[r] += coefficients1[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients1[1][s] * aux[s];
                }
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                {
                    derivatives[r] += coefficients2[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients2[1][s] * aux[s];
                }
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[1] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[1][1] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats3[comb][0][0], 1*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[1][1];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 1*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 1; ++l0)
                        for (int64_t l1 = 0; l1 < 1; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 1; ++t)
                        for (int64_t u = 0; u < 1; ++u)
                            for (int64_t tu = 0; tu < 1; ++tu)
                                dmats[t][u] += dmats3[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 1; ++s)
                    for (int64_t t = 0; t < 1; ++t)
                        aux[s] += dmats[s][t] * basisvalues0[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 1; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[4 * (num_derivatives * 3) * ip + num_derivatives * 3 * i + 3 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives_t = pow(2, order);
const int64_t num_derivatives_g = pow(3, order);
// Precomputed combinations
const int64_t combinations_t[1][2][1] =
    { { { 0 },
        { 1 } } };
// Precomputed combinations
const int64_t combinations_g[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t l = 0; l < num_points * 4 * num_derivatives_g * 4; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[4] = { 0, 0, 0, 2 };
const int64_t physical_offsets[4] = { 0, 0, 0, 3 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[3][2];
    for (int64_t r = 0; r < num_derivatives_g; ++r)
        for (int64_t s = 0; s < num_derivatives_t; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives_g; ++r)
        for (int64_t s = 0; s < num_derivatives_t; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[2 * 3 * ip + 3 * combinations_t[order - 1][s][k] + combinations_g[order - 1][r][k]];
    for (int64_t d = 3; d < 4; ++d)
    {
        for (int64_t s = 0; s < num_derivatives_t; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[4 * (num_derivatives_t * 3) * ip + num_derivatives_t * 3 * d + 3 * s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives_g; ++r)
                    values[4 * (num_derivatives_g * 4) * ip + num_derivatives_g * 4 * d + 4 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
    for (int64_t d = 0; d < 3; ++d)
    {
        for (int64_t s = 0; s < num_derivatives_t; ++s)
        {
            for (int64_t i = 0; i < 3; ++i)
            {
                // Using contravariant Piola transform to map values back to the physical element.
                const double mapped_value = 1.0 / detJ[ip] * (J[3 * 2 * ip + 2 * i] * reference_values[4 * (num_derivatives_t * 3) * ip + num_derivatives_t * 3 * d + 3 * s + reference_offsets[d]] + J[3 * 2 * ip + 2 * i + 1] * reference_values[4 * (num_derivatives_t * 3) * ip + num_derivatives_t * 3 * d + 3 * s + (reference_offsets[d] + 1)]);
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives_g; ++r)
                    values[4 * (num_derivatives_g * 4) * ip + num_derivatives_g * 4 * d + 4 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using contravariant Piola transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  // Compute Jacobian
double J[6];
compute_jacobian_triangle_3d(J, coordinate_dofs);
// Compute Inverse Jacobian and determinant
double K[6];
double detJ;
compute_jacobian_inverse_triangle_3d(K, &detJ, J);
// Check orientation and return error code
if (cell_orientation == -1)
    return -1;
// (If cell_orientation == 1 = down, multiply det(J) by -1)
else if (cell_orientation == 1)
{
    detJ *= -1;
}
reference_values[0] = (physical_values[0] * K[0] + physical_values[1] * K[1] + physical_values[2] * K[2]) * detJ + (physical_values[0] * K[3] + physical_values[1] * K[3 + 1] + physical_values[2] * K[3 + 2]) * detJ;
reference_values[1] = (physical_values[4] * K[0] + physical_values[5] * K[1] + physical_values[6] * K[2]) * detJ;
reference_values[2] = -((physical_values[8] * K[3] + physical_values[9] * K[3 + 1] + physical_values[10] * K[3 + 2]) * detJ);
reference_values[3] = physical_values[15];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[8] = { 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.3333333333333333, 0.3333333333333333 };
memcpy(reference_dof_coordinates, dof_X, 8*sizeof(double));
return 0;
}

fenics_finite_element* create_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main(void);
fenics_finite_element* create_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main(void);

fenics_finite_element* create_sub_element_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(int i)
{
  switch (i)
{
case 0:
    return create_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_finite_element_main();
case 1:
    return create_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_finite_element_main();
default:
    return NULL;
}
}

fenics_finite_element* create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "MixedElement(FiniteElement('Raviart-Thomas', Cell('triangle', 3), 1), FiniteElement('Discontinuous Lagrange', Cell('triangle', 3), 0))";
  element->cell_shape = triangle;
  element->topological_dimension = 2;
  element->geometric_dimension = 3;
  element->space_dimension = 4;
  element->value_rank = 1;
  element->value_dimension = value_dimension_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  element->value_size = 4;
  element->reference_value_rank = 1;
  element->reference_value_dimension = reference_value_dimension_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  element->reference_value_size = 3;
  element->degree = 1;
  element->family = "Mixed";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  element->transform_values = transform_values_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  element->num_sub_elements = 2;
  element->create_sub_element = create_sub_element_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  element->create = create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;

  return element;
};

// End of code for element ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main

// Code for dofmap ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main

void tabulate_entity_dofs_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    case 2:
        dofs[0] = 2;
        break;
    }
    break;
}
}


fenics_dofmap* create_sub_dofmap_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main(int i)
{
return NULL;
}

fenics_dofmap* create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', 3), 1)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 3;
  dofmap->num_entity_dofs[0] = 1;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main;
  dofmap->num_sub_dofmaps = 0;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main;
  dofmap->create = create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main

// Code for dofmap ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main

void tabulate_entity_dofs_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        dofs[1] = 3;
        dofs[2] = 6;
        break;
    case 1:
        dofs[0] = 1;
        dofs[1] = 4;
        dofs[2] = 7;
        break;
    case 2:
        dofs[0] = 2;
        dofs[1] = 5;
        dofs[2] = 8;
        break;
    }
    break;
}
}

fenics_dofmap* create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main(void);

fenics_dofmap* create_sub_dofmap_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main();
case 1:
    return create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main();
case 2:
    return create_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_dofmap_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for VectorElement(FiniteElement('Lagrange', Cell('triangle', 3), 1), dim=3)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 9;
  dofmap->num_entity_dofs[0] = 3;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main;
  dofmap->num_sub_dofmaps = 3;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main;
  dofmap->create = create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main

// Code for dofmap ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main

void tabulate_entity_dofs_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 1:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    case 2:
        dofs[0] = 2;
        break;
    }
    break;
}
}


fenics_dofmap* create_sub_dofmap_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main(int i)
{
return NULL;
}

fenics_dofmap* create_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for FiniteElement('Raviart-Thomas', Cell('triangle', 3), 1)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 3;
  dofmap->num_entity_dofs[0] = 0;
  dofmap->num_entity_dofs[1] = 1;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main;
  dofmap->num_sub_dofmaps = 0;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main;
  dofmap->create = create_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main

// Code for dofmap ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main

void tabulate_entity_dofs_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 2:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    }
    break;
}
}


fenics_dofmap* create_sub_dofmap_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main(int i)
{
return NULL;
}

fenics_dofmap* create_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for FiniteElement('Discontinuous Lagrange', Cell('triangle', 3), 0)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 1;
  dofmap->num_entity_dofs[0] = 0;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 1;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main;
  dofmap->num_sub_dofmaps = 0;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main;
  dofmap->create = create_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main

// Code for dofmap ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main

void tabulate_entity_dofs_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 1:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    case 2:
        dofs[0] = 2;
        break;
    }
    break;
case 2:
    switch (i)
    {
    case 0:
        dofs[0] = 3;
        break;
    }
    break;
}
}

fenics_dofmap* create_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main(void);
fenics_dofmap* create_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main(void);

fenics_dofmap* create_sub_dofmap_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_8f5aaa165ce140c38b3e9b3567ee2d7974f393f0_dofmap_main();
case 1:
    return create_ffc_element_f334c5f685cb9407fac95a5512c9d072f5ceb4ef_dofmap_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for MixedElement(FiniteElement('Raviart-Thomas', Cell('triangle', 3), 1), FiniteElement('Discontinuous Lagrange', Cell('triangle', 3), 0))";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 4;
  dofmap->num_entity_dofs[0] = 0;
  dofmap->num_entity_dofs[1] = 1;
  dofmap->num_entity_dofs[2] = 1;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main;
  dofmap->num_sub_dofmaps = 2;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main;
  dofmap->create = create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main

// Code for coordinate mapping ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main

fenics_finite_element* create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(void);

fenics_finite_element* create_coordinate_finite_element_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(void)
{
return create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main();
}

fenics_dofmap* create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main(void);

fenics_dofmap* create_coordinate_dofmap_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(void)
{
return create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main();
}


int evaluate_reference_basis_derivatives_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(double* restrict reference_values,
    int order, int num_points, const double* restrict X);

void compute_jacobians_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(double* restrict J, int num_points,
                                      const double* restrict X,
                                      const double* restrict coordinate_dofs)
{
double dphi[6];
for (int64_t l = 0; l < num_points * 3 * 2; ++l)
    J[l] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Compute basis derivatives of coordinate element
    evaluate_reference_basis_derivatives_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(dphi, 1, 1, &X[2 * ip]);
    // Compute J
    for (int64_t i = 0; i < 3; ++i)
        for (int64_t j = 0; j < 2; ++j)
            for (int64_t d = 0; d < 3; ++d)
                J[3 * 2 * ip + 2 * i + j] += coordinate_dofs[3 * d + i] * dphi[2 * d + j];
}
}

void compute_jacobian_determinants_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(double* restrict detJ, int num_points,
                                                  const double* restrict J, int cell_orientation)
{
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double JTJ[2][2] = {{ 0 }};
    for (int64_t i = 0; i < 2; ++i)
        for (int64_t j = 0; j < 2; ++j)
            for (int64_t k = 0; k < 3; ++k)
                JTJ[i][j] += J[3 * 2 * ip + 2 * k + i] * J[3 * 2 * ip + 2 * k + j];
    detJ[ip] = (cell_orientation == 1 ? -1.0 : 1.0) * sqrt(JTJ[0][0] * JTJ[1][1] - JTJ[0][1] * JTJ[1][0]);
}
}

void compute_jacobian_inverses_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(double* restrict K, int num_points,
    const double* restrict J, const double* restrict detJ)
{
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Compute J^T J
    double JTJ[4] = { 0 };
    for (int64_t k = 0; k < 2; ++k)
        for (int64_t j = 0; j < 2; ++j)
            for (int64_t i = 0; i < 3; ++i)
                JTJ[2 * k + j] += J[3 * 2 * ip + 2 * i + k] * J[3 * 2 * ip + 2 * i + j];
    // Compute inverse(J^T J)
    double JTJinv[4];
    JTJinv[0] = JTJ[2 + 1] / (detJ[ip] * detJ[ip]);
    JTJinv[1] = -JTJ[1] / (detJ[ip] * detJ[ip]);
    JTJinv[2] = -JTJ[2] / (detJ[ip] * detJ[ip]);
    JTJinv[2 + 1] = JTJ[0] / (detJ[ip] * detJ[ip]);
    // Compute K = inverse(J^T J) * J
    for (int64_t k = 0; k < 2; ++k)
        for (int64_t i = 0; i < 3; ++i)
            K[2 * 3 * ip + 3 * k + i] = 0.0;
    for (int64_t k = 0; k < 2; ++k)
        for (int64_t i = 0; i < 3; ++i)
            for (int64_t j = 0; j < 2; ++j)
                K[2 * 3 * ip + 3 * k + i] += JTJinv[2 * k + j] * J[3 * 2 * ip + 2 * i + j];
}
}


int evaluate_reference_basis_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(double* restrict reference_values,
    int num_points, const double* restrict X);

void compute_physical_coordinates_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(double* restrict x, int num_points,
                                                 const double* restrict X,
                                                 const double* restrict coordinate_dofs)
{
double phi[3];
for (int64_t i = 0; i < num_points * 3; ++i)
    x[i] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Compute basis values of coordinate element
    evaluate_reference_basis_ffc_element_e6f0c73e7a592342a75ee12da98a39760e0a5bc2_finite_element_main(phi, 1, &X[2 * ip]);
    // Compute x
    for (int64_t i = 0; i < 3; ++i)
        for (int64_t d = 0; d < 3; ++d)
            x[3 * ip + i] += coordinate_dofs[3 * d + i] * phi[d];
}
}

void compute_geometry_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(double* restrict x, double* restrict J,
                                     double* restrict detJ, double* restrict K,
                                     int num_points, const double* restrict X,
                                     const double* restrict coordinate_dofs,
                                     int cell_orientation)
{
compute_physical_coordinates_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(x, num_points, X, coordinate_dofs);
compute_jacobians_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(J, num_points, X, coordinate_dofs);
compute_jacobian_determinants_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(detJ, num_points, J, cell_orientation);
compute_jacobian_inverses_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(K, num_points, J, detJ);
}

void compute_midpoint_geometry_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(double* restrict x, double* restrict J,
                                              const double* restrict coordinate_dofs)
{
const double phi_Xm[3] = { 0.33333333333333337, 0.33333333333333337, 0.3333333333333333 };
const double dphi_Xm[2][3] =
    { { -1.0, 1.0, 0.0 },
      { -1.0, 0.0, 1.0 } };
for (int64_t l = 0; l < 6; ++l)
    J[l] = 0.0;
// Compute x
for (int64_t i = 0; i < 3; ++i)
{
    x[i] = 0.0;
    for (int64_t d = 0; d < 3; ++d)
        x[i] += coordinate_dofs[3 * d + i] * phi_Xm[d];
}
// Compute J
for (int64_t i = 0; i < 3; ++i)
    for (int64_t j = 0; j < 2; ++j)
        for (int64_t d = 0; d < 3; ++d)
            J[2 * i + j] += coordinate_dofs[3 * d + i] * dphi_Xm[j][d];
}

void compute_reference_coordinates_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(double* restrict X, int num_points,
                                                  const double* restrict x,
                                                  const double* restrict coordinate_dofs,
                                                  int cell_orientation)
{
for (int64_t l = 0; l < num_points * 2; ++l)
    X[l] = 0.0;
const double phi_X0[3] = { 1.0, 0.0, 0.0 };
const double dphi_X0[2][3] =
    { { -1.0, 1.0, 0.0 },
      { -1.0, 0.0, 1.0 } };
double J[6];
double detJ[1];
double K[6];
double x0[3] = { 0 };
for (int64_t i = 0; i < 3; ++i)
    for (int64_t k = 0; k < 3; ++k)
        x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
for (int64_t i = 0; i < 3; ++i)
{
    for (int64_t j = 0; j < 2; ++j)
    {
        J[2 * i + j] = 0.0;
        for (int64_t k = 0; k < 3; ++k)
            J[2 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
    }
}
compute_jacobian_determinants_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(detJ, 1, J, cell_orientation);
compute_jacobian_inverses_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(K, 1, J, detJ);
for (int64_t ip = 0; ip < num_points; ++ip)
    for (int64_t j = 0; j < 2; ++j)
        for (int64_t i = 0; i < 3; ++i)
            X[2 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}

void compute_reference_geometry_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(double* restrict X, double* restrict J,
                                               double* restrict detJ, double* restrict K,
                                               int num_points, const double* restrict x,
                                               const double* restrict coordinate_dofs,
                                               int cell_orientation)
{
for (int64_t l = 0; l < num_points * 2; ++l)
    X[l] = 0.0;
const double phi_X0[3] = { 1.0, 0.0, 0.0 };
const double dphi_X0[2][3] =
    { { -1.0, 1.0, 0.0 },
      { -1.0, 0.0, 1.0 } };
double x0[3] = { 0 };
for (int64_t i = 0; i < 3; ++i)
    for (int64_t k = 0; k < 3; ++k)
        x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
for (int64_t i = 0; i < 3; ++i)
{
    for (int64_t j = 0; j < 2; ++j)
    {
        J[2 * i + j] = 0.0;
        for (int64_t k = 0; k < 3; ++k)
            J[2 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
    }
}
compute_jacobian_determinants_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(detJ, 1, J, cell_orientation);
compute_jacobian_inverses_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(K, 1, J, detJ);
for (int64_t ip = 0; ip < num_points; ++ip)
    for (int64_t j = 0; j < 2; ++j)
        for (int64_t i = 0; i < 3; ++i)
            X[2 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}




fenics_coordinate_mapping* create_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(void)
{
  fenics_coordinate_mapping* cmap = malloc(sizeof(*cmap));
  cmap->signature = "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', Cell('triangle', 3), 1), dim=3)";
  cmap->create = create_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->geometric_dimension = 3;
  cmap->topological_dimension = 2;
  cmap->cell_shape = triangle;
  cmap->create_coordinate_finite_element = create_coordinate_finite_element_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->create_coordinate_dofmap = create_coordinate_dofmap_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->compute_physical_coordinates = compute_physical_coordinates_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->compute_reference_coordinates = compute_reference_coordinates_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->compute_reference_geometry = compute_reference_geometry_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->compute_jacobians = compute_jacobians_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->compute_jacobian_determinants = compute_jacobian_determinants_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->compute_jacobian_inverses = compute_jacobian_inverses_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->compute_geometry = compute_geometry_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  cmap->compute_midpoint_geometry = compute_midpoint_geometry_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  return cmap;
}

// End of code for coordinate mapping ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main

// Code for integral projectionmanifold_cell_integral_527128f7582c21965f4042addb76df3f7dbaf133_otherwise


void tabulate_tensor_projectionmanifold_cell_integral_527128f7582c21965f4042addb76df3f7dbaf133_otherwise(fenics_scalar_t* restrict A, const fenics_scalar_t* w,
                                    const fenics_scalar_t* c,
                                    const double* restrict coordinate_dofs,
                                    const int* unused_local_index,
                                    const int* cell_orientation)
{
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const fenics_scalar_t FE6_C0_D01_Q3[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE6_C0_D01_Q3[0][0][0] + coordinate_dofs[3] * FE6_C0_D01_Q3[0][0][1];
    const fenics_scalar_t co = cell_orientation[0] == 1 ? -1.0 : 1.0;
    const double J_c2 = coordinate_dofs[1] * FE6_C0_D01_Q3[0][0][0] + coordinate_dofs[4] * FE6_C0_D01_Q3[0][0][1];
    const double J_c5 = coordinate_dofs[2] * FE6_C0_D01_Q3[0][0][0] + coordinate_dofs[8] * FE6_C0_D01_Q3[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE6_C0_D01_Q3[0][0][0] + coordinate_dofs[7] * FE6_C0_D01_Q3[0][0][1];
    const double J_c4 = coordinate_dofs[2] * FE6_C0_D01_Q3[0][0][0] + coordinate_dofs[5] * FE6_C0_D01_Q3[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE6_C0_D01_Q3[0][0][0] + coordinate_dofs[6] * FE6_C0_D01_Q3[0][0][1];
    alignas(32) fenics_scalar_t sp[92];
    sp[0] = J_c2 * J_c5;
    sp[1] = J_c3 * J_c4;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = sp[2] * sp[2];
    sp[4] = J_c1 * J_c4;
    sp[5] = J_c0 * J_c5;
    sp[6] = sp[4] + -1 * sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = J_c0 * J_c3;
    sp[10] = J_c1 * J_c2;
    sp[11] = sp[9] + -1 * sp[10];
    sp[12] = sp[11] * sp[11];
    sp[13] = sp[8] + sp[12];
    sp[14] = sqrt(sp[13]);
    sp[15] = co * sp[14];
    sp[16] = J_c0 * (1.0 / sp[15]);
    sp[17] = J_c1 * (1.0 / sp[15]);
    sp[18] = sp[16] * sp[16];
    sp[19] = sp[16] * sp[17];
    sp[20] = sp[17] * sp[17];
    sp[21] = J_c2 * (1.0 / sp[15]);
    sp[22] = J_c3 * (1.0 / sp[15]);
    sp[23] = sp[21] * sp[21];
    sp[24] = sp[21] * sp[22];
    sp[25] = sp[22] * sp[22];
    sp[26] = sp[18] + sp[23];
    sp[27] = sp[19] + sp[24];
    sp[28] = sp[20] + sp[25];
    sp[29] = J_c4 * (1.0 / sp[15]);
    sp[30] = J_c5 * (1.0 / sp[15]);
    sp[31] = sp[29] * sp[29];
    sp[32] = sp[29] * sp[30];
    sp[33] = sp[30] * sp[30];
    sp[34] = sp[26] + sp[31];
    sp[35] = sp[27] + sp[32];
    sp[36] = sp[28] + sp[33];
    sp[37] = J_c1 * J_c1;
    sp[38] = J_c3 * J_c3;
    sp[39] = sp[37] + sp[38];
    sp[40] = J_c5 * J_c5;
    sp[41] = sp[39] + sp[40];
    sp[42] = J_c0 * J_c0;
    sp[43] = J_c2 * J_c2;
    sp[44] = sp[42] + sp[43];
    sp[45] = J_c4 * J_c4;
    sp[46] = sp[44] + sp[45];
    sp[47] = sp[46] * sp[41];
    sp[48] = J_c0 * J_c1;
    sp[49] = J_c2 * J_c3;
    sp[50] = sp[48] + sp[49];
    sp[51] = J_c4 * J_c5;
    sp[52] = sp[50] + sp[51];
    sp[53] = sp[52] * sp[52];
    sp[54] = sp[47] + -1 * sp[53];
    sp[55] = sp[41] / sp[54];
    sp[56] = J_c0 * sp[55];
    sp[57] = -1 * sp[52] / sp[54];
    sp[58] = J_c1 * sp[57];
    sp[59] = sp[56] + sp[58];
    sp[60] = sp[59] * sp[16];
    sp[61] = sp[46] / sp[54];
    sp[62] = J_c1 * sp[61];
    sp[63] = J_c0 * sp[57];
    sp[64] = sp[62] + sp[63];
    sp[65] = sp[64] * sp[17];
    sp[66] = J_c2 * sp[55];
    sp[67] = J_c3 * sp[57];
    sp[68] = sp[66] + sp[67];
    sp[69] = sp[68] * sp[21];
    sp[70] = J_c3 * sp[61];
    sp[71] = J_c2 * sp[57];
    sp[72] = sp[70] + sp[71];
    sp[73] = sp[72] * sp[22];
    sp[74] = sp[60] + sp[69];
    sp[75] = sp[65] + sp[73];
    sp[76] = J_c4 * sp[55];
    sp[77] = J_c5 * sp[57];
    sp[78] = sp[76] + sp[77];
    sp[79] = sp[78] * sp[29];
    sp[80] = J_c5 * sp[61];
    sp[81] = J_c4 * sp[57];
    sp[82] = sp[80] + sp[81];
    sp[83] = sp[82] * sp[30];
    sp[84] = sp[74] + sp[79];
    sp[85] = sp[75] + sp[83];
    sp[86] = fabs(sp[15]);
    sp[87] = sp[34] * sp[86];
    sp[88] = sp[35] * sp[86];
    sp[89] = sp[36] * sp[86];
    sp[90] = sp[84] * sp[86];
    sp[91] = sp[85] * sp[86];
    // UFLACS block mode: preintegrated
    A[0] += 0.08333333333333331 * sp[87] + 0.04166666666666662 * sp[88] + 0.04166666666666662 * sp[88] + 0.0833333333333332 * sp[89];
    A[1] += 0.08333333333333326 * sp[87] + -0.04166666666666663 * sp[88] + 0.1249999999999999 * sp[88] + -0.08333333333333322 * sp[89];
    A[2] += 0.08333333333333334 * sp[87] + -0.125 * sp[88] + 0.04166666666666663 * sp[88] + -0.08333333333333326 * sp[89];
    A[3] += 0.5 * sp[90] + 0.5 * sp[91];
    A[4] += 0.08333333333333326 * sp[87] + 0.1249999999999999 * sp[88] + -0.04166666666666663 * sp[88] + -0.08333333333333322 * sp[89];
    A[5] += 0.2499999999999999 * sp[87] + -0.1249999999999999 * sp[88] + -0.1249999999999999 * sp[88] + 0.08333333333333323 * sp[89];
    A[6] += 0.08333333333333331 * sp[87] + -0.2083333333333333 * sp[88] + -0.04166666666666665 * sp[88] + 0.08333333333333329 * sp[89];
    A[7] += -0.5 * sp[90] + -0.5 * sp[91];
    A[8] += 0.08333333333333334 * sp[87] + 0.04166666666666663 * sp[88] + -0.125 * sp[88] + -0.08333333333333326 * sp[89];
    A[9] += 0.08333333333333331 * sp[87] + -0.04166666666666665 * sp[88] + -0.2083333333333333 * sp[88] + 0.08333333333333329 * sp[89];
    A[10] += 0.08333333333333337 * sp[87] + -0.125 * sp[88] + -0.125 * sp[88] + 0.25 * sp[89];
    A[11] += 0.5 * sp[90] + 0.5 * sp[91];
    A[12] += 0.5 * sp[90] + 0.5 * sp[91];
    A[13] += -0.5 * sp[90] + -0.5 * sp[91];
    A[14] += 0.5 * sp[90] + 0.5 * sp[91];
}


fenics_integral* create_projectionmanifold_cell_integral_527128f7582c21965f4042addb76df3f7dbaf133_otherwise(void)
{
  static const bool enabled[] = {};

  fenics_integral* integral = malloc(sizeof(*integral));
  integral->enabled_coefficients = enabled;
  integral->tabulate_tensor = tabulate_tensor_projectionmanifold_cell_integral_527128f7582c21965f4042addb76df3f7dbaf133_otherwise;
  return integral;
};

// End of code for integral projectionmanifold_cell_integral_527128f7582c21965f4042addb76df3f7dbaf133_otherwise

// Code for form projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133

int original_coefficient_position_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int i)
{
// Invalid original coefficient index.
return -1;
}

// Return a list of the coefficient names.
const char** coefficient_name_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(void)
{
return NULL;
}

// Return a list of the constant names.
const char** constant_name_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(void)
{
return NULL;
}

fenics_finite_element* create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main(void);

fenics_finite_element* create_coordinate_finite_element_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(void)
{
return create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_finite_element_main();
}

fenics_dofmap* create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main(void);

fenics_dofmap* create_coordinate_dofmap_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(void)
{
return create_ffc_element_00c4f887274108ede49e22d389d4fa98583707d6_dofmap_main();
}

fenics_coordinate_mapping* create_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main(void);

fenics_coordinate_mapping* create_coordinate_mapping_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(void)
{
return create_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main();
}

fenics_finite_element* create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main(void);

fenics_finite_element* create_finite_element_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main();
case 1:
    return create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main(void);

fenics_dofmap* create_dofmap_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main();
case 1:
    return create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main();
default:
    return NULL;
}
}

fenics_integral* create_cell_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int subdomain_id)
{
  switch (subdomain_id)
{
case -1:
    return create_projectionmanifold_cell_integral_527128f7582c21965f4042addb76df3f7dbaf133_otherwise();
default:
    return NULL;
}
}

void get_cell_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int *ids)
{
  ids[0] = -1;
return;
}

fenics_integral* create_exterior_facet_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int subdomain_id)
{
  return NULL;
}

void get_exterior_facet_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int *ids)
{
  return;
}

fenics_integral* create_interior_facet_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int subdomain_id)
{
return NULL;
}

void get_interior_facet_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int *ids)
{
  return;
}

fenics_integral* create_vertex_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int subdomain_id)
{
return NULL;
}

void get_vertex_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int *ids)
{
  return;
}

fenics_custom_integral* create_custom_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int subdomain_id)
{
return NULL;
}

void get_custom_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(int *ids)
{
  return;
}

fenics_form* create_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133(void)
{
  fenics_form* form = malloc(sizeof(*form));

  form->signature = "2023e4577843e76e5707a1b77239c1dd5e1ede5156ace61719d5311ae57c68e022a45cf8e690d490b934a7b7691556663d1da113935cfe58cb5ec75ba59c633c";
  form->rank = 2;
  form->num_coefficients = 0;
  form->num_constants = 0;
  form->original_coefficient_position = original_coefficient_position_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;

  form->coefficient_name_map = coefficient_name_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->constant_name_map = constant_name_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;

  form->create_coordinate_finite_element = create_coordinate_finite_element_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->create_coordinate_dofmap = create_coordinate_dofmap_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->create_coordinate_mapping = create_coordinate_mapping_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->create_finite_element = create_finite_element_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->create_dofmap = create_dofmap_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;

  form->get_cell_integral_ids = get_cell_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->get_exterior_facet_integral_ids = get_exterior_facet_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->get_interior_facet_integral_ids = get_interior_facet_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->get_vertex_integral_ids = get_vertex_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->get_custom_integral_ids = get_custom_integral_ids_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;

  form->num_cell_integrals = 1;
  form->num_exterior_facet_integrals = 0;
  form->num_interior_facet_integrals = 0;
  form->num_vertex_integrals = 0;
  form->num_custom_integrals = 0;

  form->create_cell_integral = create_cell_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->create_exterior_facet_integral = create_exterior_facet_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->create_interior_facet_integral = create_interior_facet_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->create_vertex_integral = create_vertex_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;
  form->create_custom_integral = create_custom_integral_projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133;

  return form;
};

// End of code for form projectionmanifold_form_527128f7582c21965f4042addb76df3f7dbaf133

fenics_function_space* ProjectionManifold_form_a_functionspace_0_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  space->create_dofmap = create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  return space;
}

fenics_function_space* ProjectionManifold_form_a_functionspace_1_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_finite_element_main;
  space->create_dofmap = create_ffc_element_f10587c15df573ac034509fb41be2be9a1172362_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_079a224bd032d90b8fb0bceb8208537b09f4761a_coordinate_mapping_main;
  return space;
}

