// This code conforms with the UFC specification version 2018.2.0.dev0
// and was automatically generated by FFC version 2019.2.0.dev0.
//
// This code was generated with the following parameters:
//
//  {'epsilon': 1e-14,
//   'external_include_dirs': '',
//   'external_includes': '',
//   'precision': None,
//   'quadrature_degree': None,
//   'quadrature_rule': None,
//   'representation': 'uflacs',
//   'scalar_type': 'double',
//   'timeout': 10}


typedef double fenics_scalar_t;
#include <fenics_interface.h>
#include <math.h>
#include <stdalign.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

// Code for element ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main

int value_dimension_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(int i)
{
  return 1;
}

int reference_value_dimension_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(int i)
{
  return 1;
}

int evaluate_reference_basis_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
for (int64_t k = 0; k < num_points * 3; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 3; ++r)
        reference_values[3 * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[3 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[3 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(2, order);
for (int64_t l0 = 0; l0 < num_points * 3 * num_derivatives; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[2][3][3] =
    { { { 0.0, 0.0, 0.0 },
        { 4.8989794855663495, 0.0, 0.0 },
        { 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0 },
        { 2.449489742783182, 0.0, 0.0 },
        { 4.242640687119285, 0.0, 0.0 } } };
static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
const int64_t reference_offset[3] = { 0 };
const int64_t num_components[3] = { 1, 1, 1 };
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Loop over all dofs
    for (int64_t i = 0; i < 3; ++i)
    {
        double derivatives[2] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[3 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives = pow(2, order);
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t l = 0; l < num_points * 3 * num_derivatives; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[3] = { 0 };
const int64_t physical_offsets[3] = { 0 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[2][2];
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
    for (int64_t d = 0; d < 3; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[3 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[3 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[1];
reference_values[2] = physical_values[2];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[6] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
memcpy(reference_dof_coordinates, dof_X, 6*sizeof(double));
return 0;
}


fenics_finite_element* create_sub_element_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(int i)
{
  return NULL;
}

fenics_finite_element* create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "FiniteElement('Lagrange', triangle, 1)";
  element->cell_shape = triangle;
  element->topological_dimension = 2;
  element->geometric_dimension = 2;
  element->space_dimension = 3;
  element->value_rank = 0;
  element->value_dimension = value_dimension_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main;
  element->value_size = 1;
  element->reference_value_rank = 0;
  element->reference_value_dimension = reference_value_dimension_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main;
  element->reference_value_size = 1;
  element->degree = 1;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main;
  element->transform_values = transform_values_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main;
  element->num_sub_elements = 0;
  element->create_sub_element = create_sub_element_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main;
  element->create = create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main;

  return element;
};

// End of code for element ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main

// Code for element ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main

int value_dimension_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(int i)
{
  static const int return_values[1] = { 2 };
if (i >= 1)
    return 1;
return return_values[i];
}

int reference_value_dimension_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(int i)
{
  static const int return_values[1] = { 2 };
if (i >= 1)
    return 1;
return return_values[i];
}

int evaluate_reference_basis_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
for (int64_t k = 0; k < num_points * 6 * 2; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 3; ++r)
        reference_values[6 * 2 * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[6 * 2 * ip + 2] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[6 * 2 * ip + 2 * 2] += coefficients2[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[6 * 2 * ip + 2 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[6 * 2 * ip + 2 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[6 * 2 * ip + 2 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(2, order);
for (int64_t l0 = 0; l0 < num_points * 6 * num_derivatives * 2; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[2][3][3] =
    { { { 0.0, 0.0, 0.0 },
        { 4.8989794855663495, 0.0, 0.0 },
        { 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0 },
        { 2.449489742783182, 0.0, 0.0 },
        { 4.242640687119285, 0.0, 0.0 } } };
static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
const int64_t reference_offset[6] = { 0, 0, 0, 1, 1, 1 };
const int64_t num_components[6] = { 1, 1, 1, 1, 1, 1 };
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Loop over all dofs
    for (int64_t i = 0; i < 6; ++i)
    {
        double derivatives[2] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 4:
            // Compute reference derivatives for dof 4.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 5:
            // Compute reference derivatives for dof 5.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * i + 2 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives = pow(2, order);
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t l = 0; l < num_points * 6 * num_derivatives * 2; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[6] = { 0, 0, 0, 1, 1, 1 };
const int64_t physical_offsets[6] = { 0, 0, 0, 1, 1, 1 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[2][2];
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
    for (int64_t d = 0; d < 6; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[2];
reference_values[2] = physical_values[4];
reference_values[3] = physical_values[7];
reference_values[4] = physical_values[9];
reference_values[5] = physical_values[11];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[12] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
memcpy(reference_dof_coordinates, dof_X, 12*sizeof(double));
return 0;
}

fenics_finite_element* create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(void);

fenics_finite_element* create_sub_element_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(int i)
{
  switch (i)
{
case 0:
    return create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main();
case 1:
    return create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main();
default:
    return NULL;
}
}

fenics_finite_element* create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
  element->cell_shape = triangle;
  element->topological_dimension = 2;
  element->geometric_dimension = 2;
  element->space_dimension = 6;
  element->value_rank = 1;
  element->value_dimension = value_dimension_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main;
  element->value_size = 2;
  element->reference_value_rank = 1;
  element->reference_value_dimension = reference_value_dimension_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main;
  element->reference_value_size = 2;
  element->degree = 1;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main;
  element->transform_values = transform_values_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main;
  element->num_sub_elements = 2;
  element->create_sub_element = create_sub_element_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main;
  element->create = create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main;

  return element;
};

// End of code for element ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main

// Code for element ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main

int value_dimension_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(int i)
{
  return 1;
}

int reference_value_dimension_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(int i)
{
  return 1;
}

int evaluate_reference_basis_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
for (int64_t k = 0; k < num_points * 3; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 3; ++r)
        reference_values[3 * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[3 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 3; ++r)
        reference_values[3 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(2, order);
for (int64_t l0 = 0; l0 < num_points * 3 * num_derivatives; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[2][3][3] =
    { { { 0.0, 0.0, 0.0 },
        { 4.8989794855663495, 0.0, 0.0 },
        { 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0 },
        { 2.449489742783182, 0.0, 0.0 },
        { 4.242640687119285, 0.0, 0.0 } } };
static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
const int64_t reference_offset[3] = { 0 };
const int64_t num_components[3] = { 1, 1, 1 };
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[3] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.5);
    basisvalues1[2] *= sqrt(1.0);
    basisvalues1[1] *= sqrt(3.0);
    // Loop over all dofs
    for (int64_t i = 0; i < 3; ++i)
    {
        double derivatives[2] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[3] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[3][3] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 9*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[3][3];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 9*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 3; ++l0)
                        for (int64_t l1 = 0; l1 < 3; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 3; ++t)
                        for (int64_t u = 0; u < 3; ++u)
                            for (int64_t tu = 0; tu < 3; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 3; ++s)
                    for (int64_t t = 0; t < 3; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 3; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[3 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives = pow(2, order);
// Precomputed combinations
const int64_t combinations[1][2][1] =
    { { { 0 },
        { 1 } } };
for (int64_t l = 0; l < num_points * 3 * num_derivatives; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[3] = { 0 };
const int64_t physical_offsets[3] = { 0 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[2][2];
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
    for (int64_t d = 0; d < 3; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[3 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[3 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[1];
reference_values[2] = physical_values[2];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[6] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
memcpy(reference_dof_coordinates, dof_X, 6*sizeof(double));
return 0;
}


fenics_finite_element* create_sub_element_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(int i)
{
  return NULL;
}

fenics_finite_element* create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "FiniteElement('Discontinuous Lagrange', triangle, 1)";
  element->cell_shape = triangle;
  element->topological_dimension = 2;
  element->geometric_dimension = 2;
  element->space_dimension = 3;
  element->value_rank = 0;
  element->value_dimension = value_dimension_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  element->value_size = 1;
  element->reference_value_rank = 0;
  element->reference_value_dimension = reference_value_dimension_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  element->reference_value_size = 1;
  element->degree = 1;
  element->family = "Discontinuous Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  element->transform_values = transform_values_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  element->num_sub_elements = 0;
  element->create_sub_element = create_sub_element_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  element->create = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;

  return element;
};

// End of code for element ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main

// Code for dofmap ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main

void tabulate_entity_dofs_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    case 2:
        dofs[0] = 2;
        break;
    }
    break;
}
}


fenics_dofmap* create_sub_dofmap_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main(int i)
{
return NULL;
}

fenics_dofmap* create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for FiniteElement('Lagrange', triangle, 1)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 3;
  dofmap->num_entity_dofs[0] = 1;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main;
  dofmap->num_sub_dofmaps = 0;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main;
  dofmap->create = create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main

// Code for dofmap ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main

void tabulate_entity_dofs_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        dofs[1] = 3;
        break;
    case 1:
        dofs[0] = 1;
        dofs[1] = 4;
        break;
    case 2:
        dofs[0] = 2;
        dofs[1] = 5;
        break;
    }
    break;
}
}

fenics_dofmap* create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main(void);

fenics_dofmap* create_sub_dofmap_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main();
case 1:
    return create_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_dofmap_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 6;
  dofmap->num_entity_dofs[0] = 2;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main;
  dofmap->num_sub_dofmaps = 2;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main;
  dofmap->create = create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main

// Code for dofmap ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main

void tabulate_entity_dofs_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 2:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 2;
        break;
    }
    break;
}
}


fenics_dofmap* create_sub_dofmap_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main(int i)
{
return NULL;
}

fenics_dofmap* create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for FiniteElement('Discontinuous Lagrange', triangle, 1)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 3;
  dofmap->num_entity_dofs[0] = 0;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 3;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main;
  dofmap->num_sub_dofmaps = 0;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main;
  dofmap->create = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main

// Code for coordinate mapping ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main

fenics_finite_element* create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(void);

fenics_finite_element* create_coordinate_finite_element_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(void)
{
return create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main();
}

fenics_dofmap* create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main(void);

fenics_dofmap* create_coordinate_dofmap_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(void)
{
return create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main();
}


int evaluate_reference_basis_derivatives_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(double* restrict reference_values,
    int order, int num_points, const double* restrict X);

void compute_jacobians_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(double* restrict J, int num_points,
                                      const double* restrict X,
                                      const double* restrict coordinate_dofs)
{
double dphi[6];
for (int64_t l = 0; l < num_points * 2 * 2; ++l)
    J[l] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Compute basis derivatives of coordinate element
    evaluate_reference_basis_derivatives_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(dphi, 1, 1, &X[2 * ip]);
    // Compute J
    for (int64_t i = 0; i < 2; ++i)
        for (int64_t j = 0; j < 2; ++j)
            for (int64_t d = 0; d < 3; ++d)
                J[2 * 2 * ip + 2 * i + j] += coordinate_dofs[2 * d + i] * dphi[2 * d + j];
}
}

void compute_jacobian_determinants_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(double* restrict detJ, int num_points,
                                                  const double* restrict J, int cell_orientation)
{
for (int64_t ip = 0; ip < num_points; ++ip)
    detJ[ip] = J[2 * 2 * ip] * J[2 * 2 * ip + 2 + 1] - J[2 * 2 * ip + 1] * J[2 * 2 * ip + 2];
}

void compute_jacobian_inverses_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(double* restrict K, int num_points,
    const double* restrict J, const double* restrict detJ)
{
for (int64_t ip = 0; ip < num_points; ++ip)
{
    K[2 * 2 * ip] = J[2 * 2 * ip + 2 + 1] / detJ[ip];
    K[2 * 2 * ip + 1] = -J[2 * 2 * ip + 1] / detJ[ip];
    K[2 * 2 * ip + 2] = -J[2 * 2 * ip + 2] / detJ[ip];
    K[2 * 2 * ip + 2 + 1] = J[2 * 2 * ip] / detJ[ip];
}
}


int evaluate_reference_basis_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(double* restrict reference_values,
    int num_points, const double* restrict X);

void compute_physical_coordinates_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(double* restrict x, int num_points,
                                                 const double* restrict X,
                                                 const double* restrict coordinate_dofs)
{
double phi[3];
for (int64_t i = 0; i < num_points * 2; ++i)
    x[i] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Compute basis values of coordinate element
    evaluate_reference_basis_ffc_element_496dcc2f002f8bd29234476a4c8fa0a3efd63efb_finite_element_main(phi, 1, &X[2 * ip]);
    // Compute x
    for (int64_t i = 0; i < 2; ++i)
        for (int64_t d = 0; d < 3; ++d)
            x[2 * ip + i] += coordinate_dofs[2 * d + i] * phi[d];
}
}

void compute_geometry_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(double* restrict x, double* restrict J,
                                     double* restrict detJ, double* restrict K,
                                     int num_points, const double* restrict X,
                                     const double* restrict coordinate_dofs,
                                     int cell_orientation)
{
compute_physical_coordinates_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(x, num_points, X, coordinate_dofs);
compute_jacobians_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(J, num_points, X, coordinate_dofs);
compute_jacobian_determinants_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(detJ, num_points, J, cell_orientation);
compute_jacobian_inverses_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(K, num_points, J, detJ);
}

void compute_midpoint_geometry_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(double* restrict x, double* restrict J,
                                              const double* restrict coordinate_dofs)
{
const double phi_Xm[3] = { 0.33333333333333337, 0.33333333333333337, 0.3333333333333333 };
const double dphi_Xm[2][3] =
    { { -1.0, 1.0, 0.0 },
      { -1.0, 0.0, 1.0 } };
for (int64_t l = 0; l < 4; ++l)
    J[l] = 0.0;
// Compute x
for (int64_t i = 0; i < 2; ++i)
{
    x[i] = 0.0;
    for (int64_t d = 0; d < 3; ++d)
        x[i] += coordinate_dofs[2 * d + i] * phi_Xm[d];
}
// Compute J
for (int64_t i = 0; i < 2; ++i)
    for (int64_t j = 0; j < 2; ++j)
        for (int64_t d = 0; d < 3; ++d)
            J[2 * i + j] += coordinate_dofs[2 * d + i] * dphi_Xm[j][d];
}

void compute_reference_coordinates_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(double* restrict X, int num_points,
                                                  const double* restrict x,
                                                  const double* restrict coordinate_dofs,
                                                  int cell_orientation)
{
for (int64_t l = 0; l < num_points * 2; ++l)
    X[l] = 0.0;
const double phi_X0[3] = { 1.0, 0.0, 0.0 };
const double dphi_X0[2][3] =
    { { -1.0, 1.0, 0.0 },
      { -1.0, 0.0, 1.0 } };
double J[4];
double detJ[1];
double K[4];
double x0[2] = { 0 };
for (int64_t i = 0; i < 2; ++i)
    for (int64_t k = 0; k < 3; ++k)
        x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
for (int64_t i = 0; i < 2; ++i)
{
    for (int64_t j = 0; j < 2; ++j)
    {
        J[2 * i + j] = 0.0;
        for (int64_t k = 0; k < 3; ++k)
            J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
    }
}
compute_jacobian_determinants_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(detJ, 1, J, cell_orientation);
compute_jacobian_inverses_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(K, 1, J, detJ);
for (int64_t ip = 0; ip < num_points; ++ip)
    for (int64_t j = 0; j < 2; ++j)
        for (int64_t i = 0; i < 2; ++i)
            X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}

void compute_reference_geometry_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(double* restrict X, double* restrict J,
                                               double* restrict detJ, double* restrict K,
                                               int num_points, const double* restrict x,
                                               const double* restrict coordinate_dofs,
                                               int cell_orientation)
{
for (int64_t l = 0; l < num_points * 2; ++l)
    X[l] = 0.0;
const double phi_X0[3] = { 1.0, 0.0, 0.0 };
const double dphi_X0[2][3] =
    { { -1.0, 1.0, 0.0 },
      { -1.0, 0.0, 1.0 } };
double x0[2] = { 0 };
for (int64_t i = 0; i < 2; ++i)
    for (int64_t k = 0; k < 3; ++k)
        x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
for (int64_t i = 0; i < 2; ++i)
{
    for (int64_t j = 0; j < 2; ++j)
    {
        J[2 * i + j] = 0.0;
        for (int64_t k = 0; k < 3; ++k)
            J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
    }
}
compute_jacobian_determinants_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(detJ, 1, J, cell_orientation);
compute_jacobian_inverses_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(K, 1, J, detJ);
for (int64_t ip = 0; ip < num_points; ++ip)
    for (int64_t j = 0; j < 2; ++j)
        for (int64_t i = 0; i < 2; ++i)
            X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}




fenics_coordinate_mapping* create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(void)
{
  fenics_coordinate_mapping* cmap = malloc(sizeof(*cmap));
  cmap->signature = "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
  cmap->create = create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->geometric_dimension = 2;
  cmap->topological_dimension = 2;
  cmap->cell_shape = triangle;
  cmap->create_coordinate_finite_element = create_coordinate_finite_element_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->create_coordinate_dofmap = create_coordinate_dofmap_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->compute_physical_coordinates = compute_physical_coordinates_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->compute_reference_coordinates = compute_reference_coordinates_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->compute_reference_geometry = compute_reference_geometry_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->compute_jacobians = compute_jacobians_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->compute_jacobian_determinants = compute_jacobian_determinants_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->compute_jacobian_inverses = compute_jacobian_inverses_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->compute_geometry = compute_geometry_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  cmap->compute_midpoint_geometry = compute_midpoint_geometry_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  return cmap;
}

// End of code for coordinate mapping ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main

// Code for integral poissondg_cell_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise


void tabulate_tensor_poissondg_cell_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise(fenics_scalar_t* restrict A, const fenics_scalar_t* w,
                                    const fenics_scalar_t* c,
                                    const double* restrict coordinate_dofs,
                                    const int* unused_local_index,
                                    const int* cell_orientation)
{
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const fenics_scalar_t FE4_C0_D01_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE4_C0_D01_Q1[0][0][0] + coordinate_dofs[2] * FE4_C0_D01_Q1[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE4_C0_D01_Q1[0][0][0] + coordinate_dofs[5] * FE4_C0_D01_Q1[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE4_C0_D01_Q1[0][0][0] + coordinate_dofs[4] * FE4_C0_D01_Q1[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE4_C0_D01_Q1[0][0][0] + coordinate_dofs[3] * FE4_C0_D01_Q1[0][0][1];
    alignas(32) fenics_scalar_t sp[20];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = -1 * J_c1 / sp[2];
    sp[5] = sp[3] * sp[3];
    sp[6] = sp[3] * sp[4];
    sp[7] = sp[4] * sp[4];
    sp[8] = J_c3 / sp[2];
    sp[9] = -1 * J_c2 / sp[2];
    sp[10] = sp[9] * sp[9];
    sp[11] = sp[8] * sp[9];
    sp[12] = sp[8] * sp[8];
    sp[13] = sp[5] + sp[10];
    sp[14] = sp[6] + sp[11];
    sp[15] = sp[12] + sp[7];
    sp[16] = fabs(sp[2]);
    sp[17] = sp[13] * sp[16];
    sp[18] = sp[14] * sp[16];
    sp[19] = sp[15] * sp[16];
    // UFLACS block mode: preintegrated
    A[0] += 0.5 * sp[19] + 0.5 * sp[18] + 0.5 * sp[18] + 0.5 * sp[17];
    A[1] += -0.5 * sp[19] + -0.5 * sp[18];
    A[2] += -0.5 * sp[18] + -0.5 * sp[17];
    A[3] += -0.5 * sp[19] + -0.5 * sp[18];
    A[4] += 0.5 * sp[19];
    A[5] += 0.5 * sp[18];
    A[6] += -0.5 * sp[18] + -0.5 * sp[17];
    A[7] += 0.5 * sp[18];
    A[8] += 0.5 * sp[17];
}


fenics_integral* create_poissondg_cell_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise(void)
{
  static const bool enabled[] = {};

  fenics_integral* integral = malloc(sizeof(*integral));
  integral->enabled_coefficients = enabled;
  integral->tabulate_tensor = tabulate_tensor_poissondg_cell_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise;
  return integral;
};

// End of code for integral poissondg_cell_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise

// Code for integral poissondg_exterior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise


void tabulate_tensor_poissondg_exterior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise(fenics_scalar_t* restrict A, const fenics_scalar_t* w,
                                    const fenics_scalar_t* c,
                                    const double* restrict coordinate_dofs,
                                    const int* facet,
                                    const int* cell_orientation)
{
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const fenics_scalar_t FE10_C0_D01_F_Q2[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const fenics_scalar_t PI0[3][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 0.0, 0.3333333333333334, 0.1666666666666667 },
            { 0.0, 0.1666666666666667, 0.3333333333333334 } },
          { { 0.3333333333333334, 0.0, 0.1666666666666667 },
            { 0.0, 0.0, 0.0 },
            { 0.1666666666666667, 0.0, 0.3333333333333334 } },
          { { 0.3333333333333334, 0.1666666666666667, 0.0 },
            { 0.1666666666666667, 0.3333333333333334, 0.0 },
            { 0.0, 0.0, 0.0 } } };
    alignas(32) static const fenics_scalar_t PI1[3][3][2] =
        { { { 0.0, 0.0 },
            { -0.5, 0.5 },
            { -0.5, 0.5 } },
          { { -0.5, 0.5 },
            { 0.0, 0.0 },
            { -0.5, 0.5 } },
          { { -0.5, 0.5 },
            { -0.5, 0.5 },
            { 0.0, 0.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE10_C0_D01_F_Q2[0][0][0] + coordinate_dofs[2] * FE10_C0_D01_F_Q2[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE10_C0_D01_F_Q2[0][0][0] + coordinate_dofs[5] * FE10_C0_D01_F_Q2[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE10_C0_D01_F_Q2[0][0][0] + coordinate_dofs[4] * FE10_C0_D01_F_Q2[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE10_C0_D01_F_Q2[0][0][0] + coordinate_dofs[3] * FE10_C0_D01_F_Q2[0][0][1];
    alignas(32) fenics_scalar_t sp[55];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = -1 * J_c1 / sp[2];
    sp[5] = triangle_reference_facet_normals[facet[0]][1] * sp[3];
    sp[6] = triangle_reference_facet_normals[facet[0]][0] * sp[4];
    sp[7] = sp[5] + sp[6];
    sp[8] = sp[7] * sp[7];
    sp[9] = J_c3 / sp[2];
    sp[10] = triangle_reference_facet_normals[facet[0]][0] * sp[9];
    sp[11] = -1 * J_c2 / sp[2];
    sp[12] = triangle_reference_facet_normals[facet[0]][1] * sp[11];
    sp[13] = sp[10] + sp[12];
    sp[14] = sp[13] * sp[13];
    sp[15] = sp[8] + sp[14];
    sp[16] = sqrt(sp[15]);
    sp[17] = sp[7] / sp[16];
    sp[18] = sp[3] * sp[17];
    sp[19] = sp[4] * sp[17];
    sp[20] = sp[13] / sp[16];
    sp[21] = sp[11] * sp[20];
    sp[22] = sp[9] * sp[20];
    sp[23] = sp[18] + sp[21];
    sp[24] = sp[19] + sp[22];
    sp[25] = (coordinate_dofs[2] - coordinate_dofs[4]) * (coordinate_dofs[2] - coordinate_dofs[4]);
    sp[26] = (coordinate_dofs[3] - coordinate_dofs[5]) * (coordinate_dofs[3] - coordinate_dofs[5]);
    sp[27] = sp[25] + sp[26];
    sp[28] = sqrt(sp[27]);
    sp[29] = (coordinate_dofs[0] - coordinate_dofs[4]) * (coordinate_dofs[0] - coordinate_dofs[4]);
    sp[30] = (coordinate_dofs[1] - coordinate_dofs[5]) * (coordinate_dofs[1] - coordinate_dofs[5]);
    sp[31] = sp[29] + sp[30];
    sp[32] = sqrt(sp[31]);
    sp[33] = sp[28] * sp[32];
    sp[34] = (coordinate_dofs[0] - coordinate_dofs[2]) * (coordinate_dofs[0] - coordinate_dofs[2]);
    sp[35] = (coordinate_dofs[1] - coordinate_dofs[3]) * (coordinate_dofs[1] - coordinate_dofs[3]);
    sp[36] = sp[34] + sp[35];
    sp[37] = sqrt(sp[36]);
    sp[38] = sp[33] * sp[37];
    sp[39] = triangle_reference_cell_volume * sp[2];
    sp[40] = fabs(sp[39]);
    sp[41] = sp[38] / (4.0 * sp[40]);
    sp[42] = J_c0 * triangle_reference_facet_jacobian[facet[0]][0][0];
    sp[43] = J_c1 * triangle_reference_facet_jacobian[facet[0]][1][0];
    sp[44] = sp[42] + sp[43];
    sp[45] = sp[44] * sp[44];
    sp[46] = triangle_reference_facet_jacobian[facet[0]][0][0] * J_c2;
    sp[47] = triangle_reference_facet_jacobian[facet[0]][1][0] * J_c3;
    sp[48] = sp[46] + sp[47];
    sp[49] = sp[48] * sp[48];
    sp[50] = sp[45] + sp[49];
    sp[51] = sqrt(sp[50]);
    sp[52] = -1 * sp[23] * sp[51];
    sp[53] = -1 * sp[24] * sp[51];
    sp[54] = 8.0 / (2.0 * sp[41]) * sp[51];
    // UFLACS block mode: preintegrated
    A[0] += PI1[facet[0]][0][0] * sp[53] + PI1[facet[0]][0][0] * sp[53] + PI0[facet[0]][0][0] * sp[54] + PI1[facet[0]][0][0] * sp[52] + PI1[facet[0]][0][0] * sp[52];
    A[1] += PI1[facet[0]][1][0] * sp[53] + PI1[facet[0]][0][1] * sp[53] + PI0[facet[0]][0][1] * sp[54] + PI1[facet[0]][1][0] * sp[52];
    A[2] += PI1[facet[0]][2][0] * sp[53] + PI0[facet[0]][0][2] * sp[54] + PI1[facet[0]][0][1] * sp[52] + PI1[facet[0]][2][0] * sp[52];
    A[3] += PI1[facet[0]][0][1] * sp[53] + PI1[facet[0]][1][0] * sp[53] + PI0[facet[0]][1][0] * sp[54] + PI1[facet[0]][1][0] * sp[52];
    A[4] += PI1[facet[0]][1][1] * sp[53] + PI1[facet[0]][1][1] * sp[53] + PI0[facet[0]][1][1] * sp[54];
    A[5] += PI1[facet[0]][2][1] * sp[53] + PI0[facet[0]][1][2] * sp[54] + PI1[facet[0]][1][1] * sp[52];
    A[6] += PI1[facet[0]][2][0] * sp[53] + PI0[facet[0]][2][0] * sp[54] + PI1[facet[0]][2][0] * sp[52] + PI1[facet[0]][0][1] * sp[52];
    A[7] += PI1[facet[0]][2][1] * sp[53] + PI0[facet[0]][2][1] * sp[54] + PI1[facet[0]][1][1] * sp[52];
    A[8] += PI0[facet[0]][2][2] * sp[54] + PI1[facet[0]][2][1] * sp[52] + PI1[facet[0]][2][1] * sp[52];
}


fenics_integral* create_poissondg_exterior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise(void)
{
  static const bool enabled[] = {};

  fenics_integral* integral = malloc(sizeof(*integral));
  integral->enabled_coefficients = enabled;
  integral->tabulate_tensor = tabulate_tensor_poissondg_exterior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise;
  return integral;
};

// End of code for integral poissondg_exterior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise

// Code for integral poissondg_interior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise


void tabulate_tensor_poissondg_interior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise(fenics_scalar_t* restrict A, const fenics_scalar_t* w,
                                    const fenics_scalar_t* c,
                                    const double* restrict coordinate_dofs,
                                    const int* facet,
                                    const int* cell_orientation)
{
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const fenics_scalar_t FE20_C0_D01_F_Q2[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const fenics_scalar_t PI0[3][3][3][3] =
        { { { { 0.0, 0.0, 0.0 },
              { 0.0, 0.3333333333333334, 0.1666666666666667 },
              { 0.0, 0.1666666666666667, 0.3333333333333334 } },
            { { 0.0, 0.0, 0.0 },
              { 0.3333333333333334, 0.0, 0.1666666666666667 },
              { 0.1666666666666667, 0.0, 0.3333333333333334 } },
            { { 0.0, 0.0, 0.0 },
              { 0.3333333333333334, 0.1666666666666667, 0.0 },
              { 0.1666666666666667, 0.3333333333333334, 0.0 } } },
          { { { 0.0, 0.3333333333333334, 0.1666666666666667 },
              { 0.0, 0.0, 0.0 },
              { 0.0, 0.1666666666666667, 0.3333333333333334 } },
            { { 0.3333333333333334, 0.0, 0.1666666666666667 },
              { 0.0, 0.0, 0.0 },
              { 0.1666666666666667, 0.0, 0.3333333333333334 } },
            { { 0.3333333333333334, 0.1666666666666667, 0.0 },
              { 0.0, 0.0, 0.0 },
              { 0.1666666666666667, 0.3333333333333334, 0.0 } } },
          { { { 0.0, 0.3333333333333334, 0.1666666666666667 },
              { 0.0, 0.1666666666666667, 0.3333333333333334 },
              { 0.0, 0.0, 0.0 } },
            { { 0.3333333333333334, 0.0, 0.1666666666666667 },
              { 0.1666666666666667, 0.0, 0.3333333333333334 },
              { 0.0, 0.0, 0.0 } },
            { { 0.3333333333333334, 0.1666666666666667, 0.0 },
              { 0.1666666666666667, 0.3333333333333334, 0.0 },
              { 0.0, 0.0, 0.0 } } } };
    alignas(32) static const fenics_scalar_t PI1[3][3][3][2] =
        { { { { 0.0, 0.0 },
              { -0.5, 0.5 },
              { -0.5, 0.5 } },
            { { 0.0, 0.0 },
              { -0.5, 0.5 },
              { -0.5, 0.5 } },
            { { 0.0, 0.0 },
              { -0.5, 0.5 },
              { -0.5, 0.5 } } },
          { { { -0.5, 0.5 },
              { 0.0, 0.0 },
              { -0.5, 0.5 } },
            { { -0.5, 0.5 },
              { 0.0, 0.0 },
              { -0.5, 0.5 } },
            { { -0.5, 0.5 },
              { 0.0, 0.0 },
              { -0.5, 0.5 } } },
          { { { -0.5, 0.5 },
              { -0.5, 0.5 },
              { 0.0, 0.0 } },
            { { -0.5, 0.5 },
              { -0.5, 0.5 },
              { 0.0, 0.0 } },
            { { -0.5, 0.5 },
              { -0.5, 0.5 },
              { 0.0, 0.0 } } } };
    // Unstructured piecewise computations
    const double J_r0_c0 = coordinate_dofs[0] * FE20_C0_D01_F_Q2[0][0][0] + coordinate_dofs[2] * FE20_C0_D01_F_Q2[0][0][1];
    const double J_r0_c3 = coordinate_dofs[1] * FE20_C0_D01_F_Q2[0][0][0] + coordinate_dofs[5] * FE20_C0_D01_F_Q2[0][0][1];
    const double J_r0_c1 = coordinate_dofs[0] * FE20_C0_D01_F_Q2[0][0][0] + coordinate_dofs[4] * FE20_C0_D01_F_Q2[0][0][1];
    const double J_r0_c2 = coordinate_dofs[1] * FE20_C0_D01_F_Q2[0][0][0] + coordinate_dofs[3] * FE20_C0_D01_F_Q2[0][0][1];
    const double J_r1_c0 = coordinate_dofs[6] * FE20_C0_D01_F_Q2[0][0][0] + coordinate_dofs[8] * FE20_C0_D01_F_Q2[0][0][1];
    const double J_r1_c3 = coordinate_dofs[7] * FE20_C0_D01_F_Q2[0][0][0] + coordinate_dofs[11] * FE20_C0_D01_F_Q2[0][0][1];
    const double J_r1_c1 = coordinate_dofs[6] * FE20_C0_D01_F_Q2[0][0][0] + coordinate_dofs[10] * FE20_C0_D01_F_Q2[0][0][1];
    const double J_r1_c2 = coordinate_dofs[7] * FE20_C0_D01_F_Q2[0][0][0] + coordinate_dofs[9] * FE20_C0_D01_F_Q2[0][0][1];
    alignas(32) fenics_scalar_t sp[130];
    sp[0] = J_r0_c0 * J_r0_c3;
    sp[1] = J_r0_c1 * J_r0_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_r0_c0 / sp[2];
    sp[4] = triangle_reference_facet_normals[facet[0]][1] * sp[3];
    sp[5] = -1 * J_r0_c1 / sp[2];
    sp[6] = triangle_reference_facet_normals[facet[0]][0] * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = sp[7] * sp[7];
    sp[9] = J_r0_c3 / sp[2];
    sp[10] = triangle_reference_facet_normals[facet[0]][0] * sp[9];
    sp[11] = -1 * J_r0_c2 / sp[2];
    sp[12] = triangle_reference_facet_normals[facet[0]][1] * sp[11];
    sp[13] = sp[10] + sp[12];
    sp[14] = sp[13] * sp[13];
    sp[15] = sp[8] + sp[14];
    sp[16] = sqrt(sp[15]);
    sp[17] = sp[7] / sp[16];
    sp[18] = J_r1_c0 * J_r1_c3;
    sp[19] = J_r1_c1 * J_r1_c2;
    sp[20] = sp[18] + -1 * sp[19];
    sp[21] = J_r1_c0 / sp[20];
    sp[22] = triangle_reference_facet_normals[facet[1]][1] * sp[21];
    sp[23] = -1 * J_r1_c1 / sp[20];
    sp[24] = triangle_reference_facet_normals[facet[1]][0] * sp[23];
    sp[25] = sp[22] + sp[24];
    sp[26] = sp[25] * sp[25];
    sp[27] = J_r1_c3 / sp[20];
    sp[28] = triangle_reference_facet_normals[facet[1]][0] * sp[27];
    sp[29] = -1 * J_r1_c2 / sp[20];
    sp[30] = triangle_reference_facet_normals[facet[1]][1] * sp[29];
    sp[31] = sp[28] + sp[30];
    sp[32] = sp[31] * sp[31];
    sp[33] = sp[26] + sp[32];
    sp[34] = sqrt(sp[33]);
    sp[35] = sp[25] / sp[34];
    sp[36] = 0.5 * sp[3] * sp[17];
    sp[37] = 0.5 * sp[5] * sp[17];
    sp[38] = 0.5 * sp[21] * sp[17];
    sp[39] = 0.5 * sp[23] * sp[17];
    sp[40] = 0.5 * sp[3] * sp[35];
    sp[41] = 0.5 * sp[5] * sp[35];
    sp[42] = 0.5 * sp[21] * sp[35];
    sp[43] = 0.5 * sp[23] * sp[35];
    sp[44] = sp[13] / sp[16];
    sp[45] = sp[31] / sp[34];
    sp[46] = 0.5 * sp[11] * sp[44];
    sp[47] = 0.5 * sp[9] * sp[44];
    sp[48] = 0.5 * sp[29] * sp[44];
    sp[49] = 0.5 * sp[27] * sp[44];
    sp[50] = 0.5 * sp[11] * sp[45];
    sp[51] = 0.5 * sp[9] * sp[45];
    sp[52] = 0.5 * sp[29] * sp[45];
    sp[53] = 0.5 * sp[27] * sp[45];
    sp[54] = sp[36] + sp[46];
    sp[55] = sp[37] + sp[47];
    sp[56] = sp[38] + sp[48];
    sp[57] = sp[39] + sp[49];
    sp[58] = sp[40] + sp[50];
    sp[59] = sp[41] + sp[51];
    sp[60] = sp[42] + sp[52];
    sp[61] = sp[43] + sp[53];
    sp[62] = sp[17] * sp[17];
    sp[63] = sp[17] * sp[35];
    sp[64] = sp[35] * sp[35];
    sp[65] = sp[44] * sp[44];
    sp[66] = sp[44] * sp[45];
    sp[67] = sp[45] * sp[45];
    sp[68] = sp[62] + sp[65];
    sp[69] = sp[63] + sp[66];
    sp[70] = sp[64] + sp[67];
    sp[71] = (coordinate_dofs[2] - coordinate_dofs[4]) * (coordinate_dofs[2] - coordinate_dofs[4]);
    sp[72] = (coordinate_dofs[3] - coordinate_dofs[5]) * (coordinate_dofs[3] - coordinate_dofs[5]);
    sp[73] = sp[71] + sp[72];
    sp[74] = sqrt(sp[73]);
    sp[75] = (coordinate_dofs[0] - coordinate_dofs[4]) * (coordinate_dofs[0] - coordinate_dofs[4]);
    sp[76] = (coordinate_dofs[1] - coordinate_dofs[5]) * (coordinate_dofs[1] - coordinate_dofs[5]);
    sp[77] = sp[75] + sp[76];
    sp[78] = sqrt(sp[77]);
    sp[79] = sp[74] * sp[78];
    sp[80] = (coordinate_dofs[0] - coordinate_dofs[2]) * (coordinate_dofs[0] - coordinate_dofs[2]);
    sp[81] = (coordinate_dofs[1] - coordinate_dofs[3]) * (coordinate_dofs[1] - coordinate_dofs[3]);
    sp[82] = sp[80] + sp[81];
    sp[83] = sqrt(sp[82]);
    sp[84] = sp[79] * sp[83];
    sp[85] = triangle_reference_cell_volume * sp[2];
    sp[86] = fabs(sp[85]);
    sp[87] = sp[84] / (4.0 * sp[86]);
    sp[88] = (coordinate_dofs[8] - coordinate_dofs[10]) * (coordinate_dofs[8] - coordinate_dofs[10]);
    sp[89] = (coordinate_dofs[9] - coordinate_dofs[11]) * (coordinate_dofs[9] - coordinate_dofs[11]);
    sp[90] = sp[88] + sp[89];
    sp[91] = sqrt(sp[90]);
    sp[92] = (coordinate_dofs[6] - coordinate_dofs[10]) * (coordinate_dofs[6] - coordinate_dofs[10]);
    sp[93] = (coordinate_dofs[7] - coordinate_dofs[11]) * (coordinate_dofs[7] - coordinate_dofs[11]);
    sp[94] = sp[92] + sp[93];
    sp[95] = sqrt(sp[94]);
    sp[96] = sp[91] * sp[95];
    sp[97] = (coordinate_dofs[6] - coordinate_dofs[8]) * (coordinate_dofs[6] - coordinate_dofs[8]);
    sp[98] = (coordinate_dofs[7] - coordinate_dofs[9]) * (coordinate_dofs[7] - coordinate_dofs[9]);
    sp[99] = sp[97] + sp[98];
    sp[100] = sqrt(sp[99]);
    sp[101] = sp[96] * sp[100];
    sp[102] = triangle_reference_cell_volume * sp[20];
    sp[103] = fabs(sp[102]);
    sp[104] = sp[101] / (4.0 * sp[103]);
    sp[105] = 2.0 * sp[87] + 2.0 * sp[104];
    sp[106] = sp[68] * (4.0 / (sp[105] / 2.0));
    sp[107] = sp[69] * (4.0 / (sp[105] / 2.0));
    sp[108] = sp[70] * (4.0 / (sp[105] / 2.0));
    sp[109] = J_r0_c0 * triangle_reference_facet_jacobian[facet[0]][0][0];
    sp[110] = J_r0_c1 * triangle_reference_facet_jacobian[facet[0]][1][0];
    sp[111] = sp[109] + sp[110];
    sp[112] = sp[111] * sp[111];
    sp[113] = triangle_reference_facet_jacobian[facet[0]][0][0] * J_r0_c2;
    sp[114] = triangle_reference_facet_jacobian[facet[0]][1][0] * J_r0_c3;
    sp[115] = sp[113] + sp[114];
    sp[116] = sp[115] * sp[115];
    sp[117] = sp[112] + sp[116];
    sp[118] = sqrt(sp[117]);
    sp[119] = -1 * sp[54] * sp[118];
    sp[120] = -1 * sp[55] * sp[118];
    sp[121] = -1 * sp[56] * sp[118];
    sp[122] = -1 * sp[57] * sp[118];
    sp[123] = sp[106] * sp[118];
    sp[124] = sp[107] * sp[118];
    sp[125] = -1 * sp[58] * sp[118];
    sp[126] = -1 * sp[59] * sp[118];
    sp[127] = -1 * sp[60] * sp[118];
    sp[128] = -1 * sp[61] * sp[118];
    sp[129] = sp[108] * sp[118];
    // UFLACS block mode: preintegrated
    A[0] += PI1[facet[0]][0][0][0] * sp[120] + PI1[facet[0]][0][0][0] * sp[120] + PI0[facet[0]][facet[0]][0][0] * sp[123] + PI1[facet[0]][0][0][0] * sp[119] + PI1[facet[0]][0][0][0] * sp[119];
    A[1] += PI1[facet[0]][0][1][0] * sp[120] + PI1[facet[0]][0][0][1] * sp[120] + PI0[facet[0]][facet[0]][0][1] * sp[123] + PI1[facet[0]][0][1][0] * sp[119];
    A[2] += PI1[facet[0]][0][2][0] * sp[120] + PI0[facet[0]][facet[0]][0][2] * sp[123] + PI1[facet[0]][0][0][1] * sp[119] + PI1[facet[0]][0][2][0] * sp[119];
    A[3] += PI1[facet[1]][0][0][0] * sp[126] + PI1[facet[0]][0][0][0] * sp[122] + PI0[facet[0]][facet[1]][0][0] * sp[124] + PI1[facet[0]][0][0][0] * sp[121] + PI1[facet[1]][0][0][0] * sp[125];
    A[4] += PI1[facet[1]][0][1][0] * sp[126] + PI1[facet[0]][0][0][1] * sp[122] + PI0[facet[0]][facet[1]][0][1] * sp[124] + PI1[facet[1]][0][1][0] * sp[125];
    A[5] += PI1[facet[1]][0][2][0] * sp[126] + PI0[facet[0]][facet[1]][0][2] * sp[124] + PI1[facet[0]][0][0][1] * sp[121] + PI1[facet[1]][0][2][0] * sp[125];
    A[6] += PI1[facet[0]][0][0][1] * sp[120] + PI1[facet[0]][0][1][0] * sp[120] + PI0[facet[0]][facet[0]][1][0] * sp[123] + PI1[facet[0]][0][1][0] * sp[119];
    A[7] += PI1[facet[0]][0][1][1] * sp[120] + PI1[facet[0]][0][1][1] * sp[120] + PI0[facet[0]][facet[0]][1][1] * sp[123];
    A[8] += PI1[facet[0]][0][2][1] * sp[120] + PI0[facet[0]][facet[0]][1][2] * sp[123] + PI1[facet[0]][0][1][1] * sp[119];
    A[9] += PI1[facet[1]][0][0][1] * sp[126] + PI1[facet[0]][0][1][0] * sp[122] + PI0[facet[0]][facet[1]][1][0] * sp[124] + PI1[facet[0]][0][1][0] * sp[121];
    A[10] += PI1[facet[1]][0][1][1] * sp[126] + PI1[facet[0]][0][1][1] * sp[122] + PI0[facet[0]][facet[1]][1][1] * sp[124];
    A[11] += PI1[facet[1]][0][2][1] * sp[126] + PI0[facet[0]][facet[1]][1][2] * sp[124] + PI1[facet[0]][0][1][1] * sp[121];
    A[12] += PI1[facet[0]][0][2][0] * sp[120] + PI0[facet[0]][facet[0]][2][0] * sp[123] + PI1[facet[0]][0][2][0] * sp[119] + PI1[facet[0]][0][0][1] * sp[119];
    A[13] += PI1[facet[0]][0][2][1] * sp[120] + PI0[facet[0]][facet[0]][2][1] * sp[123] + PI1[facet[0]][0][1][1] * sp[119];
    A[14] += PI0[facet[0]][facet[0]][2][2] * sp[123] + PI1[facet[0]][0][2][1] * sp[119] + PI1[facet[0]][0][2][1] * sp[119];
    A[15] += PI1[facet[0]][0][2][0] * sp[122] + PI0[facet[0]][facet[1]][2][0] * sp[124] + PI1[facet[0]][0][2][0] * sp[121] + PI1[facet[1]][0][0][1] * sp[125];
    A[16] += PI1[facet[0]][0][2][1] * sp[122] + PI0[facet[0]][facet[1]][2][1] * sp[124] + PI1[facet[1]][0][1][1] * sp[125];
    A[17] += PI0[facet[0]][facet[1]][2][2] * sp[124] + PI1[facet[0]][0][2][1] * sp[121] + PI1[facet[1]][0][2][1] * sp[125];
    A[18] += PI1[facet[0]][0][0][0] * sp[122] + PI1[facet[1]][0][0][0] * sp[126] + PI0[facet[1]][facet[0]][0][0] * sp[124] + PI1[facet[1]][0][0][0] * sp[125] + PI1[facet[0]][0][0][0] * sp[121];
    A[19] += PI1[facet[0]][0][1][0] * sp[122] + PI1[facet[1]][0][0][1] * sp[126] + PI0[facet[1]][facet[0]][0][1] * sp[124] + PI1[facet[0]][0][1][0] * sp[121];
    A[20] += PI1[facet[0]][0][2][0] * sp[122] + PI0[facet[1]][facet[0]][0][2] * sp[124] + PI1[facet[1]][0][0][1] * sp[125] + PI1[facet[0]][0][2][0] * sp[121];
    A[21] += PI1[facet[1]][0][0][0] * sp[128] + PI1[facet[1]][0][0][0] * sp[128] + PI0[facet[1]][facet[1]][0][0] * sp[129] + PI1[facet[1]][0][0][0] * sp[127] + PI1[facet[1]][0][0][0] * sp[127];
    A[22] += PI1[facet[1]][0][1][0] * sp[128] + PI1[facet[1]][0][0][1] * sp[128] + PI0[facet[1]][facet[1]][0][1] * sp[129] + PI1[facet[1]][0][1][0] * sp[127];
    A[23] += PI1[facet[1]][0][2][0] * sp[128] + PI0[facet[1]][facet[1]][0][2] * sp[129] + PI1[facet[1]][0][0][1] * sp[127] + PI1[facet[1]][0][2][0] * sp[127];
    A[24] += PI1[facet[0]][0][0][1] * sp[122] + PI1[facet[1]][0][1][0] * sp[126] + PI0[facet[1]][facet[0]][1][0] * sp[124] + PI1[facet[1]][0][1][0] * sp[125];
    A[25] += PI1[facet[0]][0][1][1] * sp[122] + PI1[facet[1]][0][1][1] * sp[126] + PI0[facet[1]][facet[0]][1][1] * sp[124];
    A[26] += PI1[facet[0]][0][2][1] * sp[122] + PI0[facet[1]][facet[0]][1][2] * sp[124] + PI1[facet[1]][0][1][1] * sp[125];
    A[27] += PI1[facet[1]][0][0][1] * sp[128] + PI1[facet[1]][0][1][0] * sp[128] + PI0[facet[1]][facet[1]][1][0] * sp[129] + PI1[facet[1]][0][1][0] * sp[127];
    A[28] += PI1[facet[1]][0][1][1] * sp[128] + PI1[facet[1]][0][1][1] * sp[128] + PI0[facet[1]][facet[1]][1][1] * sp[129];
    A[29] += PI1[facet[1]][0][2][1] * sp[128] + PI0[facet[1]][facet[1]][1][2] * sp[129] + PI1[facet[1]][0][1][1] * sp[127];
    A[30] += PI1[facet[1]][0][2][0] * sp[126] + PI0[facet[1]][facet[0]][2][0] * sp[124] + PI1[facet[1]][0][2][0] * sp[125] + PI1[facet[0]][0][0][1] * sp[121];
    A[31] += PI1[facet[1]][0][2][1] * sp[126] + PI0[facet[1]][facet[0]][2][1] * sp[124] + PI1[facet[0]][0][1][1] * sp[121];
    A[32] += PI0[facet[1]][facet[0]][2][2] * sp[124] + PI1[facet[1]][0][2][1] * sp[125] + PI1[facet[0]][0][2][1] * sp[121];
    A[33] += PI1[facet[1]][0][2][0] * sp[128] + PI0[facet[1]][facet[1]][2][0] * sp[129] + PI1[facet[1]][0][2][0] * sp[127] + PI1[facet[1]][0][0][1] * sp[127];
    A[34] += PI1[facet[1]][0][2][1] * sp[128] + PI0[facet[1]][facet[1]][2][1] * sp[129] + PI1[facet[1]][0][1][1] * sp[127];
    A[35] += PI0[facet[1]][facet[1]][2][2] * sp[129] + PI1[facet[1]][0][2][1] * sp[127] + PI1[facet[1]][0][2][1] * sp[127];
}


fenics_integral* create_poissondg_interior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise(void)
{
  static const bool enabled[] = {};

  fenics_integral* integral = malloc(sizeof(*integral));
  integral->enabled_coefficients = enabled;
  integral->tabulate_tensor = tabulate_tensor_poissondg_interior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise;
  return integral;
};

// End of code for integral poissondg_interior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise

// Code for integral poissondg_cell_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise


void tabulate_tensor_poissondg_cell_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise(fenics_scalar_t* restrict A, const fenics_scalar_t* w,
                                    const fenics_scalar_t* c,
                                    const double* restrict coordinate_dofs,
                                    const int* unused_local_index,
                                    const int* cell_orientation)
{
    // Quadrature rules
    alignas(32) static const fenics_scalar_t weights3[3] = { 0.1666666666666667, 0.1666666666666667, 0.1666666666666667 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const fenics_scalar_t FE4_C0_D01_Q3[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const fenics_scalar_t FE6_C0_Q3[1][3][3] =
        { { { 0.6666666666666669, 0.1666666666666666, 0.1666666666666667 },
            { 0.1666666666666667, 0.1666666666666666, 0.6666666666666665 },
            { 0.1666666666666667, 0.6666666666666665, 0.1666666666666666 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE4_C0_D01_Q3[0][0][0] + coordinate_dofs[2] * FE4_C0_D01_Q3[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE4_C0_D01_Q3[0][0][0] + coordinate_dofs[5] * FE4_C0_D01_Q3[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE4_C0_D01_Q3[0][0][0] + coordinate_dofs[4] * FE4_C0_D01_Q3[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE4_C0_D01_Q3[0][0][0] + coordinate_dofs[3] * FE4_C0_D01_Q3[0][0][1];
    alignas(32) fenics_scalar_t sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = fabs(sp[2]);
    // UFLACS block mode: full
    alignas(32) fenics_scalar_t BF0[3] = { 0 };
    for (int iq = 0; iq < 3; ++iq)
    {
        // Quadrature loop body setup (num_points=3)
        // Unstructured varying computations for num_points=3
        fenics_scalar_t w0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0 += w[ic] * FE6_C0_Q3[0][iq][ic];
        alignas(32) fenics_scalar_t sv3[1];
        sv3[0] = sp[3] * w0;
        // UFLACS block mode: full
        const fenics_scalar_t fw0 = sv3[0] * weights3[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE6_C0_Q3[0][iq][i];
    }
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
}


fenics_integral* create_poissondg_cell_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise(void)
{
  static const bool enabled[2] = { true, false };

  fenics_integral* integral = malloc(sizeof(*integral));
  integral->enabled_coefficients = enabled;
  integral->tabulate_tensor = tabulate_tensor_poissondg_cell_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise;
  return integral;
};

// End of code for integral poissondg_cell_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise

// Code for integral poissondg_exterior_facet_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise


void tabulate_tensor_poissondg_exterior_facet_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise(fenics_scalar_t* restrict A, const fenics_scalar_t* w,
                                    const fenics_scalar_t* c,
                                    const double* restrict coordinate_dofs,
                                    const int* facet,
                                    const int* cell_orientation)
{
    // Quadrature rules
    alignas(32) static const fenics_scalar_t weights2[2] = { 0.5, 0.5 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const fenics_scalar_t FE4_C0_D01_F_Q2[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const fenics_scalar_t FE6_C0_F_Q2[3][2][3] =
        { { { 0.0, 0.7886751345948129, 0.2113248654051871 },
            { 0.0, 0.2113248654051872, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.0, 0.2113248654051871 },
            { 0.2113248654051872, 0.0, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.2113248654051872, 0.0 },
            { 0.2113248654051872, 0.7886751345948129, 0.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE4_C0_D01_F_Q2[0][0][0] + coordinate_dofs[2] * FE4_C0_D01_F_Q2[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE4_C0_D01_F_Q2[0][0][0] + coordinate_dofs[4] * FE4_C0_D01_F_Q2[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE4_C0_D01_F_Q2[0][0][0] + coordinate_dofs[3] * FE4_C0_D01_F_Q2[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE4_C0_D01_F_Q2[0][0][0] + coordinate_dofs[5] * FE4_C0_D01_F_Q2[0][0][1];
    alignas(32) fenics_scalar_t sp[10];
    sp[0] = J_c0 * triangle_reference_facet_jacobian[facet[0]][0][0];
    sp[1] = J_c1 * triangle_reference_facet_jacobian[facet[0]][1][0];
    sp[2] = sp[0] + sp[1];
    sp[3] = sp[2] * sp[2];
    sp[4] = triangle_reference_facet_jacobian[facet[0]][0][0] * J_c2;
    sp[5] = triangle_reference_facet_jacobian[facet[0]][1][0] * J_c3;
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = sqrt(sp[8]);
    // UFLACS block mode: full
    alignas(32) fenics_scalar_t BF0[3] = { 0 };
    for (int iq = 0; iq < 2; ++iq)
    {
        // Quadrature loop body setup (num_points=2)
        // Unstructured varying computations for num_points=2
        fenics_scalar_t w1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1 += w[3 + ic] * FE6_C0_F_Q2[facet[0]][iq][ic];
        alignas(32) fenics_scalar_t sv2[1];
        sv2[0] = sp[9] * w1;
        // UFLACS block mode: full
        const fenics_scalar_t fw0 = sv2[0] * weights2[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE6_C0_F_Q2[facet[0]][iq][i];
    }
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
}


fenics_integral* create_poissondg_exterior_facet_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise(void)
{
  static const bool enabled[2] = { false, true };

  fenics_integral* integral = malloc(sizeof(*integral));
  integral->enabled_coefficients = enabled;
  integral->tabulate_tensor = tabulate_tensor_poissondg_exterior_facet_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise;
  return integral;
};

// End of code for integral poissondg_exterior_facet_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise

// Code for form poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d

int original_coefficient_position_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int i)
{
// Invalid original coefficient index.
return -1;
}

// Return a list of the coefficient names.
const char** coefficient_name_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(void)
{
return NULL;
}

// Return a list of the constant names.
const char** constant_name_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(void)
{
return NULL;
}

fenics_finite_element* create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(void);

fenics_finite_element* create_coordinate_finite_element_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(void)
{
return create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main();
}

fenics_dofmap* create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main(void);

fenics_dofmap* create_coordinate_dofmap_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(void)
{
return create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main();
}

fenics_coordinate_mapping* create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(void);

fenics_coordinate_mapping* create_coordinate_mapping_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(void)
{
return create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main();
}

fenics_finite_element* create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(void);

fenics_finite_element* create_finite_element_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main();
case 1:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main(void);

fenics_dofmap* create_dofmap_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main();
case 1:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main();
default:
    return NULL;
}
}

fenics_integral* create_cell_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int subdomain_id)
{
  switch (subdomain_id)
{
case -1:
    return create_poissondg_cell_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise();
default:
    return NULL;
}
}

void get_cell_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int *ids)
{
  ids[0] = -1;
return;
}

fenics_integral* create_exterior_facet_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int subdomain_id)
{
  switch (subdomain_id)
{
case -1:
    return create_poissondg_exterior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise();
default:
    return NULL;
}
}

void get_exterior_facet_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int *ids)
{
  ids[0] = -1;
return;
}

fenics_integral* create_interior_facet_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int subdomain_id)
{
switch (subdomain_id)
{
case -1:
    return create_poissondg_interior_facet_integral_e35f641731b0c974b4b7520e23d69f4f726a7b2d_otherwise();
default:
    return NULL;
}
}

void get_interior_facet_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int *ids)
{
  ids[0] = -1;
return;
}

fenics_integral* create_vertex_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int subdomain_id)
{
return NULL;
}

void get_vertex_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int *ids)
{
  return;
}

fenics_custom_integral* create_custom_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int subdomain_id)
{
return NULL;
}

void get_custom_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(int *ids)
{
  return;
}

fenics_form* create_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d(void)
{
  fenics_form* form = malloc(sizeof(*form));

  form->signature = "c489292b64eaffe8192353ee2e194f111a009b2af4568a1e8f7b1af3d6c17942644c66e2c431df92f275575680800a4fc5bd38ac882d89c4761c7e4af5722419";
  form->rank = 2;
  form->num_coefficients = 0;
  form->num_constants = 0;
  form->original_coefficient_position = original_coefficient_position_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;

  form->coefficient_name_map = coefficient_name_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->constant_name_map = constant_name_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;

  form->create_coordinate_finite_element = create_coordinate_finite_element_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->create_coordinate_dofmap = create_coordinate_dofmap_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->create_coordinate_mapping = create_coordinate_mapping_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->create_finite_element = create_finite_element_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->create_dofmap = create_dofmap_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;

  form->get_cell_integral_ids = get_cell_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->get_exterior_facet_integral_ids = get_exterior_facet_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->get_interior_facet_integral_ids = get_interior_facet_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->get_vertex_integral_ids = get_vertex_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->get_custom_integral_ids = get_custom_integral_ids_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;

  form->num_cell_integrals = 1;
  form->num_exterior_facet_integrals = 1;
  form->num_interior_facet_integrals = 1;
  form->num_vertex_integrals = 0;
  form->num_custom_integrals = 0;

  form->create_cell_integral = create_cell_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->create_exterior_facet_integral = create_exterior_facet_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->create_interior_facet_integral = create_interior_facet_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->create_vertex_integral = create_vertex_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;
  form->create_custom_integral = create_custom_integral_poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d;

  return form;
};

// End of code for form poissondg_form_e35f641731b0c974b4b7520e23d69f4f726a7b2d

// Code for form poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1

int original_coefficient_position_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int i)
{
if (i >= 2)
{
    // Invalid original coefficient index.
    return -1;
}
static const int64_t position[2] = { 0, 1 };
return position[i];
}

// Return a list of the coefficient names.
const char** coefficient_name_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(void)
{
static const char* names[2] = { "f", "gN" };
return names;
}

// Return a list of the constant names.
const char** constant_name_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(void)
{
return NULL;
}

fenics_finite_element* create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main(void);

fenics_finite_element* create_coordinate_finite_element_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(void)
{
return create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_finite_element_main();
}

fenics_dofmap* create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main(void);

fenics_dofmap* create_coordinate_dofmap_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(void)
{
return create_ffc_element_648437b5c7ff9a32325fb64e5193a33f44784fc1_dofmap_main();
}

fenics_coordinate_mapping* create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main(void);

fenics_coordinate_mapping* create_coordinate_mapping_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(void)
{
return create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main();
}

fenics_finite_element* create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main(void);

fenics_finite_element* create_finite_element_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main();
case 1:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main();
case 2:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main(void);

fenics_dofmap* create_dofmap_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main();
case 1:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main();
case 2:
    return create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main();
default:
    return NULL;
}
}

fenics_integral* create_cell_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int subdomain_id)
{
  switch (subdomain_id)
{
case -1:
    return create_poissondg_cell_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise();
default:
    return NULL;
}
}

void get_cell_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int *ids)
{
  ids[0] = -1;
return;
}

fenics_integral* create_exterior_facet_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int subdomain_id)
{
  switch (subdomain_id)
{
case -1:
    return create_poissondg_exterior_facet_integral_f74f75e56aa99140e8176029cc3cd69b6c21f0d1_otherwise();
default:
    return NULL;
}
}

void get_exterior_facet_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int *ids)
{
  ids[0] = -1;
return;
}

fenics_integral* create_interior_facet_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int subdomain_id)
{
return NULL;
}

void get_interior_facet_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int *ids)
{
  return;
}

fenics_integral* create_vertex_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int subdomain_id)
{
return NULL;
}

void get_vertex_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int *ids)
{
  return;
}

fenics_custom_integral* create_custom_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int subdomain_id)
{
return NULL;
}

void get_custom_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(int *ids)
{
  return;
}

fenics_form* create_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1(void)
{
  fenics_form* form = malloc(sizeof(*form));

  form->signature = "600ca443960795916e28c766db8c206a3ffb1177741f5ca18f3a0cc6f85258c5b53dcbc7f45b7f7c975fe73b1b010e108fdfb7526eeea4cc9344e0b864e043ec";
  form->rank = 1;
  form->num_coefficients = 2;
  form->num_constants = 0;
  form->original_coefficient_position = original_coefficient_position_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;

  form->coefficient_name_map = coefficient_name_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->constant_name_map = constant_name_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;

  form->create_coordinate_finite_element = create_coordinate_finite_element_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->create_coordinate_dofmap = create_coordinate_dofmap_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->create_coordinate_mapping = create_coordinate_mapping_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->create_finite_element = create_finite_element_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->create_dofmap = create_dofmap_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;

  form->get_cell_integral_ids = get_cell_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->get_exterior_facet_integral_ids = get_exterior_facet_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->get_interior_facet_integral_ids = get_interior_facet_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->get_vertex_integral_ids = get_vertex_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->get_custom_integral_ids = get_custom_integral_ids_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;

  form->num_cell_integrals = 1;
  form->num_exterior_facet_integrals = 1;
  form->num_interior_facet_integrals = 0;
  form->num_vertex_integrals = 0;
  form->num_custom_integrals = 0;

  form->create_cell_integral = create_cell_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->create_exterior_facet_integral = create_exterior_facet_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->create_interior_facet_integral = create_interior_facet_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->create_vertex_integral = create_vertex_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;
  form->create_custom_integral = create_custom_integral_poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1;

  return form;
};

// End of code for form poissondg_form_f74f75e56aa99140e8176029cc3cd69b6c21f0d1

fenics_function_space* PoissonDG_coefficientspace_f_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  space->create_dofmap = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  return space;
}
fenics_function_space* PoissonDG_coefficientspace_gN_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  space->create_dofmap = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  return space;
}
fenics_function_space* PoissonDG_form_a_functionspace_0_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  space->create_dofmap = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  return space;
}

fenics_function_space* PoissonDG_form_a_functionspace_1_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  space->create_dofmap = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  return space;
}
fenics_function_space* PoissonDG_form_L_functionspace_0_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_finite_element_main;
  space->create_dofmap = create_ffc_element_392bbf16c23ca3243a70e66e583db2c280b3601b_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_3631f6fb40e874a885198dfcf74e60d36da645a2_coordinate_mapping_main;
  return space;
}

