// This code conforms with the UFC specification version 2018.2.0.dev0
// and was automatically generated by FFC version 2019.2.0.dev0.
//
// This code was generated with the following parameters:
//
//  {'epsilon': 1e-14,
//   'external_include_dirs': '',
//   'external_includes': '',
//   'precision': None,
//   'quadrature_degree': None,
//   'quadrature_rule': None,
//   'representation': 'uflacs',
//   'scalar_type': 'double',
//   'timeout': 10}


typedef double fenics_scalar_t;
#include <fenics_interface.h>
#include <math.h>
#include <stdalign.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

// Code for element ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main

int value_dimension_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(int i)
{
  return 1;
}

int reference_value_dimension_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(int i)
{
  return 1;
}

int evaluate_reference_basis_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][10] = { { -0.05773502691896244, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.041147559989891176, 0.029095718698132305, 0.02375655483665994, 0.01679842102263232 } };
static const double coefficients1[1][10] = { { -0.05773502691896254, 0.06085806194501846, -0.03513641844631534, -0.02484519974999766, 0.06506000486323553, -0.05039526306789696, -0.04114755998989116, 0.029095718698132312, 0.02375655483665994, 0.01679842102263232 } };
static const double coefficients2[1][10] = { { -0.05773502691896248, 0.0, 0.07027283689263068, -0.024845199749997687, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.016798421022632317 } };
static const double coefficients3[1][10] = { { -0.05773502691896258, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 } };
static const double coefficients4[1][10] = { { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 } };
static const double coefficients5[1][10] = { { 0.23094010767585044, 0.1217161238900369, -0.07027283689263064, 0.09938079899999067, 0.0, 0.0, 0.10286889997472794, 0.0, -0.05939138709164987, -0.0671936840905293 } };
static const double coefficients6[1][10] = { { 0.23094010767585035, 0.1217161238900369, 0.07027283689263066, -0.09938079899999062, 0.0, 0.10079052613579391, -0.02057377999494558, -0.08728715609439694, -0.011878277418329978, 0.01679842102263232 } };
static const double coefficients7[1][10] = { { 0.23094010767585021, -0.1217161238900369, -0.07027283689263064, 0.09938079899999064, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164986, -0.06719368409052928 } };
static const double coefficients8[1][10] = { { 0.23094010767585035, -0.12171612389003696, 0.07027283689263063, -0.09938079899999064, 0.0, -0.10079052613579395, 0.02057377999494558, -0.08728715609439693, -0.011878277418329967, 0.016798421022632327 } };
static const double coefficients9[1][10] = { { 0.23094010767585033, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132322, 0.023756554836659956, 0.01679842102263232 } };
for (int64_t k = 0; k < num_points * 10; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues2[10] = { 0 };
    basisvalues2[0] = 1.0;
    const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues2[1] = tmp1_2;
    const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
    basisvalues2[4] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp2_2 * basisvalues2[0];
    basisvalues2[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues2[0];
    basisvalues2[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues2[1];
    const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
    const double tmp4_2 = 0.5 * (1.0 - Y[2]);
    const double tmp5_2 = tmp4_2 * tmp4_2;
    basisvalues2[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues2[2] - 0.5555555555555556 * tmp5_2 * basisvalues2[0];
    basisvalues2[3] = (2.0 * Y[2] + 1.0) * basisvalues2[0];
    basisvalues2[8] = (3.0 * Y[2] + 2.0) * basisvalues2[2];
    basisvalues2[6] = (3.0 * Y[2] + 2.0) * basisvalues2[1];
    basisvalues2[9] = (0.3125 + 1.875 * Y[2]) * basisvalues2[3] - 0.5625 * basisvalues2[0];
    basisvalues2[0] *= sqrt(0.75);
    basisvalues2[3] *= sqrt(1.25);
    basisvalues2[9] *= sqrt(1.75);
    basisvalues2[2] *= sqrt(2.5);
    basisvalues2[8] *= sqrt(3.5);
    basisvalues2[7] *= sqrt(5.25);
    basisvalues2[1] *= sqrt(7.5);
    basisvalues2[6] *= sqrt(10.5);
    basisvalues2[5] *= sqrt(15.75);
    basisvalues2[4] *= sqrt(26.25);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip] += coefficients0[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip + 1] += coefficients1[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip + 2] += coefficients2[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip + 3] += coefficients3[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip + 4] += coefficients4[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip + 5] += coefficients5[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip + 6] += coefficients6[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip + 7] += coefficients7[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip + 8] += coefficients8[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[10 * ip + 9] += coefficients9[0][r] * basisvalues2[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(3, order);
for (int64_t l0 = 0; l0 < num_points * 10 * num_derivatives; ++l0)
    reference_values[l0] = 0.0;
if (order > 2)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[3][10][10] =
    { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 6.32455532033676, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 4.582575694955857, 0.0, 8.366600265340765, -1.1832159566199276, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 3.741657386773954, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 3.16227766016838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 2.9580398915498094, 5.612486080160912, -1.080123449734643, -0.7637626158259723, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 2.29128784747796, 7.245688373094725, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.870828693386977, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { -2.6457513110646254, 0.0, 9.660917830792958, 0.6831300510639811, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 3.2403703492039417, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 3.16227766016838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.8257418583505545, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 5.163977794943223, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 2.9580398915498094, 5.612486080160912, -1.080123449734643, -0.7637626158259723, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 2.291287847477917, 1.4491376746189433, 4.183300132670375, -0.591607978309961, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.8708286933870113, 7.0992957397195475, 0.0, 4.347413023856837, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.3228756555323071, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.0801234497346333, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { -3.818813079129912, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } } };
static const double coefficients0[1][10] = { { -0.05773502691896244, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.041147559989891176, 0.029095718698132305, 0.02375655483665994, 0.01679842102263232 } };
static const double coefficients1[1][10] = { { -0.05773502691896254, 0.06085806194501846, -0.03513641844631534, -0.02484519974999766, 0.06506000486323553, -0.05039526306789696, -0.04114755998989116, 0.029095718698132312, 0.02375655483665994, 0.01679842102263232 } };
static const double coefficients2[1][10] = { { -0.05773502691896248, 0.0, 0.07027283689263068, -0.024845199749997687, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.016798421022632317 } };
static const double coefficients3[1][10] = { { -0.05773502691896258, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 } };
static const double coefficients4[1][10] = { { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 } };
static const double coefficients5[1][10] = { { 0.23094010767585044, 0.1217161238900369, -0.07027283689263064, 0.09938079899999067, 0.0, 0.0, 0.10286889997472794, 0.0, -0.05939138709164987, -0.0671936840905293 } };
static const double coefficients6[1][10] = { { 0.23094010767585035, 0.1217161238900369, 0.07027283689263066, -0.09938079899999062, 0.0, 0.10079052613579391, -0.02057377999494558, -0.08728715609439694, -0.011878277418329978, 0.01679842102263232 } };
static const double coefficients7[1][10] = { { 0.23094010767585021, -0.1217161238900369, -0.07027283689263064, 0.09938079899999064, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164986, -0.06719368409052928 } };
static const double coefficients8[1][10] = { { 0.23094010767585035, -0.12171612389003696, 0.07027283689263063, -0.09938079899999064, 0.0, -0.10079052613579395, 0.02057377999494558, -0.08728715609439693, -0.011878277418329967, 0.016798421022632327 } };
static const double coefficients9[1][10] = { { 0.23094010767585033, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132322, 0.023756554836659956, 0.01679842102263232 } };
const int64_t reference_offset[10] = { 0 };
const int64_t num_components[10] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
// Precomputed combinations
const int64_t combinations[2][9][2] =
    { { { 0, 0 },
        { 1, 0 },
        { 2, 0 },
        { 0, 0 },
        { 1, 0 },
        { 2, 0 },
        { 0, 0 },
        { 1, 0 },
        { 2, 0 } },
      { { 0, 0 },
        { 0, 1 },
        { 0, 2 },
        { 1, 0 },
        { 1, 1 },
        { 1, 2 },
        { 2, 0 },
        { 2, 1 },
        { 2, 2 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues2[10] = { 0 };
    basisvalues2[0] = 1.0;
    const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues2[1] = tmp1_2;
    const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
    basisvalues2[4] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp2_2 * basisvalues2[0];
    basisvalues2[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues2[0];
    basisvalues2[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues2[1];
    const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
    const double tmp4_2 = 0.5 * (1.0 - Y[2]);
    const double tmp5_2 = tmp4_2 * tmp4_2;
    basisvalues2[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues2[2] - 0.5555555555555556 * tmp5_2 * basisvalues2[0];
    basisvalues2[3] = (2.0 * Y[2] + 1.0) * basisvalues2[0];
    basisvalues2[8] = (3.0 * Y[2] + 2.0) * basisvalues2[2];
    basisvalues2[6] = (3.0 * Y[2] + 2.0) * basisvalues2[1];
    basisvalues2[9] = (0.3125 + 1.875 * Y[2]) * basisvalues2[3] - 0.5625 * basisvalues2[0];
    basisvalues2[0] *= sqrt(0.75);
    basisvalues2[3] *= sqrt(1.25);
    basisvalues2[9] *= sqrt(1.75);
    basisvalues2[2] *= sqrt(2.5);
    basisvalues2[8] *= sqrt(3.5);
    basisvalues2[7] *= sqrt(5.25);
    basisvalues2[1] *= sqrt(7.5);
    basisvalues2[6] *= sqrt(10.5);
    basisvalues2[5] *= sqrt(15.75);
    basisvalues2[4] *= sqrt(26.25);
    // Loop over all dofs
    for (int64_t i = 0; i < 10; ++i)
    {
        double derivatives[9] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        case 4:
            // Compute reference derivatives for dof 4.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients4[0][s] * aux[s];
            }
            break;
        case 5:
            // Compute reference derivatives for dof 5.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients5[0][s] * aux[s];
            }
            break;
        case 6:
            // Compute reference derivatives for dof 6.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients6[0][s] * aux[s];
            }
            break;
        case 7:
            // Compute reference derivatives for dof 7.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients7[0][s] * aux[s];
            }
            break;
        case 8:
            // Compute reference derivatives for dof 8.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients8[0][s] * aux[s];
            }
            break;
        case 9:
            // Compute reference derivatives for dof 9.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients9[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[10 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives = pow(3, order);
// Precomputed combinations
const int64_t combinations[2][9][2] =
    { { { 0, 0 },
        { 1, 0 },
        { 2, 0 },
        { 0, 0 },
        { 1, 0 },
        { 2, 0 },
        { 0, 0 },
        { 1, 0 },
        { 2, 0 } },
      { { 0, 0 },
        { 0, 1 },
        { 0, 2 },
        { 1, 0 },
        { 1, 1 },
        { 1, 2 },
        { 2, 0 },
        { 2, 1 },
        { 2, 2 } } };
for (int64_t l = 0; l < num_points * 10 * num_derivatives; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[10] = { 0 };
const int64_t physical_offsets[10] = { 0 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[9][9];
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
    for (int64_t d = 0; d < 10; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[10 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[10 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[1];
reference_values[2] = physical_values[2];
reference_values[3] = physical_values[3];
reference_values[4] = physical_values[4];
reference_values[5] = physical_values[5];
reference_values[6] = physical_values[6];
reference_values[7] = physical_values[7];
reference_values[8] = physical_values[8];
reference_values[9] = physical_values[9];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[30] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0 };
memcpy(reference_dof_coordinates, dof_X, 30*sizeof(double));
return 0;
}


fenics_finite_element* create_sub_element_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(int i)
{
  return NULL;
}

fenics_finite_element* create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "FiniteElement('Lagrange', tetrahedron, 2)";
  element->cell_shape = tetrahedron;
  element->topological_dimension = 3;
  element->geometric_dimension = 3;
  element->space_dimension = 10;
  element->value_rank = 0;
  element->value_dimension = value_dimension_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main;
  element->value_size = 1;
  element->reference_value_rank = 0;
  element->reference_value_dimension = reference_value_dimension_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main;
  element->reference_value_size = 1;
  element->degree = 2;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main;
  element->transform_values = transform_values_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main;
  element->num_sub_elements = 0;
  element->create_sub_element = create_sub_element_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main;
  element->create = create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main;

  return element;
};

// End of code for element ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main

// Code for element ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main

int value_dimension_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int reference_value_dimension_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int evaluate_reference_basis_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][10] = { { -0.05773502691896244, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.041147559989891176, 0.029095718698132305, 0.02375655483665994, 0.01679842102263232 } };
static const double coefficients1[1][10] = { { -0.05773502691896254, 0.06085806194501846, -0.03513641844631534, -0.02484519974999766, 0.06506000486323553, -0.05039526306789696, -0.04114755998989116, 0.029095718698132312, 0.02375655483665994, 0.01679842102263232 } };
static const double coefficients2[1][10] = { { -0.05773502691896248, 0.0, 0.07027283689263068, -0.024845199749997687, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.016798421022632317 } };
static const double coefficients3[1][10] = { { -0.05773502691896258, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 } };
static const double coefficients4[1][10] = { { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 } };
static const double coefficients5[1][10] = { { 0.23094010767585044, 0.1217161238900369, -0.07027283689263064, 0.09938079899999067, 0.0, 0.0, 0.10286889997472794, 0.0, -0.05939138709164987, -0.0671936840905293 } };
static const double coefficients6[1][10] = { { 0.23094010767585035, 0.1217161238900369, 0.07027283689263066, -0.09938079899999062, 0.0, 0.10079052613579391, -0.02057377999494558, -0.08728715609439694, -0.011878277418329978, 0.01679842102263232 } };
static const double coefficients7[1][10] = { { 0.23094010767585021, -0.1217161238900369, -0.07027283689263064, 0.09938079899999064, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164986, -0.06719368409052928 } };
static const double coefficients8[1][10] = { { 0.23094010767585035, -0.12171612389003696, 0.07027283689263063, -0.09938079899999064, 0.0, -0.10079052613579395, 0.02057377999494558, -0.08728715609439693, -0.011878277418329967, 0.016798421022632327 } };
static const double coefficients9[1][10] = { { 0.23094010767585033, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132322, 0.023756554836659956, 0.01679842102263232 } };
for (int64_t k = 0; k < num_points * 30 * 3; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues2[10] = { 0 };
    basisvalues2[0] = 1.0;
    const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues2[1] = tmp1_2;
    const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
    basisvalues2[4] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp2_2 * basisvalues2[0];
    basisvalues2[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues2[0];
    basisvalues2[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues2[1];
    const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
    const double tmp4_2 = 0.5 * (1.0 - Y[2]);
    const double tmp5_2 = tmp4_2 * tmp4_2;
    basisvalues2[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues2[2] - 0.5555555555555556 * tmp5_2 * basisvalues2[0];
    basisvalues2[3] = (2.0 * Y[2] + 1.0) * basisvalues2[0];
    basisvalues2[8] = (3.0 * Y[2] + 2.0) * basisvalues2[2];
    basisvalues2[6] = (3.0 * Y[2] + 2.0) * basisvalues2[1];
    basisvalues2[9] = (0.3125 + 1.875 * Y[2]) * basisvalues2[3] - 0.5625 * basisvalues2[0];
    basisvalues2[0] *= sqrt(0.75);
    basisvalues2[3] *= sqrt(1.25);
    basisvalues2[9] *= sqrt(1.75);
    basisvalues2[2] *= sqrt(2.5);
    basisvalues2[8] *= sqrt(3.5);
    basisvalues2[7] *= sqrt(5.25);
    basisvalues2[1] *= sqrt(7.5);
    basisvalues2[6] *= sqrt(10.5);
    basisvalues2[5] *= sqrt(15.75);
    basisvalues2[4] *= sqrt(26.25);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip] += coefficients0[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3] += coefficients1[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 2] += coefficients2[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 3] += coefficients3[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 4] += coefficients4[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 5] += coefficients5[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 6] += coefficients6[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 7] += coefficients7[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 8] += coefficients8[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 9] += coefficients9[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 10 + 1] += coefficients0[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 11 + 1] += coefficients1[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 12 + 1] += coefficients2[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 13 + 1] += coefficients3[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 14 + 1] += coefficients4[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 15 + 1] += coefficients5[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 16 + 1] += coefficients6[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 17 + 1] += coefficients7[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 18 + 1] += coefficients8[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 19 + 1] += coefficients9[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 20 + 2] += coefficients0[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 21 + 2] += coefficients1[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 22 + 2] += coefficients2[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 23 + 2] += coefficients3[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 24 + 2] += coefficients4[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 25 + 2] += coefficients5[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 26 + 2] += coefficients6[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 27 + 2] += coefficients7[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 28 + 2] += coefficients8[0][r] * basisvalues2[r];
    for (int64_t r = 0; r < 10; ++r)
        reference_values[30 * 3 * ip + 3 * 29 + 2] += coefficients9[0][r] * basisvalues2[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(3, order);
for (int64_t l0 = 0; l0 < num_points * 30 * num_derivatives * 3; ++l0)
    reference_values[l0] = 0.0;
if (order > 2)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[3][10][10] =
    { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 6.32455532033676, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 4.582575694955857, 0.0, 8.366600265340765, -1.1832159566199276, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 3.741657386773954, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 3.16227766016838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 2.9580398915498094, 5.612486080160912, -1.080123449734643, -0.7637626158259723, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 2.29128784747796, 7.245688373094725, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.870828693386977, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { -2.6457513110646254, 0.0, 9.660917830792958, 0.6831300510639811, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 3.2403703492039417, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 3.16227766016838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.8257418583505545, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 5.163977794943223, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 2.9580398915498094, 5.612486080160912, -1.080123449734643, -0.7637626158259723, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 2.291287847477917, 1.4491376746189433, 4.183300132670375, -0.591607978309961, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.8708286933870113, 7.0992957397195475, 0.0, 4.347413023856837, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.3228756555323071, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { 1.0801234497346333, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
        { -3.818813079129912, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } } };
static const double coefficients0[1][10] = { { -0.05773502691896244, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.041147559989891176, 0.029095718698132305, 0.02375655483665994, 0.01679842102263232 } };
static const double coefficients1[1][10] = { { -0.05773502691896254, 0.06085806194501846, -0.03513641844631534, -0.02484519974999766, 0.06506000486323553, -0.05039526306789696, -0.04114755998989116, 0.029095718698132312, 0.02375655483665994, 0.01679842102263232 } };
static const double coefficients2[1][10] = { { -0.05773502691896248, 0.0, 0.07027283689263068, -0.024845199749997687, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.016798421022632317 } };
static const double coefficients3[1][10] = { { -0.05773502691896258, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 } };
static const double coefficients4[1][10] = { { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 } };
static const double coefficients5[1][10] = { { 0.23094010767585044, 0.1217161238900369, -0.07027283689263064, 0.09938079899999067, 0.0, 0.0, 0.10286889997472794, 0.0, -0.05939138709164987, -0.0671936840905293 } };
static const double coefficients6[1][10] = { { 0.23094010767585035, 0.1217161238900369, 0.07027283689263066, -0.09938079899999062, 0.0, 0.10079052613579391, -0.02057377999494558, -0.08728715609439694, -0.011878277418329978, 0.01679842102263232 } };
static const double coefficients7[1][10] = { { 0.23094010767585021, -0.1217161238900369, -0.07027283689263064, 0.09938079899999064, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164986, -0.06719368409052928 } };
static const double coefficients8[1][10] = { { 0.23094010767585035, -0.12171612389003696, 0.07027283689263063, -0.09938079899999064, 0.0, -0.10079052613579395, 0.02057377999494558, -0.08728715609439693, -0.011878277418329967, 0.016798421022632327 } };
static const double coefficients9[1][10] = { { 0.23094010767585033, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132322, 0.023756554836659956, 0.01679842102263232 } };
const int64_t reference_offset[30] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
const int64_t num_components[30] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
// Precomputed combinations
const int64_t combinations[2][9][2] =
    { { { 0, 0 },
        { 1, 0 },
        { 2, 0 },
        { 0, 0 },
        { 1, 0 },
        { 2, 0 },
        { 0, 0 },
        { 1, 0 },
        { 2, 0 } },
      { { 0, 0 },
        { 0, 1 },
        { 0, 2 },
        { 1, 0 },
        { 1, 1 },
        { 1, 2 },
        { 2, 0 },
        { 2, 1 },
        { 2, 2 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues2[10] = { 0 };
    basisvalues2[0] = 1.0;
    const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues2[1] = tmp1_2;
    const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
    basisvalues2[4] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp2_2 * basisvalues2[0];
    basisvalues2[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues2[0];
    basisvalues2[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues2[1];
    const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
    const double tmp4_2 = 0.5 * (1.0 - Y[2]);
    const double tmp5_2 = tmp4_2 * tmp4_2;
    basisvalues2[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues2[2] - 0.5555555555555556 * tmp5_2 * basisvalues2[0];
    basisvalues2[3] = (2.0 * Y[2] + 1.0) * basisvalues2[0];
    basisvalues2[8] = (3.0 * Y[2] + 2.0) * basisvalues2[2];
    basisvalues2[6] = (3.0 * Y[2] + 2.0) * basisvalues2[1];
    basisvalues2[9] = (0.3125 + 1.875 * Y[2]) * basisvalues2[3] - 0.5625 * basisvalues2[0];
    basisvalues2[0] *= sqrt(0.75);
    basisvalues2[3] *= sqrt(1.25);
    basisvalues2[9] *= sqrt(1.75);
    basisvalues2[2] *= sqrt(2.5);
    basisvalues2[8] *= sqrt(3.5);
    basisvalues2[7] *= sqrt(5.25);
    basisvalues2[1] *= sqrt(7.5);
    basisvalues2[6] *= sqrt(10.5);
    basisvalues2[5] *= sqrt(15.75);
    basisvalues2[4] *= sqrt(26.25);
    // Loop over all dofs
    for (int64_t i = 0; i < 30; ++i)
    {
        double derivatives[9] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        case 4:
            // Compute reference derivatives for dof 4.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients4[0][s] * aux[s];
            }
            break;
        case 5:
            // Compute reference derivatives for dof 5.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients5[0][s] * aux[s];
            }
            break;
        case 6:
            // Compute reference derivatives for dof 6.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients6[0][s] * aux[s];
            }
            break;
        case 7:
            // Compute reference derivatives for dof 7.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients7[0][s] * aux[s];
            }
            break;
        case 8:
            // Compute reference derivatives for dof 8.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients8[0][s] * aux[s];
            }
            break;
        case 9:
            // Compute reference derivatives for dof 9.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients9[0][s] * aux[s];
            }
            break;
        case 10:
            // Compute reference derivatives for dof 10.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 11:
            // Compute reference derivatives for dof 11.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 12:
            // Compute reference derivatives for dof 12.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 13:
            // Compute reference derivatives for dof 13.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        case 14:
            // Compute reference derivatives for dof 14.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients4[0][s] * aux[s];
            }
            break;
        case 15:
            // Compute reference derivatives for dof 15.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients5[0][s] * aux[s];
            }
            break;
        case 16:
            // Compute reference derivatives for dof 16.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients6[0][s] * aux[s];
            }
            break;
        case 17:
            // Compute reference derivatives for dof 17.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients7[0][s] * aux[s];
            }
            break;
        case 18:
            // Compute reference derivatives for dof 18.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients8[0][s] * aux[s];
            }
            break;
        case 19:
            // Compute reference derivatives for dof 19.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients9[0][s] * aux[s];
            }
            break;
        case 20:
            // Compute reference derivatives for dof 20.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 21:
            // Compute reference derivatives for dof 21.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 22:
            // Compute reference derivatives for dof 22.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 23:
            // Compute reference derivatives for dof 23.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        case 24:
            // Compute reference derivatives for dof 24.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients4[0][s] * aux[s];
            }
            break;
        case 25:
            // Compute reference derivatives for dof 25.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients5[0][s] * aux[s];
            }
            break;
        case 26:
            // Compute reference derivatives for dof 26.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients6[0][s] * aux[s];
            }
            break;
        case 27:
            // Compute reference derivatives for dof 27.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients7[0][s] * aux[s];
            }
            break;
        case 28:
            // Compute reference derivatives for dof 28.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients8[0][s] * aux[s];
            }
            break;
        case 29:
            // Compute reference derivatives for dof 29.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[10] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[10][10] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 100*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[10][10];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 100*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 10; ++l0)
                        for (int64_t l1 = 0; l1 < 10; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 10; ++t)
                        for (int64_t u = 0; u < 10; ++u)
                            for (int64_t tu = 0; tu < 10; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 10; ++s)
                    for (int64_t t = 0; t < 10; ++t)
                        aux[s] += dmats[s][t] * basisvalues2[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 10; ++s)
                    derivatives[r] += coefficients9[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[30 * (num_derivatives * 3) * ip + num_derivatives * 3 * i + 3 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives = pow(3, order);
// Precomputed combinations
const int64_t combinations[2][9][2] =
    { { { 0, 0 },
        { 1, 0 },
        { 2, 0 },
        { 0, 0 },
        { 1, 0 },
        { 2, 0 },
        { 0, 0 },
        { 1, 0 },
        { 2, 0 } },
      { { 0, 0 },
        { 0, 1 },
        { 0, 2 },
        { 1, 0 },
        { 1, 1 },
        { 1, 2 },
        { 2, 0 },
        { 2, 1 },
        { 2, 2 } } };
for (int64_t l = 0; l < num_points * 30 * num_derivatives * 3; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[30] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
const int64_t physical_offsets[30] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[9][9];
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
    for (int64_t d = 0; d < 30; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[30 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[30 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[3];
reference_values[2] = physical_values[6];
reference_values[3] = physical_values[9];
reference_values[4] = physical_values[12];
reference_values[5] = physical_values[15];
reference_values[6] = physical_values[18];
reference_values[7] = physical_values[21];
reference_values[8] = physical_values[24];
reference_values[9] = physical_values[27];
reference_values[10] = physical_values[31];
reference_values[11] = physical_values[34];
reference_values[12] = physical_values[37];
reference_values[13] = physical_values[40];
reference_values[14] = physical_values[43];
reference_values[15] = physical_values[46];
reference_values[16] = physical_values[49];
reference_values[17] = physical_values[52];
reference_values[18] = physical_values[55];
reference_values[19] = physical_values[58];
reference_values[20] = physical_values[62];
reference_values[21] = physical_values[65];
reference_values[22] = physical_values[68];
reference_values[23] = physical_values[71];
reference_values[24] = physical_values[74];
reference_values[25] = physical_values[77];
reference_values[26] = physical_values[80];
reference_values[27] = physical_values[83];
reference_values[28] = physical_values[86];
reference_values[29] = physical_values[89];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[90] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0 };
memcpy(reference_dof_coordinates, dof_X, 90*sizeof(double));
return 0;
}

fenics_finite_element* create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main(void);

fenics_finite_element* create_sub_element_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(int i)
{
  switch (i)
{
case 0:
    return create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main();
case 1:
    return create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main();
case 2:
    return create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_finite_element_main();
default:
    return NULL;
}
}

fenics_finite_element* create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "VectorElement(FiniteElement('Lagrange', tetrahedron, 2), dim=3)";
  element->cell_shape = tetrahedron;
  element->topological_dimension = 3;
  element->geometric_dimension = 3;
  element->space_dimension = 30;
  element->value_rank = 1;
  element->value_dimension = value_dimension_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;
  element->value_size = 3;
  element->reference_value_rank = 1;
  element->reference_value_dimension = reference_value_dimension_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;
  element->reference_value_size = 3;
  element->degree = 2;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;
  element->transform_values = transform_values_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;
  element->num_sub_elements = 3;
  element->create_sub_element = create_sub_element_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;
  element->create = create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;

  return element;
};

// End of code for element ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main

// Code for element ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main

int value_dimension_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(int i)
{
  return 1;
}

int reference_value_dimension_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(int i)
{
  return 1;
}

int evaluate_reference_basis_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
for (int64_t k = 0; k < num_points * 4; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 4; ++r)
        reference_values[4 * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[4 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[4 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[4 * ip + 3] += coefficients3[0][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(3, order);
for (int64_t l0 = 0; l0 < num_points * 4 * num_derivatives; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[3][4][4] =
    { { { 0.0, 0.0, 0.0, 0.0 },
        { 6.324555320336758, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 5.477225575051664, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 1.8257418583505545, 0.0, 0.0, 0.0 },
        { 5.163977794943223, 0.0, 0.0, 0.0 } } };
static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
const int64_t reference_offset[4] = { 0 };
const int64_t num_components[4] = { 1, 1, 1, 1 };
// Precomputed combinations
const int64_t combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Loop over all dofs
    for (int64_t i = 0; i < 4; ++i)
    {
        double derivatives[3] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[4 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives = pow(3, order);
// Precomputed combinations
const int64_t combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t l = 0; l < num_points * 4 * num_derivatives; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[4] = { 0 };
const int64_t physical_offsets[4] = { 0 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[3][3];
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
    for (int64_t d = 0; d < 4; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[4 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[4 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[1];
reference_values[2] = physical_values[2];
reference_values[3] = physical_values[3];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[12] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
memcpy(reference_dof_coordinates, dof_X, 12*sizeof(double));
return 0;
}


fenics_finite_element* create_sub_element_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(int i)
{
  return NULL;
}

fenics_finite_element* create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "FiniteElement('Lagrange', tetrahedron, 1)";
  element->cell_shape = tetrahedron;
  element->topological_dimension = 3;
  element->geometric_dimension = 3;
  element->space_dimension = 4;
  element->value_rank = 0;
  element->value_dimension = value_dimension_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main;
  element->value_size = 1;
  element->reference_value_rank = 0;
  element->reference_value_dimension = reference_value_dimension_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main;
  element->reference_value_size = 1;
  element->degree = 1;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main;
  element->transform_values = transform_values_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main;
  element->num_sub_elements = 0;
  element->create_sub_element = create_sub_element_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main;
  element->create = create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main;

  return element;
};

// End of code for element ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main

// Code for element ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main

int value_dimension_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int reference_value_dimension_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int evaluate_reference_basis_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
for (int64_t k = 0; k < num_points * 12 * 3; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 2] += coefficients2[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 3] += coefficients3[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 4 + 1] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 5 + 1] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 6 + 1] += coefficients2[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 7 + 1] += coefficients3[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 8 + 2] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 9 + 2] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 10 + 2] += coefficients2[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[12 * 3 * ip + 3 * 11 + 2] += coefficients3[0][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(3, order);
for (int64_t l0 = 0; l0 < num_points * 12 * num_derivatives * 3; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[3][4][4] =
    { { { 0.0, 0.0, 0.0, 0.0 },
        { 6.324555320336758, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 5.477225575051664, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 1.8257418583505545, 0.0, 0.0, 0.0 },
        { 5.163977794943223, 0.0, 0.0, 0.0 } } };
static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
const int64_t reference_offset[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
const int64_t num_components[12] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
// Precomputed combinations
const int64_t combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Loop over all dofs
    for (int64_t i = 0; i < 12; ++i)
    {
        double derivatives[3] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        case 4:
            // Compute reference derivatives for dof 4.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 5:
            // Compute reference derivatives for dof 5.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 6:
            // Compute reference derivatives for dof 6.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 7:
            // Compute reference derivatives for dof 7.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        case 8:
            // Compute reference derivatives for dof 8.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 9:
            // Compute reference derivatives for dof 9.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 10:
            // Compute reference derivatives for dof 10.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 11:
            // Compute reference derivatives for dof 11.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[12 * (num_derivatives * 3) * ip + num_derivatives * 3 * i + 3 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives = pow(3, order);
// Precomputed combinations
const int64_t combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t l = 0; l < num_points * 12 * num_derivatives * 3; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
const int64_t physical_offsets[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[3][3];
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
    for (int64_t d = 0; d < 12; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[12 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[12 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using affine transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  reference_values[0] = physical_values[0];
reference_values[1] = physical_values[3];
reference_values[2] = physical_values[6];
reference_values[3] = physical_values[9];
reference_values[4] = physical_values[13];
reference_values[5] = physical_values[16];
reference_values[6] = physical_values[19];
reference_values[7] = physical_values[22];
reference_values[8] = physical_values[26];
reference_values[9] = physical_values[29];
reference_values[10] = physical_values[32];
reference_values[11] = physical_values[35];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[36] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
memcpy(reference_dof_coordinates, dof_X, 36*sizeof(double));
return 0;
}

fenics_finite_element* create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(void);

fenics_finite_element* create_sub_element_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(int i)
{
  switch (i)
{
case 0:
    return create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main();
case 1:
    return create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main();
case 2:
    return create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main();
default:
    return NULL;
}
}

fenics_finite_element* create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
  element->cell_shape = tetrahedron;
  element->topological_dimension = 3;
  element->geometric_dimension = 3;
  element->space_dimension = 12;
  element->value_rank = 1;
  element->value_dimension = value_dimension_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main;
  element->value_size = 3;
  element->reference_value_rank = 1;
  element->reference_value_dimension = reference_value_dimension_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main;
  element->reference_value_size = 3;
  element->degree = 1;
  element->family = "Lagrange";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main;
  element->transform_values = transform_values_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main;
  element->num_sub_elements = 3;
  element->create_sub_element = create_sub_element_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main;
  element->create = create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main;

  return element;
};

// End of code for element ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main

// Code for element ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main

int value_dimension_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int reference_value_dimension_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(int i)
{
  static const int return_values[1] = { 3 };
if (i >= 1)
    return 1;
return return_values[i];
}

int evaluate_reference_basis_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[3][4] =
    { { 0.0, 0.0, 0.0, 0.0 },
      { -0.288675134594813, 0.0, 0.0, -0.22360679774997896 },
      { 0.2886751345948127, 0.0, 0.21081851067789184, -0.07453559924999294 } };
static const double coefficients1[3][4] =
    { { -0.28867513459481275, 0.0, 0.0, -0.22360679774997883 },
      { 0.0, 0.0, 0.0, 0.0 },
      { 0.2886751345948127, 0.1825741858350554, -0.10540925533894596, -0.07453559924999288 } };
static const double coefficients2[3][4] =
    { { -0.28867513459481253, 0.0, -0.2108185106778917, 0.07453559924999298 },
      { 0.2886751345948131, 0.18257418583505547, -0.1054092553389459, -0.07453559924999303 },
      { 0.0, 0.0, 0.0, 0.0 } };
static const double coefficients3[3][4] =
    { { 0.2886751345948127, 0.0, 0.0, 0.22360679774997877 },
      { 0.28867513459481287, 0.0, 0.0, 0.22360679774997894 },
      { 0.5773502691896258, -0.18257418583505544, -0.10540925533894596, 0.14907119849998585 } };
static const double coefficients4[3][4] =
    { { 0.28867513459481264, 0.0, 0.2108185106778917, -0.07453559924999291 },
      { 0.5773502691896255, -0.18257418583505552, 0.10540925533894593, -0.149071198499986 },
      { 0.2886751345948127, 0.0, 0.21081851067789178, -0.07453559924999292 } };
static const double coefficients5[3][4] =
    { { 0.5773502691896262, 0.0, -0.21081851067789173, -0.14907119849998596 },
      { 0.2886751345948131, 0.1825741858350555, -0.1054092553389459, -0.07453559924999295 },
      { 0.28867513459481287, 0.1825741858350554, -0.10540925533894584, -0.07453559924999295 } };
for (int64_t k = 0; k < num_points * 6 * 3; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Accumulate products of coefficients and basisvalues
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[6 * 3 * ip + c] += coefficients0[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[6 * 3 * ip + 3 + c] += coefficients1[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[6 * 3 * ip + 3 * 2 + c] += coefficients2[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[6 * 3 * ip + 3 * 3 + c] += coefficients3[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[6 * 3 * ip + 3 * 4 + c] += coefficients4[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[6 * 3 * ip + 3 * 5 + c] += coefficients5[c][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(3, order);
for (int64_t l0 = 0; l0 < num_points * 6 * num_derivatives * 3; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[3][4][4] =
    { { { 0.0, 0.0, 0.0, 0.0 },
        { 6.324555320336758, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 5.477225575051664, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 1.8257418583505545, 0.0, 0.0, 0.0 },
        { 5.163977794943223, 0.0, 0.0, 0.0 } } };
static const double coefficients0[3][4] =
    { { 0.0, 0.0, 0.0, 0.0 },
      { -0.288675134594813, 0.0, 0.0, -0.22360679774997896 },
      { 0.2886751345948127, 0.0, 0.21081851067789184, -0.07453559924999294 } };
static const double coefficients1[3][4] =
    { { -0.28867513459481275, 0.0, 0.0, -0.22360679774997883 },
      { 0.0, 0.0, 0.0, 0.0 },
      { 0.2886751345948127, 0.1825741858350554, -0.10540925533894596, -0.07453559924999288 } };
static const double coefficients2[3][4] =
    { { -0.28867513459481253, 0.0, -0.2108185106778917, 0.07453559924999298 },
      { 0.2886751345948131, 0.18257418583505547, -0.1054092553389459, -0.07453559924999303 },
      { 0.0, 0.0, 0.0, 0.0 } };
static const double coefficients3[3][4] =
    { { 0.2886751345948127, 0.0, 0.0, 0.22360679774997877 },
      { 0.28867513459481287, 0.0, 0.0, 0.22360679774997894 },
      { 0.5773502691896258, -0.18257418583505544, -0.10540925533894596, 0.14907119849998585 } };
static const double coefficients4[3][4] =
    { { 0.28867513459481264, 0.0, 0.2108185106778917, -0.07453559924999291 },
      { 0.5773502691896255, -0.18257418583505552, 0.10540925533894593, -0.149071198499986 },
      { 0.2886751345948127, 0.0, 0.21081851067789178, -0.07453559924999292 } };
static const double coefficients5[3][4] =
    { { 0.5773502691896262, 0.0, -0.21081851067789173, -0.14907119849998596 },
      { 0.2886751345948131, 0.1825741858350555, -0.1054092553389459, -0.07453559924999295 },
      { 0.28867513459481287, 0.1825741858350554, -0.10540925533894584, -0.07453559924999295 } };
const int64_t reference_offset[6] = { 0 };
const int64_t num_components[6] = { 3, 3, 3, 3, 3, 3 };
// Precomputed combinations
const int64_t combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Loop over all dofs
    for (int64_t i = 0; i < 6; ++i)
    {
        double derivatives[9] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients0[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients0[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients0[2][s] * aux[s];
                }
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients1[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients1[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients1[2][s] * aux[s];
                }
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients2[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients2[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients2[2][s] * aux[s];
                }
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients3[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients3[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients3[2][s] * aux[s];
                }
            }
            break;
        case 4:
            // Compute reference derivatives for dof 4.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients4[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients4[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients4[2][s] * aux[s];
                }
            }
            break;
        case 5:
            // Compute reference derivatives for dof 5.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients5[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients5[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients5[2][s] * aux[s];
                }
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[6 * (num_derivatives * 3) * ip + num_derivatives * 3 * i + 3 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives = pow(3, order);
// Precomputed combinations
const int64_t combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t l = 0; l < num_points * 6 * num_derivatives * 3; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[6] = { 0 };
const int64_t physical_offsets[6] = { 0 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[3][3];
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
    for (int64_t d = 0; d < 6; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 3; ++i)
            {
                // Using covariant Piola transform to map values back to the physical element.
                const double mapped_value = K[3 * 3 * ip + i] * reference_values[6 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * s + reference_offsets[d]] + K[3 * 3 * ip + 3 + i] * reference_values[6 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * s + (reference_offsets[d] + 1)] + K[3 * 3 * ip + 3 * 2 + i] * reference_values[6 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * s + (reference_offsets[d] + 2)];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[6 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using covariant Piola transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  // Compute Jacobian
double J[9];
compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
reference_values[0] = -(physical_values[0] * J[1] + physical_values[1] * J[3 + 1] + physical_values[2] * J[3 * 2 + 1]) + (physical_values[0] * J[2] + physical_values[1] * J[3 + 2] + physical_values[2] * J[3 * 2 + 2]);
reference_values[1] = -(physical_values[3] * J[0] + physical_values[4] * J[3] + physical_values[5] * J[3 * 2]) + (physical_values[3] * J[2] + physical_values[4] * J[3 + 2] + physical_values[5] * J[3 * 2 + 2]);
reference_values[2] = -(physical_values[6] * J[0] + physical_values[7] * J[3] + physical_values[8] * J[3 * 2]) + (physical_values[6] * J[1] + physical_values[7] * J[3 + 1] + physical_values[8] * J[3 * 2 + 1]);
reference_values[3] = physical_values[9] * J[2] + physical_values[10] * J[3 + 2] + physical_values[11] * J[3 * 2 + 2];
reference_values[4] = physical_values[12] * J[1] + physical_values[13] * J[3 + 1] + physical_values[14] * J[3 * 2 + 1];
reference_values[5] = physical_values[15] * J[0] + physical_values[16] * J[3] + physical_values[17] * J[3 * 2];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[18] = { 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0 };
memcpy(reference_dof_coordinates, dof_X, 18*sizeof(double));
return 0;
}


fenics_finite_element* create_sub_element_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(int i)
{
  return NULL;
}

fenics_finite_element* create_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "FiniteElement('Nedelec 1st kind H(curl)', tetrahedron, 1)";
  element->cell_shape = tetrahedron;
  element->topological_dimension = 3;
  element->geometric_dimension = 3;
  element->space_dimension = 6;
  element->value_rank = 1;
  element->value_dimension = value_dimension_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main;
  element->value_size = 3;
  element->reference_value_rank = 1;
  element->reference_value_dimension = reference_value_dimension_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main;
  element->reference_value_size = 3;
  element->degree = 1;
  element->family = "Nedelec 1st kind H(curl)";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main;
  element->transform_values = transform_values_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main;
  element->num_sub_elements = 0;
  element->create_sub_element = create_sub_element_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main;
  element->create = create_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main;

  return element;
};

// End of code for element ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main

// Code for element ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main

int value_dimension_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(int i)
{
  static const int return_values[1] = { 4 };
if (i >= 1)
    return 1;
return return_values[i];
}

int reference_value_dimension_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(int i)
{
  static const int return_values[1] = { 4 };
if (i >= 1)
    return 1;
return return_values[i];
}

int evaluate_reference_basis_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(double* restrict reference_values,
                                            int num_points,
                                            const double* restrict X)
{
  static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
static const double coefficients4[3][4] =
    { { 0.0, 0.0, 0.0, 0.0 },
      { -0.288675134594813, 0.0, 0.0, -0.22360679774997896 },
      { 0.2886751345948127, 0.0, 0.21081851067789184, -0.07453559924999294 } };
static const double coefficients5[3][4] =
    { { -0.28867513459481275, 0.0, 0.0, -0.22360679774997883 },
      { 0.0, 0.0, 0.0, 0.0 },
      { 0.2886751345948127, 0.1825741858350554, -0.10540925533894596, -0.07453559924999288 } };
static const double coefficients6[3][4] =
    { { -0.28867513459481253, 0.0, -0.2108185106778917, 0.07453559924999298 },
      { 0.2886751345948131, 0.18257418583505547, -0.1054092553389459, -0.07453559924999303 },
      { 0.0, 0.0, 0.0, 0.0 } };
static const double coefficients7[3][4] =
    { { 0.2886751345948127, 0.0, 0.0, 0.22360679774997877 },
      { 0.28867513459481287, 0.0, 0.0, 0.22360679774997894 },
      { 0.5773502691896258, -0.18257418583505544, -0.10540925533894596, 0.14907119849998585 } };
static const double coefficients8[3][4] =
    { { 0.28867513459481264, 0.0, 0.2108185106778917, -0.07453559924999291 },
      { 0.5773502691896255, -0.18257418583505552, 0.10540925533894593, -0.149071198499986 },
      { 0.2886751345948127, 0.0, 0.21081851067789178, -0.07453559924999292 } };
static const double coefficients9[3][4] =
    { { 0.5773502691896262, 0.0, -0.21081851067789173, -0.14907119849998596 },
      { 0.2886751345948131, 0.1825741858350555, -0.1054092553389459, -0.07453559924999295 },
      { 0.28867513459481287, 0.1825741858350554, -0.10540925533894584, -0.07453559924999295 } };
for (int64_t k = 0; k < num_points * 10 * 4; ++k)
    reference_values[k] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Accumulate products of coefficients and basisvalues
    for (int64_t r = 0; r < 4; ++r)
        reference_values[10 * 4 * ip] += coefficients0[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[10 * 4 * ip + 4] += coefficients1[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[10 * 4 * ip + 4 * 2] += coefficients2[0][r] * basisvalues1[r];
    for (int64_t r = 0; r < 4; ++r)
        reference_values[10 * 4 * ip + 4 * 3] += coefficients3[0][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[10 * 4 * ip + 4 * 4 + (1 + c)] += coefficients4[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[10 * 4 * ip + 4 * 5 + (1 + c)] += coefficients5[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[10 * 4 * ip + 4 * 6 + (1 + c)] += coefficients6[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[10 * 4 * ip + 4 * 7 + (1 + c)] += coefficients7[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[10 * 4 * ip + 4 * 8 + (1 + c)] += coefficients8[c][r] * basisvalues1[r];
    for (int64_t c = 0; c < 3; ++c)
        for (int64_t r = 0; r < 4; ++r)
            reference_values[10 * 4 * ip + 4 * 9 + (1 + c)] += coefficients9[c][r] * basisvalues1[r];
}
return 0;
}

int evaluate_reference_basis_derivatives_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(double * restrict reference_values,
                                          int order, int num_points,
                                          const double * restrict X)
{
  if (order == 0)
    return evaluate_reference_basis_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(reference_values, num_points, X);
const int64_t num_derivatives = pow(3, order);
for (int64_t l0 = 0; l0 < num_points * 10 * num_derivatives * 4; ++l0)
    reference_values[l0] = 0.0;
if (order > 1)
    return 0;
// Tables of derivatives of the polynomial base (transpose).
alignas(32) static const double dmats0[3][4][4] =
    { { { 0.0, 0.0, 0.0, 0.0 },
        { 6.324555320336758, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 5.477225575051664, 0.0, 0.0, 0.0 },
        { 0.0, 0.0, 0.0, 0.0 } },
      { { 0.0, 0.0, 0.0, 0.0 },
        { 3.162277660168379, 0.0, 0.0, 0.0 },
        { 1.8257418583505545, 0.0, 0.0, 0.0 },
        { 5.163977794943223, 0.0, 0.0, 0.0 } } };
static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
static const double coefficients4[3][4] =
    { { 0.0, 0.0, 0.0, 0.0 },
      { -0.288675134594813, 0.0, 0.0, -0.22360679774997896 },
      { 0.2886751345948127, 0.0, 0.21081851067789184, -0.07453559924999294 } };
static const double coefficients5[3][4] =
    { { -0.28867513459481275, 0.0, 0.0, -0.22360679774997883 },
      { 0.0, 0.0, 0.0, 0.0 },
      { 0.2886751345948127, 0.1825741858350554, -0.10540925533894596, -0.07453559924999288 } };
static const double coefficients6[3][4] =
    { { -0.28867513459481253, 0.0, -0.2108185106778917, 0.07453559924999298 },
      { 0.2886751345948131, 0.18257418583505547, -0.1054092553389459, -0.07453559924999303 },
      { 0.0, 0.0, 0.0, 0.0 } };
static const double coefficients7[3][4] =
    { { 0.2886751345948127, 0.0, 0.0, 0.22360679774997877 },
      { 0.28867513459481287, 0.0, 0.0, 0.22360679774997894 },
      { 0.5773502691896258, -0.18257418583505544, -0.10540925533894596, 0.14907119849998585 } };
static const double coefficients8[3][4] =
    { { 0.28867513459481264, 0.0, 0.2108185106778917, -0.07453559924999291 },
      { 0.5773502691896255, -0.18257418583505552, 0.10540925533894593, -0.149071198499986 },
      { 0.2886751345948127, 0.0, 0.21081851067789178, -0.07453559924999292 } };
static const double coefficients9[3][4] =
    { { 0.5773502691896262, 0.0, -0.21081851067789173, -0.14907119849998596 },
      { 0.2886751345948131, 0.1825741858350555, -0.1054092553389459, -0.07453559924999295 },
      { 0.28867513459481287, 0.1825741858350554, -0.10540925533894584, -0.07453559924999295 } };
const int64_t reference_offset[10] = { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 };
const int64_t num_components[10] = { 1, 1, 1, 1, 3, 3, 3, 3, 3, 3 };
// Precomputed combinations
const int64_t combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Map from UFC reference coordinate X to FIAT reference coordinate Y
    const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
    // Compute basisvalues for each relevant embedded degree
    double basisvalues1[4] = { 0 };
    basisvalues1[0] = 1.0;
    const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
    basisvalues1[1] = tmp1_1;
    basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
    basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
    basisvalues1[0] *= sqrt(0.75);
    basisvalues1[3] *= sqrt(1.25);
    basisvalues1[2] *= sqrt(2.5);
    basisvalues1[1] *= sqrt(7.5);
    // Loop over all dofs
    for (int64_t i = 0; i < 10; ++i)
    {
        double derivatives[9] = { 0 };
        switch (i)
        {
        case 0:
            // Compute reference derivatives for dof 0.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients0[0][s] * aux[s];
            }
            break;
        case 1:
            // Compute reference derivatives for dof 1.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients1[0][s] * aux[s];
            }
            break;
        case 2:
            // Compute reference derivatives for dof 2.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients2[0][s] * aux[s];
            }
            break;
        case 3:
            // Compute reference derivatives for dof 3.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                    derivatives[r] += coefficients3[0][s] * aux[s];
            }
            break;
        case 4:
            // Compute reference derivatives for dof 4.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients4[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients4[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients4[2][s] * aux[s];
                }
            }
            break;
        case 5:
            // Compute reference derivatives for dof 5.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients5[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients5[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients5[2][s] * aux[s];
                }
            }
            break;
        case 6:
            // Compute reference derivatives for dof 6.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients6[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients6[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients6[2][s] * aux[s];
                }
            }
            break;
        case 7:
            // Compute reference derivatives for dof 7.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients7[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients7[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients7[2][s] * aux[s];
                }
            }
            break;
        case 8:
            // Compute reference derivatives for dof 8.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients8[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients8[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients8[2][s] * aux[s];
                }
            }
            break;
        case 9:
            // Compute reference derivatives for dof 9.
            for (int64_t r = 0; r < num_derivatives; ++r)
            {
                double aux[4] = { 0 };
                // Declare derivative matrix (of polynomial basis).
                double dmats[4][4] = {{ 0 }};
                // Initialize dmats.
                int64_t comb = combinations[order - 1][r][0];
                memcpy(&dmats[0][0], &dmats0[comb][0][0], 16*sizeof(double));
                // Looping derivative order to generate dmats.
                for (int64_t s = 1; s < order; ++s)
                {
                    // Store previous dmats matrix.
                    double dmats_old[4][4];
                    memcpy(&dmats_old[0][0], &dmats[0][0], 16*sizeof(double));
                    // Resetting dmats.
                    for (int64_t l0 = 0; l0 < 4; ++l0)
                        for (int64_t l1 = 0; l1 < 4; ++l1)
                            dmats[l0][l1] = 0.0;
                    // Update dmats using an inner product.
                    comb = combinations[order - 1][r][s];
                    for (int64_t t = 0; t < 4; ++t)
                        for (int64_t u = 0; u < 4; ++u)
                            for (int64_t tu = 0; tu < 4; ++tu)
                                dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                }
                for (int64_t s = 0; s < 4; ++s)
                    for (int64_t t = 0; t < 4; ++t)
                        aux[s] += dmats[s][t] * basisvalues1[t];
                derivatives[r] = 0.0;
                derivatives[num_derivatives + r] = 0.0;
                derivatives[num_derivatives * 2 + r] = 0.0;
                for (int64_t s = 0; s < 4; ++s)
                {
                    derivatives[r] += coefficients9[0][s] * aux[s];
                    derivatives[num_derivatives + r] += coefficients9[1][s] * aux[s];
                    derivatives[num_derivatives * 2 + r] += coefficients9[2][s] * aux[s];
                }
            }
            break;
        }
        for (int64_t r = 0; r < num_derivatives; ++r)
            for (int64_t c = 0; c < num_components[i]; ++c)
                reference_values[10 * (num_derivatives * 4) * ip + num_derivatives * 4 * i + 4 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
    }
}
return 0;
}

int transform_reference_basis_derivatives_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(
    double * restrict values, int order, int num_points,
    const double * restrict reference_values,
    const double * restrict X, const double * restrict J,
    const double * restrict detJ, const double * restrict K,
    int cell_orientation)
{
  const int64_t num_derivatives = pow(3, order);
// Precomputed combinations
const int64_t combinations[1][3][1] =
    { { { 0 },
        { 1 },
        { 2 } } };
for (int64_t l = 0; l < num_points * 10 * num_derivatives * 4; ++l)
    values[l] = 0.0;
const int64_t reference_offsets[10] = { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 };
const int64_t physical_offsets[10] = { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 };
for (int64_t ip = 0; ip < num_points; ++ip)
{
    double transform[3][3];
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            transform[r][s] = 1.0;
    for (int64_t r = 0; r < num_derivatives; ++r)
        for (int64_t s = 0; s < num_derivatives; ++s)
            for (int64_t k = 0; k < order; ++k)
                transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
    for (int64_t d = 0; d < 4; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 1; ++i)
            {
                // Using affine transform to map values back to the physical element.
                const double mapped_value = reference_values[10 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * s + reference_offsets[d]];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[10 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
    for (int64_t d = 4; d < 10; ++d)
    {
        for (int64_t s = 0; s < num_derivatives; ++s)
        {
            for (int64_t i = 0; i < 3; ++i)
            {
                // Using covariant Piola transform to map values back to the physical element.
                const double mapped_value = K[3 * 3 * ip + i] * reference_values[10 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * s + reference_offsets[d]] + K[3 * 3 * ip + 3 + i] * reference_values[10 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * s + (reference_offsets[d] + 1)] + K[3 * 3 * ip + 3 * 2 + i] * reference_values[10 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * s + (reference_offsets[d] + 2)];
                // Mapping derivatives back to the physical element
                for (int64_t r = 0; r < num_derivatives; ++r)
                    values[10 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
            }
        }
    }
}
// Using covariant Piola transform to map values back to the physical element.
return 0;
}

int transform_values_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(
     fenics_scalar_t* restrict reference_values,
     const fenics_scalar_t* restrict physical_values,
     const double* restrict coordinate_dofs,
     int cell_orientation,
     const fenics_coordinate_mapping* cm)
{
  // Compute Jacobian
double J[9];
compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
reference_values[0] = physical_values[0];
reference_values[1] = physical_values[4];
reference_values[2] = physical_values[8];
reference_values[3] = physical_values[12];
reference_values[4] = -(physical_values[17] * J[1] + physical_values[18] * J[3 + 1] + physical_values[19] * J[3 * 2 + 1]) + (physical_values[17] * J[2] + physical_values[18] * J[3 + 2] + physical_values[19] * J[3 * 2 + 2]);
reference_values[5] = -(physical_values[21] * J[0] + physical_values[22] * J[3] + physical_values[23] * J[3 * 2]) + (physical_values[21] * J[2] + physical_values[22] * J[3 + 2] + physical_values[23] * J[3 * 2 + 2]);
reference_values[6] = -(physical_values[25] * J[0] + physical_values[26] * J[3] + physical_values[27] * J[3 * 2]) + (physical_values[25] * J[1] + physical_values[26] * J[3 + 1] + physical_values[27] * J[3 * 2 + 1]);
reference_values[7] = physical_values[29] * J[2] + physical_values[30] * J[3 + 2] + physical_values[31] * J[3 * 2 + 2];
reference_values[8] = physical_values[33] * J[1] + physical_values[34] * J[3 + 1] + physical_values[35] * J[3 * 2 + 1];
reference_values[9] = physical_values[37] * J[0] + physical_values[38] * J[3] + physical_values[39] * J[3 * 2];
return 0;
}

int tabulate_reference_dof_coordinates_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(double* restrict reference_dof_coordinates)
{
  static const double dof_X[30] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0 };
memcpy(reference_dof_coordinates, dof_X, 30*sizeof(double));
return 0;
}

fenics_finite_element* create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(void);
fenics_finite_element* create_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main(void);

fenics_finite_element* create_sub_element_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(int i)
{
  switch (i)
{
case 0:
    return create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main();
case 1:
    return create_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_finite_element_main();
default:
    return NULL;
}
}

fenics_finite_element* create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(void)
{
  fenics_finite_element* element = malloc(sizeof(*element));

  element->signature = "MixedElement(FiniteElement('Lagrange', tetrahedron, 1), FiniteElement('Nedelec 1st kind H(curl)', tetrahedron, 1))";
  element->cell_shape = tetrahedron;
  element->topological_dimension = 3;
  element->geometric_dimension = 3;
  element->space_dimension = 10;
  element->value_rank = 1;
  element->value_dimension = value_dimension_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  element->value_size = 4;
  element->reference_value_rank = 1;
  element->reference_value_dimension = reference_value_dimension_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  element->reference_value_size = 4;
  element->degree = 1;
  element->family = "Mixed";
  element->evaluate_reference_basis = evaluate_reference_basis_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  element->evaluate_reference_basis_derivatives = evaluate_reference_basis_derivatives_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  element->transform_reference_basis_derivatives = transform_reference_basis_derivatives_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  element->transform_values = transform_values_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  element->tabulate_reference_dof_coordinates = tabulate_reference_dof_coordinates_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  element->num_sub_elements = 2;
  element->create_sub_element = create_sub_element_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  element->create = create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;

  return element;
};

// End of code for element ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main

// Code for dofmap ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main

void tabulate_entity_dofs_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    case 2:
        dofs[0] = 2;
        break;
    case 3:
        dofs[0] = 3;
        break;
    }
    break;
case 1:
    switch (i)
    {
    case 0:
        dofs[0] = 4;
        break;
    case 1:
        dofs[0] = 5;
        break;
    case 2:
        dofs[0] = 6;
        break;
    case 3:
        dofs[0] = 7;
        break;
    case 4:
        dofs[0] = 8;
        break;
    case 5:
        dofs[0] = 9;
        break;
    }
    break;
}
}


fenics_dofmap* create_sub_dofmap_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main(int i)
{
return NULL;
}

fenics_dofmap* create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for FiniteElement('Lagrange', tetrahedron, 2)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 10;
  dofmap->num_entity_dofs[0] = 1;
  dofmap->num_entity_dofs[1] = 1;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main;
  dofmap->num_sub_dofmaps = 0;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main;
  dofmap->create = create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main

// Code for dofmap ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main

void tabulate_entity_dofs_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        dofs[1] = 10;
        dofs[2] = 20;
        break;
    case 1:
        dofs[0] = 1;
        dofs[1] = 11;
        dofs[2] = 21;
        break;
    case 2:
        dofs[0] = 2;
        dofs[1] = 12;
        dofs[2] = 22;
        break;
    case 3:
        dofs[0] = 3;
        dofs[1] = 13;
        dofs[2] = 23;
        break;
    }
    break;
case 1:
    switch (i)
    {
    case 0:
        dofs[0] = 4;
        dofs[1] = 14;
        dofs[2] = 24;
        break;
    case 1:
        dofs[0] = 5;
        dofs[1] = 15;
        dofs[2] = 25;
        break;
    case 2:
        dofs[0] = 6;
        dofs[1] = 16;
        dofs[2] = 26;
        break;
    case 3:
        dofs[0] = 7;
        dofs[1] = 17;
        dofs[2] = 27;
        break;
    case 4:
        dofs[0] = 8;
        dofs[1] = 18;
        dofs[2] = 28;
        break;
    case 5:
        dofs[0] = 9;
        dofs[1] = 19;
        dofs[2] = 29;
        break;
    }
    break;
}
}

fenics_dofmap* create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main(void);

fenics_dofmap* create_sub_dofmap_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main();
case 1:
    return create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main();
case 2:
    return create_ffc_element_ee842efaff850c68ef813950918d0afe4f876107_dofmap_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for VectorElement(FiniteElement('Lagrange', tetrahedron, 2), dim=3)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 30;
  dofmap->num_entity_dofs[0] = 3;
  dofmap->num_entity_dofs[1] = 3;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main;
  dofmap->num_sub_dofmaps = 3;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main;
  dofmap->create = create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main

// Code for dofmap ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main

void tabulate_entity_dofs_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    case 2:
        dofs[0] = 2;
        break;
    case 3:
        dofs[0] = 3;
        break;
    }
    break;
}
}


fenics_dofmap* create_sub_dofmap_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main(int i)
{
return NULL;
}

fenics_dofmap* create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for FiniteElement('Lagrange', tetrahedron, 1)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 4;
  dofmap->num_entity_dofs[0] = 1;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main;
  dofmap->num_sub_dofmaps = 0;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main;
  dofmap->create = create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main

// Code for dofmap ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main

void tabulate_entity_dofs_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        dofs[1] = 4;
        dofs[2] = 8;
        break;
    case 1:
        dofs[0] = 1;
        dofs[1] = 5;
        dofs[2] = 9;
        break;
    case 2:
        dofs[0] = 2;
        dofs[1] = 6;
        dofs[2] = 10;
        break;
    case 3:
        dofs[0] = 3;
        dofs[1] = 7;
        dofs[2] = 11;
        break;
    }
    break;
}
}

fenics_dofmap* create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main(void);

fenics_dofmap* create_sub_dofmap_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main();
case 1:
    return create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main();
case 2:
    return create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 12;
  dofmap->num_entity_dofs[0] = 3;
  dofmap->num_entity_dofs[1] = 0;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main;
  dofmap->num_sub_dofmaps = 3;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main;
  dofmap->create = create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main

// Code for dofmap ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main

void tabulate_entity_dofs_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 1:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    case 2:
        dofs[0] = 2;
        break;
    case 3:
        dofs[0] = 3;
        break;
    case 4:
        dofs[0] = 4;
        break;
    case 5:
        dofs[0] = 5;
        break;
    }
    break;
}
}


fenics_dofmap* create_sub_dofmap_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main(int i)
{
return NULL;
}

fenics_dofmap* create_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for FiniteElement('Nedelec 1st kind H(curl)', tetrahedron, 1)";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 6;
  dofmap->num_entity_dofs[0] = 0;
  dofmap->num_entity_dofs[1] = 1;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main;
  dofmap->num_sub_dofmaps = 0;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main;
  dofmap->create = create_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main

// Code for dofmap ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main

void tabulate_entity_dofs_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main(int* restrict dofs, int d, int i)
{
switch (d)
{
case 0:
    switch (i)
    {
    case 0:
        dofs[0] = 0;
        break;
    case 1:
        dofs[0] = 1;
        break;
    case 2:
        dofs[0] = 2;
        break;
    case 3:
        dofs[0] = 3;
        break;
    }
    break;
case 1:
    switch (i)
    {
    case 0:
        dofs[0] = 4;
        break;
    case 1:
        dofs[0] = 5;
        break;
    case 2:
        dofs[0] = 6;
        break;
    case 3:
        dofs[0] = 7;
        break;
    case 4:
        dofs[0] = 8;
        break;
    case 5:
        dofs[0] = 9;
        break;
    }
    break;
}
}

fenics_dofmap* create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main(void);
fenics_dofmap* create_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main(void);

fenics_dofmap* create_sub_dofmap_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_dofmap_main();
case 1:
    return create_ffc_element_5ca9aa173a4a215c3bd1e99d9aa74f41fa5b4079_dofmap_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main(void)
{
  fenics_dofmap* dofmap = malloc(sizeof(*dofmap));
  dofmap->signature = "FFC dofmap for MixedElement(FiniteElement('Lagrange', tetrahedron, 1), FiniteElement('Nedelec 1st kind H(curl)', tetrahedron, 1))";
  dofmap->num_global_support_dofs = 0;
  dofmap->num_element_support_dofs = 10;
  dofmap->num_entity_dofs[0] = 1;
  dofmap->num_entity_dofs[1] = 1;
  dofmap->num_entity_dofs[2] = 0;
  dofmap->num_entity_dofs[3] = 0;
  dofmap->tabulate_entity_dofs = tabulate_entity_dofs_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main;
  dofmap->num_sub_dofmaps = 2;
  dofmap->create_sub_dofmap = create_sub_dofmap_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main;
  dofmap->create = create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main;

  return dofmap;
};

// End of code for dofmap ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main

// Code for coordinate mapping ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main

fenics_finite_element* create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(void);

fenics_finite_element* create_coordinate_finite_element_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(void)
{
return create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main();
}

fenics_dofmap* create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main(void);

fenics_dofmap* create_coordinate_dofmap_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(void)
{
return create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main();
}


int evaluate_reference_basis_derivatives_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(double* restrict reference_values,
    int order, int num_points, const double* restrict X);

void compute_jacobians_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(double* restrict J, int num_points,
                                      const double* restrict X,
                                      const double* restrict coordinate_dofs)
{
double dphi[12];
for (int64_t l = 0; l < num_points * 3 * 3; ++l)
    J[l] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Compute basis derivatives of coordinate element
    evaluate_reference_basis_derivatives_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(dphi, 1, 1, &X[3 * ip]);
    // Compute J
    for (int64_t i = 0; i < 3; ++i)
        for (int64_t j = 0; j < 3; ++j)
            for (int64_t d = 0; d < 4; ++d)
                J[3 * 3 * ip + 3 * i + j] += coordinate_dofs[3 * d + i] * dphi[3 * d + j];
}
}

void compute_jacobian_determinants_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(double* restrict detJ, int num_points,
                                                  const double* restrict J, int cell_orientation)
{
for (int64_t ip = 0; ip < num_points; ++ip)
    detJ[ip] = J[3 * 3 * ip] * (J[3 * 3 * ip + 3 + 1] * J[3 * 3 * ip + 3 * 2 + 2] - J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2 + 1]) + J[3 * 3 * ip + 1] * (J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2] - J[3 * 3 * ip + 3] * J[3 * 3 * ip + 3 * 2 + 2]) + J[3 * 3 * ip + 2] * (J[3 * 3 * ip + 3] * J[3 * 3 * ip + 3 * 2 + 1] - J[3 * 3 * ip + 3 + 1] * J[3 * 3 * ip + 3 * 2]);
}

void compute_jacobian_inverses_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(double* restrict K, int num_points,
    const double* restrict J, const double* restrict detJ)
{
for (int64_t ip = 0; ip < num_points; ++ip)
{
    K[3 * 3 * ip] = (J[3 * 3 * ip + 3 * 2 + 2] * J[3 * 3 * ip + 3 + 1] - J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2 + 1]) / detJ[ip];
    K[3 * 3 * ip + 1] = (J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3 * 2 + 1] - J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3 * 2 + 2]) / detJ[ip];
    K[3 * 3 * ip + 2] = (J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3 + 2] - J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3 + 1]) / detJ[ip];
    K[3 * 3 * ip + 3] = (J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2] - J[3 * 3 * ip + 3 * 2 + 2] * J[3 * 3 * ip + 3]) / detJ[ip];
    K[3 * 3 * ip + 3 + 1] = (J[3 * 3 * ip + 3 * 2 + 2] * J[3 * 3 * ip] - J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3 * 2]) / detJ[ip];
    K[3 * 3 * ip + 3 + 2] = (J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3] - J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip]) / detJ[ip];
    K[3 * 3 * ip + 3 * 2] = (J[3 * 3 * ip + 3] * J[3 * 3 * ip + 3 * 2 + 1] - J[3 * 3 * ip + 3 * 2] * J[3 * 3 * ip + 3 + 1]) / detJ[ip];
    K[3 * 3 * ip + 3 * 2 + 1] = (J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3 * 2] - J[3 * 3 * ip] * J[3 * 3 * ip + 3 * 2 + 1]) / detJ[ip];
    K[3 * 3 * ip + 3 * 2 + 2] = (J[3 * 3 * ip] * J[3 * 3 * ip + 3 + 1] - J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3]) / detJ[ip];
}
}


int evaluate_reference_basis_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(double* restrict reference_values,
    int num_points, const double* restrict X);

void compute_physical_coordinates_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(double* restrict x, int num_points,
                                                 const double* restrict X,
                                                 const double* restrict coordinate_dofs)
{
double phi[4];
for (int64_t i = 0; i < num_points * 3; ++i)
    x[i] = 0.0;
for (int64_t ip = 0; ip < num_points; ++ip)
{
    // Compute basis values of coordinate element
    evaluate_reference_basis_ffc_element_d5d593bf7bdd8cdecff9765146b9ea7ef104cb59_finite_element_main(phi, 1, &X[3 * ip]);
    // Compute x
    for (int64_t i = 0; i < 3; ++i)
        for (int64_t d = 0; d < 4; ++d)
            x[3 * ip + i] += coordinate_dofs[3 * d + i] * phi[d];
}
}

void compute_geometry_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(double* restrict x, double* restrict J,
                                     double* restrict detJ, double* restrict K,
                                     int num_points, const double* restrict X,
                                     const double* restrict coordinate_dofs,
                                     int cell_orientation)
{
compute_physical_coordinates_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(x, num_points, X, coordinate_dofs);
compute_jacobians_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(J, num_points, X, coordinate_dofs);
compute_jacobian_determinants_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(detJ, num_points, J, cell_orientation);
compute_jacobian_inverses_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(K, num_points, J, detJ);
}

void compute_midpoint_geometry_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(double* restrict x, double* restrict J,
                                              const double* restrict coordinate_dofs)
{
const double phi_Xm[4] = { 0.25000000000000006, 0.24999999999999997, 0.25, 0.25 };
const double dphi_Xm[3][4] =
    { { -1.0, 1.0, 0.0, 0.0 },
      { -1.0, 0.0, 1.0, 0.0 },
      { -1.0, 0.0, 0.0, 1.0 } };
for (int64_t l = 0; l < 9; ++l)
    J[l] = 0.0;
// Compute x
for (int64_t i = 0; i < 3; ++i)
{
    x[i] = 0.0;
    for (int64_t d = 0; d < 4; ++d)
        x[i] += coordinate_dofs[3 * d + i] * phi_Xm[d];
}
// Compute J
for (int64_t i = 0; i < 3; ++i)
    for (int64_t j = 0; j < 3; ++j)
        for (int64_t d = 0; d < 4; ++d)
            J[3 * i + j] += coordinate_dofs[3 * d + i] * dphi_Xm[j][d];
}

void compute_reference_coordinates_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(double* restrict X, int num_points,
                                                  const double* restrict x,
                                                  const double* restrict coordinate_dofs,
                                                  int cell_orientation)
{
for (int64_t l = 0; l < num_points * 3; ++l)
    X[l] = 0.0;
const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
const double dphi_X0[3][4] =
    { { -1.0, 1.0, 0.0, 0.0 },
      { -1.0, 0.0, 1.0, 0.0 },
      { -1.0, 0.0, 0.0, 1.0 } };
double J[9];
double detJ[1];
double K[9];
double x0[3] = { 0 };
for (int64_t i = 0; i < 3; ++i)
    for (int64_t k = 0; k < 4; ++k)
        x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
for (int64_t i = 0; i < 3; ++i)
{
    for (int64_t j = 0; j < 3; ++j)
    {
        J[3 * i + j] = 0.0;
        for (int64_t k = 0; k < 4; ++k)
            J[3 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
    }
}
compute_jacobian_determinants_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(detJ, 1, J, cell_orientation);
compute_jacobian_inverses_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(K, 1, J, detJ);
for (int64_t ip = 0; ip < num_points; ++ip)
    for (int64_t j = 0; j < 3; ++j)
        for (int64_t i = 0; i < 3; ++i)
            X[3 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}

void compute_reference_geometry_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(double* restrict X, double* restrict J,
                                               double* restrict detJ, double* restrict K,
                                               int num_points, const double* restrict x,
                                               const double* restrict coordinate_dofs,
                                               int cell_orientation)
{
for (int64_t l = 0; l < num_points * 3; ++l)
    X[l] = 0.0;
const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
const double dphi_X0[3][4] =
    { { -1.0, 1.0, 0.0, 0.0 },
      { -1.0, 0.0, 1.0, 0.0 },
      { -1.0, 0.0, 0.0, 1.0 } };
double x0[3] = { 0 };
for (int64_t i = 0; i < 3; ++i)
    for (int64_t k = 0; k < 4; ++k)
        x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
for (int64_t i = 0; i < 3; ++i)
{
    for (int64_t j = 0; j < 3; ++j)
    {
        J[3 * i + j] = 0.0;
        for (int64_t k = 0; k < 4; ++k)
            J[3 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
    }
}
compute_jacobian_determinants_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(detJ, 1, J, cell_orientation);
compute_jacobian_inverses_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(K, 1, J, detJ);
for (int64_t ip = 0; ip < num_points; ++ip)
    for (int64_t j = 0; j < 3; ++j)
        for (int64_t i = 0; i < 3; ++i)
            X[3 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}




fenics_coordinate_mapping* create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(void)
{
  fenics_coordinate_mapping* cmap = malloc(sizeof(*cmap));
  cmap->signature = "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
  cmap->create = create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->geometric_dimension = 3;
  cmap->topological_dimension = 3;
  cmap->cell_shape = tetrahedron;
  cmap->create_coordinate_finite_element = create_coordinate_finite_element_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->create_coordinate_dofmap = create_coordinate_dofmap_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->compute_physical_coordinates = compute_physical_coordinates_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->compute_reference_coordinates = compute_reference_coordinates_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->compute_reference_geometry = compute_reference_geometry_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->compute_jacobians = compute_jacobians_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->compute_jacobian_determinants = compute_jacobian_determinants_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->compute_jacobian_inverses = compute_jacobian_inverses_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->compute_geometry = compute_geometry_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  cmap->compute_midpoint_geometry = compute_midpoint_geometry_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  return cmap;
}

// End of code for coordinate mapping ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main

// Code for integral vectorlaplacegradcurl_cell_integral_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6_otherwise


void tabulate_tensor_vectorlaplacegradcurl_cell_integral_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6_otherwise(fenics_scalar_t* restrict A, const fenics_scalar_t* w,
                                    const fenics_scalar_t* c,
                                    const double* restrict coordinate_dofs,
                                    const int* unused_local_index,
                                    const int* cell_orientation)
{
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const fenics_scalar_t FE42_C0_D001_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c4 = coordinate_dofs[1] * FE42_C0_D001_Q4[0][0][0] + coordinate_dofs[7] * FE42_C0_D001_Q4[0][0][1];
    const double J_c8 = coordinate_dofs[2] * FE42_C0_D001_Q4[0][0][0] + coordinate_dofs[11] * FE42_C0_D001_Q4[0][0][1];
    const double J_c5 = coordinate_dofs[1] * FE42_C0_D001_Q4[0][0][0] + coordinate_dofs[10] * FE42_C0_D001_Q4[0][0][1];
    const double J_c7 = coordinate_dofs[2] * FE42_C0_D001_Q4[0][0][0] + coordinate_dofs[8] * FE42_C0_D001_Q4[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE42_C0_D001_Q4[0][0][0] + coordinate_dofs[3] * FE42_C0_D001_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE42_C0_D001_Q4[0][0][0] + coordinate_dofs[6] * FE42_C0_D001_Q4[0][0][1];
    const double J_c6 = coordinate_dofs[2] * FE42_C0_D001_Q4[0][0][0] + coordinate_dofs[5] * FE42_C0_D001_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE42_C0_D001_Q4[0][0][0] + coordinate_dofs[4] * FE42_C0_D001_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[0] * FE42_C0_D001_Q4[0][0][0] + coordinate_dofs[9] * FE42_C0_D001_Q4[0][0][1];
    alignas(32) fenics_scalar_t sp[248];
    sp[0] = J_c4 * J_c8;
    sp[1] = J_c5 * J_c7;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 * sp[2];
    sp[4] = J_c5 * J_c6;
    sp[5] = J_c3 * J_c8;
    sp[6] = sp[4] + -1 * sp[5];
    sp[7] = J_c1 * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = J_c3 * J_c7;
    sp[10] = J_c4 * J_c6;
    sp[11] = sp[9] + -1 * sp[10];
    sp[12] = J_c2 * sp[11];
    sp[13] = sp[8] + sp[12];
    sp[14] = sp[2] / sp[13];
    sp[15] = J_c3 * (-1 * J_c8);
    sp[16] = sp[4] + sp[15];
    sp[17] = sp[16] / sp[13];
    sp[18] = sp[11] / sp[13];
    sp[19] = sp[14] * sp[14];
    sp[20] = sp[14] * sp[17];
    sp[21] = sp[18] * sp[14];
    sp[22] = sp[17] * sp[17];
    sp[23] = sp[18] * sp[17];
    sp[24] = sp[18] * sp[18];
    sp[25] = J_c2 * J_c7;
    sp[26] = J_c8 * (-1 * J_c1);
    sp[27] = sp[25] + sp[26];
    sp[28] = sp[27] / sp[13];
    sp[29] = J_c0 * J_c8;
    sp[30] = J_c6 * (-1 * J_c2);
    sp[31] = sp[29] + sp[30];
    sp[32] = sp[31] / sp[13];
    sp[33] = J_c1 * J_c6;
    sp[34] = J_c0 * J_c7;
    sp[35] = sp[33] + -1 * sp[34];
    sp[36] = sp[35] / sp[13];
    sp[37] = sp[28] * sp[28];
    sp[38] = sp[28] * sp[32];
    sp[39] = sp[28] * sp[36];
    sp[40] = sp[32] * sp[32];
    sp[41] = sp[32] * sp[36];
    sp[42] = sp[36] * sp[36];
    sp[43] = sp[37] + sp[19];
    sp[44] = sp[38] + sp[20];
    sp[45] = sp[39] + sp[21];
    sp[46] = sp[40] + sp[22];
    sp[47] = sp[41] + sp[23];
    sp[48] = sp[24] + sp[42];
    sp[49] = J_c1 * J_c5;
    sp[50] = J_c2 * J_c4;
    sp[51] = sp[49] + -1 * sp[50];
    sp[52] = sp[51] / sp[13];
    sp[53] = J_c2 * J_c3;
    sp[54] = J_c0 * J_c5;
    sp[55] = sp[53] + -1 * sp[54];
    sp[56] = sp[55] / sp[13];
    sp[57] = J_c0 * J_c4;
    sp[58] = J_c1 * J_c3;
    sp[59] = sp[57] + -1 * sp[58];
    sp[60] = sp[59] / sp[13];
    sp[61] = sp[52] * sp[52];
    sp[62] = sp[52] * sp[56];
    sp[63] = sp[60] * sp[52];
    sp[64] = sp[56] * sp[56];
    sp[65] = sp[60] * sp[56];
    sp[66] = sp[60] * sp[60];
    sp[67] = sp[43] + sp[61];
    sp[68] = sp[44] + sp[62];
    sp[69] = sp[45] + sp[63];
    sp[70] = sp[46] + sp[64];
    sp[71] = sp[47] + sp[65];
    sp[72] = sp[48] + sp[66];
    sp[73] = sp[60] * sp[14];
    sp[74] = sp[56] * sp[14];
    sp[75] = sp[60] * sp[17];
    sp[76] = sp[52] * sp[17];
    sp[77] = sp[52] * sp[18];
    sp[78] = sp[56] * sp[18];
    sp[79] = -1 * sp[77] + sp[73];
    sp[80] = -1 * sp[76] + sp[74];
    sp[81] = -1 * sp[78] + sp[75];
    sp[82] = -1 * sp[74] + sp[76];
    sp[83] = -1 * sp[73] + sp[77];
    sp[84] = -1 * sp[75] + sp[78];
    sp[85] = sp[79] * sp[79];
    sp[86] = sp[79] * sp[80];
    sp[87] = sp[79] * sp[81];
    sp[88] = sp[79] * sp[82];
    sp[89] = sp[83] * sp[79];
    sp[90] = sp[84] * sp[79];
    sp[91] = sp[80] * sp[80];
    sp[92] = sp[80] * sp[81];
    sp[93] = sp[80] * sp[82];
    sp[94] = sp[83] * sp[80];
    sp[95] = sp[84] * sp[80];
    sp[96] = sp[81] * sp[81];
    sp[97] = sp[81] * sp[82];
    sp[98] = sp[83] * sp[81];
    sp[99] = sp[84] * sp[81];
    sp[100] = sp[82] * sp[82];
    sp[101] = sp[83] * sp[82];
    sp[102] = sp[84] * sp[82];
    sp[103] = sp[83] * sp[83];
    sp[104] = sp[83] * sp[84];
    sp[105] = sp[84] * sp[84];
    sp[106] = sp[52] * sp[36];
    sp[107] = sp[32] * sp[52];
    sp[108] = sp[56] * sp[36];
    sp[109] = sp[28] * sp[56];
    sp[110] = sp[28] * sp[60];
    sp[111] = sp[32] * sp[60];
    sp[112] = -1 * sp[110] + sp[106];
    sp[113] = -1 * sp[109] + sp[107];
    sp[114] = -1 * sp[111] + sp[108];
    sp[115] = -1 * sp[107] + sp[109];
    sp[116] = -1 * sp[106] + sp[110];
    sp[117] = -1 * sp[108] + sp[111];
    sp[118] = sp[112] * sp[112];
    sp[119] = sp[113] * sp[112];
    sp[120] = sp[112] * sp[114];
    sp[121] = sp[115] * sp[112];
    sp[122] = sp[116] * sp[112];
    sp[123] = sp[117] * sp[112];
    sp[124] = sp[113] * sp[113];
    sp[125] = sp[113] * sp[114];
    sp[126] = sp[113] * sp[115];
    sp[127] = sp[116] * sp[113];
    sp[128] = sp[117] * sp[113];
    sp[129] = sp[114] * sp[114];
    sp[130] = sp[115] * sp[114];
    sp[131] = sp[116] * sp[114];
    sp[132] = sp[117] * sp[114];
    sp[133] = sp[115] * sp[115];
    sp[134] = sp[116] * sp[115];
    sp[135] = sp[117] * sp[115];
    sp[136] = sp[116] * sp[116];
    sp[137] = sp[116] * sp[117];
    sp[138] = sp[117] * sp[117];
    sp[139] = sp[118] + sp[85];
    sp[140] = sp[119] + sp[86];
    sp[141] = sp[120] + sp[87];
    sp[142] = sp[121] + sp[88];
    sp[143] = sp[122] + sp[89];
    sp[144] = sp[123] + sp[90];
    sp[145] = sp[124] + sp[91];
    sp[146] = sp[125] + sp[92];
    sp[147] = sp[126] + sp[93];
    sp[148] = sp[127] + sp[94];
    sp[149] = sp[128] + sp[95];
    sp[150] = sp[129] + sp[96];
    sp[151] = sp[130] + sp[97];
    sp[152] = sp[131] + sp[98];
    sp[153] = sp[132] + sp[99];
    sp[154] = sp[133] + sp[100];
    sp[155] = sp[134] + sp[101];
    sp[156] = sp[135] + sp[102];
    sp[157] = sp[136] + sp[103];
    sp[158] = sp[137] + sp[104];
    sp[159] = sp[138] + sp[105];
    sp[160] = sp[28] * sp[18];
    sp[161] = sp[28] * sp[17];
    sp[162] = sp[32] * sp[18];
    sp[163] = sp[32] * sp[14];
    sp[164] = sp[36] * sp[14];
    sp[165] = sp[36] * sp[17];
    sp[166] = -1 * sp[164] + sp[160];
    sp[167] = -1 * sp[163] + sp[161];
    sp[168] = -1 * sp[165] + sp[162];
    sp[169] = -1 * sp[161] + sp[163];
    sp[170] = -1 * sp[160] + sp[164];
    sp[171] = -1 * sp[162] + sp[165];
    sp[172] = sp[166] * sp[166];
    sp[173] = sp[166] * sp[167];
    sp[174] = sp[166] * sp[168];
    sp[175] = sp[166] * sp[169];
    sp[176] = sp[166] * sp[170];
    sp[177] = sp[166] * sp[171];
    sp[178] = sp[167] * sp[167];
    sp[179] = sp[168] * sp[167];
    sp[180] = sp[169] * sp[167];
    sp[181] = sp[170] * sp[167];
    sp[182] = sp[167] * sp[171];
    sp[183] = sp[168] * sp[168];
    sp[184] = sp[168] * sp[169];
    sp[185] = sp[168] * sp[170];
    sp[186] = sp[168] * sp[171];
    sp[187] = sp[169] * sp[169];
    sp[188] = sp[169] * sp[170];
    sp[189] = sp[169] * sp[171];
    sp[190] = sp[170] * sp[170];
    sp[191] = sp[170] * sp[171];
    sp[192] = sp[171] * sp[171];
    sp[193] = sp[139] + sp[172];
    sp[194] = sp[140] + sp[173];
    sp[195] = sp[141] + sp[174];
    sp[196] = sp[142] + sp[175];
    sp[197] = sp[143] + sp[176];
    sp[198] = sp[144] + sp[177];
    sp[199] = sp[145] + sp[178];
    sp[200] = sp[146] + sp[179];
    sp[201] = sp[147] + sp[180];
    sp[202] = sp[148] + sp[181];
    sp[203] = sp[149] + sp[182];
    sp[204] = sp[150] + sp[183];
    sp[205] = sp[151] + sp[184];
    sp[206] = sp[152] + sp[185];
    sp[207] = sp[153] + sp[186];
    sp[208] = sp[154] + sp[187];
    sp[209] = sp[155] + sp[188];
    sp[210] = sp[156] + sp[189];
    sp[211] = sp[157] + sp[190];
    sp[212] = sp[158] + sp[191];
    sp[213] = sp[159] + sp[192];
    sp[214] = fabs(sp[13]);
    sp[215] = -1 * sp[67] * sp[214];
    sp[216] = -1 * sp[68] * sp[214];
    sp[217] = -1 * sp[69] * sp[214];
    sp[218] = -1 * sp[70] * sp[214];
    sp[219] = -1 * sp[71] * sp[214];
    sp[220] = -1 * sp[72] * sp[214];
    sp[221] = sp[67] * sp[214];
    sp[222] = sp[68] * sp[214];
    sp[223] = sp[69] * sp[214];
    sp[224] = sp[70] * sp[214];
    sp[225] = sp[71] * sp[214];
    sp[226] = sp[72] * sp[214];
    sp[227] = sp[193] * sp[214];
    sp[228] = sp[194] * sp[214];
    sp[229] = sp[195] * sp[214];
    sp[230] = sp[196] * sp[214];
    sp[231] = sp[197] * sp[214];
    sp[232] = sp[198] * sp[214];
    sp[233] = sp[199] * sp[214];
    sp[234] = sp[200] * sp[214];
    sp[235] = sp[201] * sp[214];
    sp[236] = sp[202] * sp[214];
    sp[237] = sp[203] * sp[214];
    sp[238] = sp[204] * sp[214];
    sp[239] = sp[205] * sp[214];
    sp[240] = sp[206] * sp[214];
    sp[241] = sp[207] * sp[214];
    sp[242] = sp[208] * sp[214];
    sp[243] = sp[209] * sp[214];
    sp[244] = sp[210] * sp[214];
    sp[245] = sp[211] * sp[214];
    sp[246] = sp[212] * sp[214];
    sp[247] = sp[213] * sp[214];
    // UFLACS block mode: preintegrated
    A[0] += 0.01666666666666656 * sp[214];
    A[1] += 0.008333333333333293 * sp[214];
    A[2] += 0.008333333333333299 * sp[214];
    A[3] += 0.008333333333333297 * sp[214];
    A[4] += -0.04166666666666672 * sp[217] + 0.04166666666666675 * sp[216] + -0.04166666666666672 * sp[219] + 0.04166666666666675 * sp[218] + -0.04166666666666672 * sp[220] + 0.04166666666666675 * sp[219];
    A[5] += -0.04166666666666671 * sp[217] + 0.04166666666666672 * sp[215] + -0.04166666666666671 * sp[219] + 0.04166666666666672 * sp[216] + -0.04166666666666671 * sp[220] + 0.04166666666666672 * sp[217];
    A[6] += -0.04166666666666677 * sp[216] + 0.0416666666666667 * sp[215] + -0.04166666666666677 * sp[218] + 0.0416666666666667 * sp[216] + -0.04166666666666677 * sp[219] + 0.0416666666666667 * sp[217];
    A[7] += -0.08333333333333318 * sp[217] + -0.04166666666666674 * sp[216] + -0.04166666666666671 * sp[215] + -0.08333333333333318 * sp[219] + -0.04166666666666674 * sp[218] + -0.04166666666666671 * sp[216] + -0.08333333333333318 * sp[220] + -0.04166666666666674 * sp[219] + -0.04166666666666671 * sp[217];
    A[8] += -0.04166666666666672 * sp[217] + -0.08333333333333312 * sp[216] + -0.04166666666666671 * sp[215] + -0.04166666666666672 * sp[219] + -0.08333333333333312 * sp[218] + -0.04166666666666671 * sp[216] + -0.04166666666666672 * sp[220] + -0.08333333333333312 * sp[219] + -0.04166666666666671 * sp[217];
    A[9] += -0.04166666666666674 * sp[217] + -0.04166666666666677 * sp[216] + -0.08333333333333323 * sp[215] + -0.04166666666666674 * sp[219] + -0.04166666666666677 * sp[218] + -0.08333333333333323 * sp[216] + -0.04166666666666674 * sp[220] + -0.04166666666666677 * sp[219] + -0.08333333333333323 * sp[217];
    A[10] += 0.008333333333333293 * sp[214];
    A[11] += 0.0166666666666667 * sp[214];
    A[12] += 0.008333333333333373 * sp[214];
    A[13] += 0.008333333333333371 * sp[214];
    A[14] += 0.04166666666666672 * sp[217] + -0.04166666666666675 * sp[216];
    A[15] += 0.04166666666666671 * sp[217] + -0.04166666666666672 * sp[215];
    A[16] += 0.04166666666666677 * sp[216] + -0.0416666666666667 * sp[215];
    A[17] += 0.08333333333333318 * sp[217] + 0.04166666666666674 * sp[216] + 0.04166666666666671 * sp[215];
    A[18] += 0.04166666666666672 * sp[217] + 0.08333333333333312 * sp[216] + 0.04166666666666671 * sp[215];
    A[19] += 0.04166666666666674 * sp[217] + 0.04166666666666677 * sp[216] + 0.08333333333333323 * sp[215];
    A[20] += 0.008333333333333299 * sp[214];
    A[21] += 0.008333333333333373 * sp[214];
    A[22] += 0.01666666666666671 * sp[214];
    A[23] += 0.008333333333333373 * sp[214];
    A[24] += 0.04166666666666672 * sp[219] + -0.04166666666666675 * sp[218];
    A[25] += 0.04166666666666671 * sp[219] + -0.04166666666666672 * sp[216];
    A[26] += 0.04166666666666677 * sp[218] + -0.0416666666666667 * sp[216];
    A[27] += 0.08333333333333318 * sp[219] + 0.04166666666666674 * sp[218] + 0.04166666666666671 * sp[216];
    A[28] += 0.04166666666666672 * sp[219] + 0.08333333333333312 * sp[218] + 0.04166666666666671 * sp[216];
    A[29] += 0.04166666666666674 * sp[219] + 0.04166666666666677 * sp[218] + 0.08333333333333323 * sp[216];
    A[30] += 0.008333333333333297 * sp[214];
    A[31] += 0.008333333333333371 * sp[214];
    A[32] += 0.008333333333333373 * sp[214];
    A[33] += 0.01666666666666671 * sp[214];
    A[34] += 0.04166666666666672 * sp[220] + -0.04166666666666675 * sp[219];
    A[35] += 0.04166666666666671 * sp[220] + -0.04166666666666672 * sp[217];
    A[36] += 0.04166666666666677 * sp[219] + -0.0416666666666667 * sp[217];
    A[37] += 0.08333333333333318 * sp[220] + 0.04166666666666674 * sp[219] + 0.04166666666666671 * sp[217];
    A[38] += 0.04166666666666672 * sp[220] + 0.08333333333333312 * sp[219] + 0.04166666666666671 * sp[217];
    A[39] += 0.04166666666666674 * sp[220] + 0.04166666666666677 * sp[219] + 0.08333333333333323 * sp[217];
    A[40] += -0.04166666666666672 * sp[223] + -0.04166666666666672 * sp[225] + -0.04166666666666672 * sp[226] + 0.04166666666666675 * sp[222] + 0.04166666666666675 * sp[224] + 0.04166666666666675 * sp[225];
    A[41] += 0.04166666666666672 * sp[223] + -0.04166666666666675 * sp[222];
    A[42] += 0.04166666666666672 * sp[225] + -0.04166666666666675 * sp[224];
    A[43] += 0.04166666666666672 * sp[226] + -0.04166666666666675 * sp[225];
    A[44] += 0.1666666666666667 * sp[238] + -0.1666666666666667 * sp[241] + -0.1666666666666667 * sp[241] + 0.1666666666666667 * sp[247];
    A[45] += 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[240] + -0.1666666666666667 * sp[232] + 0.1666666666666667 * sp[246];
    A[46] += 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[239] + -0.1666666666666667 * sp[237] + 0.1666666666666667 * sp[244];
    A[47] += -0.1666666666666667 * sp[238] + 0.1666666666666667 * sp[241] + 0.1666666666666667 * sp[241] + -0.1666666666666667 * sp[247] + -0.1666666666666667 * sp[229] + 0.1666666666666667 * sp[240] + 0.1666666666666667 * sp[232] + -0.1666666666666667 * sp[246];
    A[48] += 0.1666666666666667 * sp[238] + -0.1666666666666667 * sp[241] + -0.1666666666666667 * sp[241] + 0.1666666666666667 * sp[247] + -0.1666666666666667 * sp[234] + 0.1666666666666667 * sp[239] + 0.1666666666666667 * sp[237] + -0.1666666666666667 * sp[244];
    A[49] += 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[240] + -0.1666666666666667 * sp[232] + 0.1666666666666667 * sp[246] + 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[239] + -0.1666666666666667 * sp[237] + 0.1666666666666667 * sp[244];
    A[50] += -0.04166666666666671 * sp[223] + -0.04166666666666671 * sp[225] + -0.04166666666666671 * sp[226] + 0.04166666666666672 * sp[221] + 0.04166666666666672 * sp[222] + 0.04166666666666672 * sp[223];
    A[51] += 0.04166666666666671 * sp[223] + -0.04166666666666672 * sp[221];
    A[52] += 0.04166666666666671 * sp[225] + -0.04166666666666672 * sp[222];
    A[53] += 0.04166666666666671 * sp[226] + -0.04166666666666672 * sp[223];
    A[54] += 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[232] + -0.1666666666666667 * sp[240] + 0.1666666666666667 * sp[246];
    A[55] += 0.1666666666666667 * sp[227] + -0.1666666666666667 * sp[231] + -0.1666666666666667 * sp[231] + 0.1666666666666667 * sp[245];
    A[56] += 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[230] + -0.1666666666666667 * sp[236] + 0.1666666666666667 * sp[243];
    A[57] += -0.1666666666666667 * sp[229] + 0.1666666666666667 * sp[232] + 0.1666666666666667 * sp[240] + -0.1666666666666667 * sp[246] + -0.1666666666666667 * sp[227] + 0.1666666666666667 * sp[231] + 0.1666666666666667 * sp[231] + -0.1666666666666667 * sp[245];
    A[58] += 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[232] + -0.1666666666666667 * sp[240] + 0.1666666666666667 * sp[246] + -0.1666666666666667 * sp[228] + 0.1666666666666667 * sp[230] + 0.1666666666666667 * sp[236] + -0.1666666666666667 * sp[243];
    A[59] += 0.1666666666666667 * sp[227] + -0.1666666666666667 * sp[231] + -0.1666666666666667 * sp[231] + 0.1666666666666667 * sp[245] + 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[230] + -0.1666666666666667 * sp[236] + 0.1666666666666667 * sp[243];
    A[60] += -0.04166666666666677 * sp[222] + -0.04166666666666677 * sp[224] + -0.04166666666666677 * sp[225] + 0.0416666666666667 * sp[221] + 0.0416666666666667 * sp[222] + 0.0416666666666667 * sp[223];
    A[61] += 0.04166666666666677 * sp[222] + -0.0416666666666667 * sp[221];
    A[62] += 0.04166666666666677 * sp[224] + -0.0416666666666667 * sp[222];
    A[63] += 0.04166666666666677 * sp[225] + -0.0416666666666667 * sp[223];
    A[64] += 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[237] + -0.1666666666666667 * sp[239] + 0.1666666666666667 * sp[244];
    A[65] += 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[236] + -0.1666666666666667 * sp[230] + 0.1666666666666667 * sp[243];
    A[66] += 0.1666666666666667 * sp[233] + -0.1666666666666667 * sp[235] + -0.1666666666666667 * sp[235] + 0.1666666666666667 * sp[242];
    A[67] += -0.1666666666666667 * sp[234] + 0.1666666666666667 * sp[237] + 0.1666666666666667 * sp[239] + -0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[228] + 0.1666666666666667 * sp[236] + 0.1666666666666667 * sp[230] + -0.1666666666666667 * sp[243];
    A[68] += 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[237] + -0.1666666666666667 * sp[239] + 0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[233] + 0.1666666666666667 * sp[235] + 0.1666666666666667 * sp[235] + -0.1666666666666667 * sp[242];
    A[69] += 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[236] + -0.1666666666666667 * sp[230] + 0.1666666666666667 * sp[243] + 0.1666666666666667 * sp[233] + -0.1666666666666667 * sp[235] + -0.1666666666666667 * sp[235] + 0.1666666666666667 * sp[242];
    A[70] += -0.08333333333333318 * sp[223] + -0.08333333333333318 * sp[225] + -0.08333333333333318 * sp[226] + -0.04166666666666674 * sp[222] + -0.04166666666666674 * sp[224] + -0.04166666666666674 * sp[225] + -0.04166666666666671 * sp[221] + -0.04166666666666671 * sp[222] + -0.04166666666666671 * sp[223];
    A[71] += 0.08333333333333318 * sp[223] + 0.04166666666666674 * sp[222] + 0.04166666666666671 * sp[221];
    A[72] += 0.08333333333333318 * sp[225] + 0.04166666666666674 * sp[224] + 0.04166666666666671 * sp[222];
    A[73] += 0.08333333333333318 * sp[226] + 0.04166666666666674 * sp[225] + 0.04166666666666671 * sp[223];
    A[74] += -0.1666666666666667 * sp[238] + 0.1666666666666667 * sp[241] + 0.1666666666666667 * sp[241] + -0.1666666666666667 * sp[247] + -0.1666666666666667 * sp[229] + 0.1666666666666667 * sp[232] + 0.1666666666666667 * sp[240] + -0.1666666666666667 * sp[246];
    A[75] += -0.1666666666666667 * sp[229] + 0.1666666666666667 * sp[240] + 0.1666666666666667 * sp[232] + -0.1666666666666667 * sp[246] + -0.1666666666666667 * sp[227] + 0.1666666666666667 * sp[231] + 0.1666666666666667 * sp[231] + -0.1666666666666667 * sp[245];
    A[76] += -0.1666666666666667 * sp[234] + 0.1666666666666667 * sp[239] + 0.1666666666666667 * sp[237] + -0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[228] + 0.1666666666666667 * sp[230] + 0.1666666666666667 * sp[236] + -0.1666666666666667 * sp[243];
    A[77] += 0.1666666666666667 * sp[238] + -0.1666666666666667 * sp[241] + -0.1666666666666667 * sp[241] + 0.1666666666666667 * sp[247] + 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[240] + -0.1666666666666667 * sp[232] + 0.1666666666666667 * sp[246] + 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[232] + -0.1666666666666667 * sp[240] + 0.1666666666666667 * sp[246] + 0.1666666666666667 * sp[227] + -0.1666666666666667 * sp[231] + -0.1666666666666667 * sp[231] + 0.1666666666666667 * sp[245];
    A[78] += -0.1666666666666667 * sp[238] + 0.1666666666666667 * sp[241] + 0.1666666666666667 * sp[241] + -0.1666666666666667 * sp[247] + 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[239] + -0.1666666666666667 * sp[237] + 0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[229] + 0.1666666666666667 * sp[232] + 0.1666666666666667 * sp[240] + -0.1666666666666667 * sp[246] + 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[230] + -0.1666666666666667 * sp[236] + 0.1666666666666667 * sp[243];
    A[79] += -0.1666666666666667 * sp[229] + 0.1666666666666667 * sp[240] + 0.1666666666666667 * sp[232] + -0.1666666666666667 * sp[246] + -0.1666666666666667 * sp[234] + 0.1666666666666667 * sp[239] + 0.1666666666666667 * sp[237] + -0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[227] + 0.1666666666666667 * sp[231] + 0.1666666666666667 * sp[231] + -0.1666666666666667 * sp[245] + -0.1666666666666667 * sp[228] + 0.1666666666666667 * sp[230] + 0.1666666666666667 * sp[236] + -0.1666666666666667 * sp[243];
    A[80] += -0.04166666666666672 * sp[223] + -0.04166666666666672 * sp[225] + -0.04166666666666672 * sp[226] + -0.08333333333333312 * sp[222] + -0.08333333333333312 * sp[224] + -0.08333333333333312 * sp[225] + -0.04166666666666671 * sp[221] + -0.04166666666666671 * sp[222] + -0.04166666666666671 * sp[223];
    A[81] += 0.04166666666666672 * sp[223] + 0.08333333333333312 * sp[222] + 0.04166666666666671 * sp[221];
    A[82] += 0.04166666666666672 * sp[225] + 0.08333333333333312 * sp[224] + 0.04166666666666671 * sp[222];
    A[83] += 0.04166666666666672 * sp[226] + 0.08333333333333312 * sp[225] + 0.04166666666666671 * sp[223];
    A[84] += 0.1666666666666667 * sp[238] + -0.1666666666666667 * sp[241] + -0.1666666666666667 * sp[241] + 0.1666666666666667 * sp[247] + -0.1666666666666667 * sp[234] + 0.1666666666666667 * sp[237] + 0.1666666666666667 * sp[239] + -0.1666666666666667 * sp[244];
    A[85] += 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[240] + -0.1666666666666667 * sp[232] + 0.1666666666666667 * sp[246] + -0.1666666666666667 * sp[228] + 0.1666666666666667 * sp[236] + 0.1666666666666667 * sp[230] + -0.1666666666666667 * sp[243];
    A[86] += 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[239] + -0.1666666666666667 * sp[237] + 0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[233] + 0.1666666666666667 * sp[235] + 0.1666666666666667 * sp[235] + -0.1666666666666667 * sp[242];
    A[87] += -0.1666666666666667 * sp[238] + 0.1666666666666667 * sp[241] + 0.1666666666666667 * sp[241] + -0.1666666666666667 * sp[247] + -0.1666666666666667 * sp[229] + 0.1666666666666667 * sp[240] + 0.1666666666666667 * sp[232] + -0.1666666666666667 * sp[246] + 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[237] + -0.1666666666666667 * sp[239] + 0.1666666666666667 * sp[244] + 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[236] + -0.1666666666666667 * sp[230] + 0.1666666666666667 * sp[243];
    A[88] += 0.1666666666666667 * sp[238] + -0.1666666666666667 * sp[241] + -0.1666666666666667 * sp[241] + 0.1666666666666667 * sp[247] + -0.1666666666666667 * sp[234] + 0.1666666666666667 * sp[239] + 0.1666666666666667 * sp[237] + -0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[234] + 0.1666666666666667 * sp[237] + 0.1666666666666667 * sp[239] + -0.1666666666666667 * sp[244] + 0.1666666666666667 * sp[233] + -0.1666666666666667 * sp[235] + -0.1666666666666667 * sp[235] + 0.1666666666666667 * sp[242];
    A[89] += 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[240] + -0.1666666666666667 * sp[232] + 0.1666666666666667 * sp[246] + 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[239] + -0.1666666666666667 * sp[237] + 0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[228] + 0.1666666666666667 * sp[236] + 0.1666666666666667 * sp[230] + -0.1666666666666667 * sp[243] + -0.1666666666666667 * sp[233] + 0.1666666666666667 * sp[235] + 0.1666666666666667 * sp[235] + -0.1666666666666667 * sp[242];
    A[90] += -0.04166666666666674 * sp[223] + -0.04166666666666674 * sp[225] + -0.04166666666666674 * sp[226] + -0.04166666666666677 * sp[222] + -0.04166666666666677 * sp[224] + -0.04166666666666677 * sp[225] + -0.08333333333333323 * sp[221] + -0.08333333333333323 * sp[222] + -0.08333333333333323 * sp[223];
    A[91] += 0.04166666666666674 * sp[223] + 0.04166666666666677 * sp[222] + 0.08333333333333323 * sp[221];
    A[92] += 0.04166666666666674 * sp[225] + 0.04166666666666677 * sp[224] + 0.08333333333333323 * sp[222];
    A[93] += 0.04166666666666674 * sp[226] + 0.04166666666666677 * sp[225] + 0.08333333333333323 * sp[223];
    A[94] += 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[232] + -0.1666666666666667 * sp[240] + 0.1666666666666667 * sp[246] + 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[237] + -0.1666666666666667 * sp[239] + 0.1666666666666667 * sp[244];
    A[95] += 0.1666666666666667 * sp[227] + -0.1666666666666667 * sp[231] + -0.1666666666666667 * sp[231] + 0.1666666666666667 * sp[245] + 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[236] + -0.1666666666666667 * sp[230] + 0.1666666666666667 * sp[243];
    A[96] += 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[230] + -0.1666666666666667 * sp[236] + 0.1666666666666667 * sp[243] + 0.1666666666666667 * sp[233] + -0.1666666666666667 * sp[235] + -0.1666666666666667 * sp[235] + 0.1666666666666667 * sp[242];
    A[97] += -0.1666666666666667 * sp[229] + 0.1666666666666667 * sp[232] + 0.1666666666666667 * sp[240] + -0.1666666666666667 * sp[246] + -0.1666666666666667 * sp[227] + 0.1666666666666667 * sp[231] + 0.1666666666666667 * sp[231] + -0.1666666666666667 * sp[245] + -0.1666666666666667 * sp[234] + 0.1666666666666667 * sp[237] + 0.1666666666666667 * sp[239] + -0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[228] + 0.1666666666666667 * sp[236] + 0.1666666666666667 * sp[230] + -0.1666666666666667 * sp[243];
    A[98] += 0.1666666666666667 * sp[229] + -0.1666666666666667 * sp[232] + -0.1666666666666667 * sp[240] + 0.1666666666666667 * sp[246] + -0.1666666666666667 * sp[228] + 0.1666666666666667 * sp[230] + 0.1666666666666667 * sp[236] + -0.1666666666666667 * sp[243] + 0.1666666666666667 * sp[234] + -0.1666666666666667 * sp[237] + -0.1666666666666667 * sp[239] + 0.1666666666666667 * sp[244] + -0.1666666666666667 * sp[233] + 0.1666666666666667 * sp[235] + 0.1666666666666667 * sp[235] + -0.1666666666666667 * sp[242];
    A[99] += 0.1666666666666667 * sp[227] + -0.1666666666666667 * sp[231] + -0.1666666666666667 * sp[231] + 0.1666666666666667 * sp[245] + 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[230] + -0.1666666666666667 * sp[236] + 0.1666666666666667 * sp[243] + 0.1666666666666667 * sp[228] + -0.1666666666666667 * sp[236] + -0.1666666666666667 * sp[230] + 0.1666666666666667 * sp[243] + 0.1666666666666667 * sp[233] + -0.1666666666666667 * sp[235] + -0.1666666666666667 * sp[235] + 0.1666666666666667 * sp[242];
}


fenics_integral* create_vectorlaplacegradcurl_cell_integral_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6_otherwise(void)
{
  static const bool enabled[] = {};

  fenics_integral* integral = malloc(sizeof(*integral));
  integral->enabled_coefficients = enabled;
  integral->tabulate_tensor = tabulate_tensor_vectorlaplacegradcurl_cell_integral_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6_otherwise;
  return integral;
};

// End of code for integral vectorlaplacegradcurl_cell_integral_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6_otherwise

// Code for integral vectorlaplacegradcurl_cell_integral_8be93e911f7d55be3deda9d5fe504d135698d4f2_otherwise


void tabulate_tensor_vectorlaplacegradcurl_cell_integral_8be93e911f7d55be3deda9d5fe504d135698d4f2_otherwise(fenics_scalar_t* restrict A, const fenics_scalar_t* w,
                                    const fenics_scalar_t* c,
                                    const double* restrict coordinate_dofs,
                                    const int* unused_local_index,
                                    const int* cell_orientation)
{
    // Quadrature rules
    alignas(32) static const fenics_scalar_t weights5[5] = { -0.1333333333333333, 0.075, 0.075, 0.075, 0.075 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const fenics_scalar_t FE13_C0_D001_Q5[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const fenics_scalar_t FE17_C1_Q5[1][5][5] =
        { { { -0.2499999999999999, -0.2499999999999997, 0.2499999999999998, 0.2499999999999998, 0.5 },
            { -0.1666666666666666, -0.1666666666666665, 0.1666666666666666, 0.1666666666666666, 0.6666666666666665 },
            { -0.1666666666666665, -0.5, 0.1666666666666665, 0.5, 0.3333333333333338 },
            { -0.5, -0.1666666666666664, 0.5, 0.1666666666666665, 0.3333333333333337 },
            { -0.1666666666666665, -0.1666666666666664, 0.1666666666666665, 0.1666666666666665, 0.6666666666666669 } } };
    alignas(32) static const fenics_scalar_t FE17_C2_Q5[1][5][5] =
        { { { -0.2500000000000001, 0.2500000000000002, 0.25, 0.5, 0.2500000000000002 },
            { -0.1666666666666667, 0.5, 0.1666666666666667, 0.3333333333333329, 0.5 },
            { -0.1666666666666667, 0.1666666666666669, 0.1666666666666666, 0.6666666666666664, 0.1666666666666668 },
            { -0.5, 0.1666666666666667, 0.5, 0.333333333333333, 0.1666666666666668 },
            { -0.1666666666666667, 0.1666666666666666, 0.1666666666666666, 0.6666666666666666, 0.1666666666666665 } } };
    alignas(32) static const fenics_scalar_t FE17_C3_Q5[1][5][5] =
        { { { 0.2499999999999998, 0.2499999999999998, 0.5, 0.2499999999999998, 0.25 },
            { 0.1666666666666665, 0.5, 0.3333333333333334, 0.1666666666666666, 0.5 },
            { 0.5, 0.1666666666666664, 0.3333333333333335, 0.5, 0.1666666666666667 },
            { 0.1666666666666666, 0.1666666666666666, 0.6666666666666665, 0.1666666666666666, 0.1666666666666666 },
            { 0.1666666666666664, 0.1666666666666663, 0.6666666666666669, 0.1666666666666665, 0.1666666666666664 } } };
    alignas(32) static const fenics_scalar_t FE3_C0_Q5[1][5][10] =
        { { { -0.1249999999999998, -0.1249999999999999, -0.1249999999999999, -0.125, 0.25, 0.2500000000000001, 0.25, 0.2499999999999999, 0.25, 0.25 },
            { -0.111111111111111, 0.0, -0.111111111111111, -0.111111111111111, 0.111111111111111, 0.3333333333333333, 0.3333333333333333, 0.111111111111111, 0.1111111111111111, 0.3333333333333334 },
            { -0.111111111111111, -0.111111111111111, 0.0, -0.1111111111111111, 0.3333333333333333, 0.1111111111111111, 0.3333333333333333, 0.111111111111111, 0.3333333333333334, 0.1111111111111111 },
            { -0.111111111111111, -0.111111111111111, -0.111111111111111, 0.0, 0.3333333333333333, 0.3333333333333334, 0.1111111111111111, 0.3333333333333333, 0.1111111111111112, 0.1111111111111111 },
            { 0.0, -0.111111111111111, -0.111111111111111, -0.1111111111111111, 0.111111111111111, 0.1111111111111111, 0.1111111111111111, 0.3333333333333332, 0.3333333333333334, 0.3333333333333332 } } };
    // Unstructured piecewise computations
    const double J_c4 = coordinate_dofs[1] * FE13_C0_D001_Q5[0][0][0] + coordinate_dofs[7] * FE13_C0_D001_Q5[0][0][1];
    const double J_c8 = coordinate_dofs[2] * FE13_C0_D001_Q5[0][0][0] + coordinate_dofs[11] * FE13_C0_D001_Q5[0][0][1];
    const double J_c5 = coordinate_dofs[1] * FE13_C0_D001_Q5[0][0][0] + coordinate_dofs[10] * FE13_C0_D001_Q5[0][0][1];
    const double J_c7 = coordinate_dofs[2] * FE13_C0_D001_Q5[0][0][0] + coordinate_dofs[8] * FE13_C0_D001_Q5[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE13_C0_D001_Q5[0][0][0] + coordinate_dofs[3] * FE13_C0_D001_Q5[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE13_C0_D001_Q5[0][0][0] + coordinate_dofs[6] * FE13_C0_D001_Q5[0][0][1];
    const double J_c6 = coordinate_dofs[2] * FE13_C0_D001_Q5[0][0][0] + coordinate_dofs[5] * FE13_C0_D001_Q5[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE13_C0_D001_Q5[0][0][0] + coordinate_dofs[4] * FE13_C0_D001_Q5[0][0][1];
    const double J_c2 = coordinate_dofs[0] * FE13_C0_D001_Q5[0][0][0] + coordinate_dofs[9] * FE13_C0_D001_Q5[0][0][1];
    alignas(32) fenics_scalar_t sp[44];
    sp[0] = J_c4 * J_c8;
    sp[1] = J_c5 * J_c7;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 * sp[2];
    sp[4] = J_c5 * J_c6;
    sp[5] = J_c3 * J_c8;
    sp[6] = sp[4] + -1 * sp[5];
    sp[7] = J_c1 * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = J_c3 * J_c7;
    sp[10] = J_c4 * J_c6;
    sp[11] = sp[9] + -1 * sp[10];
    sp[12] = J_c2 * sp[11];
    sp[13] = sp[8] + sp[12];
    sp[14] = sp[2] / sp[13];
    sp[15] = J_c3 * (-1 * J_c8);
    sp[16] = sp[4] + sp[15];
    sp[17] = sp[16] / sp[13];
    sp[18] = sp[11] / sp[13];
    sp[19] = J_c2 * J_c7;
    sp[20] = J_c8 * (-1 * J_c1);
    sp[21] = sp[19] + sp[20];
    sp[22] = sp[21] / sp[13];
    sp[23] = J_c0 * J_c8;
    sp[24] = J_c6 * (-1 * J_c2);
    sp[25] = sp[23] + sp[24];
    sp[26] = sp[25] / sp[13];
    sp[27] = J_c1 * J_c6;
    sp[28] = J_c0 * J_c7;
    sp[29] = sp[27] + -1 * sp[28];
    sp[30] = sp[29] / sp[13];
    sp[31] = J_c1 * J_c5;
    sp[32] = J_c2 * J_c4;
    sp[33] = sp[31] + -1 * sp[32];
    sp[34] = sp[33] / sp[13];
    sp[35] = J_c2 * J_c3;
    sp[36] = J_c0 * J_c5;
    sp[37] = sp[35] + -1 * sp[36];
    sp[38] = sp[37] / sp[13];
    sp[39] = J_c0 * J_c4;
    sp[40] = J_c1 * J_c3;
    sp[41] = sp[39] + -1 * sp[40];
    sp[42] = sp[41] / sp[13];
    sp[43] = fabs(sp[13]);
    // UFLACS block mode: full
    alignas(32) fenics_scalar_t BF0[5] = { 0 };
    // UFLACS block mode: full
    alignas(32) fenics_scalar_t BF1[5] = { 0 };
    // UFLACS block mode: full
    alignas(32) fenics_scalar_t BF2[5] = { 0 };
    for (int iq = 0; iq < 5; ++iq)
    {
        // Quadrature loop body setup (num_points=5)
        // Unstructured varying computations for num_points=5
        fenics_scalar_t w0_c0 = 0.0;
        for (int ic = 0; ic < 10; ++ic)
            w0_c0 += w[ic] * FE3_C0_Q5[0][iq][ic];
        fenics_scalar_t w0_c1 = 0.0;
        for (int ic = 0; ic < 10; ++ic)
            w0_c1 += w[ic + 10] * FE3_C0_Q5[0][iq][ic];
        fenics_scalar_t w0_c2 = 0.0;
        for (int ic = 0; ic < 10; ++ic)
            w0_c2 += w[ic + 20] * FE3_C0_Q5[0][iq][ic];
        alignas(32) fenics_scalar_t sv5[18];
        sv5[0] = w0_c0 * sp[14];
        sv5[1] = w0_c0 * sp[17];
        sv5[2] = w0_c0 * sp[18];
        sv5[3] = w0_c1 * sp[22];
        sv5[4] = w0_c1 * sp[26];
        sv5[5] = w0_c1 * sp[30];
        sv5[6] = sv5[3] + sv5[0];
        sv5[7] = sv5[4] + sv5[1];
        sv5[8] = sv5[2] + sv5[5];
        sv5[9] = w0_c2 * sp[34];
        sv5[10] = w0_c2 * sp[38];
        sv5[11] = w0_c2 * sp[42];
        sv5[12] = sv5[6] + sv5[9];
        sv5[13] = sv5[7] + sv5[10];
        sv5[14] = sv5[8] + sv5[11];
        sv5[15] = sv5[12] * sp[43];
        sv5[16] = sv5[13] * sp[43];
        sv5[17] = sv5[14] * sp[43];
        // UFLACS block mode: full
        const fenics_scalar_t fw0 = sv5[17] * weights5[iq];
        for (int i = 0; i < 5; ++i)
            BF0[i] += fw0 * FE17_C3_Q5[0][iq][i];
        // UFLACS block mode: full
        const fenics_scalar_t fw1 = sv5[16] * weights5[iq];
        for (int i = 0; i < 5; ++i)
            BF1[i] += fw1 * FE17_C2_Q5[0][iq][i];
        // UFLACS block mode: full
        const fenics_scalar_t fw2 = sv5[15] * weights5[iq];
        for (int i = 0; i < 5; ++i)
            BF2[i] += fw2 * FE17_C1_Q5[0][iq][i];
    }
    static const int DM0[5] = { 4, 5, 7, 8, 9 };
    static const int DM1[5] = { 4, 6, 7, 8, 9 };
    for (int i = 0; i < 5; ++i)
        A[DM0[i]] += BF0[i];
    for (int i = 0; i < 5; ++i)
        A[DM1[i]] += BF1[i];
    for (int i = 0; i < 5; ++i)
        A[i + 5] += BF2[i];
}


fenics_integral* create_vectorlaplacegradcurl_cell_integral_8be93e911f7d55be3deda9d5fe504d135698d4f2_otherwise(void)
{
  static const bool enabled[1] = { true };

  fenics_integral* integral = malloc(sizeof(*integral));
  integral->enabled_coefficients = enabled;
  integral->tabulate_tensor = tabulate_tensor_vectorlaplacegradcurl_cell_integral_8be93e911f7d55be3deda9d5fe504d135698d4f2_otherwise;
  return integral;
};

// End of code for integral vectorlaplacegradcurl_cell_integral_8be93e911f7d55be3deda9d5fe504d135698d4f2_otherwise

// Code for form vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6

int original_coefficient_position_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int i)
{
// Invalid original coefficient index.
return -1;
}

// Return a list of the coefficient names.
const char** coefficient_name_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(void)
{
return NULL;
}

// Return a list of the constant names.
const char** constant_name_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(void)
{
return NULL;
}

fenics_finite_element* create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(void);

fenics_finite_element* create_coordinate_finite_element_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(void)
{
return create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main();
}

fenics_dofmap* create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main(void);

fenics_dofmap* create_coordinate_dofmap_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(void)
{
return create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main();
}

fenics_coordinate_mapping* create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(void);

fenics_coordinate_mapping* create_coordinate_mapping_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(void)
{
return create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main();
}

fenics_finite_element* create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(void);

fenics_finite_element* create_finite_element_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main();
case 1:
    return create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main(void);

fenics_dofmap* create_dofmap_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main();
case 1:
    return create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main();
default:
    return NULL;
}
}

fenics_integral* create_cell_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int subdomain_id)
{
  switch (subdomain_id)
{
case -1:
    return create_vectorlaplacegradcurl_cell_integral_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6_otherwise();
default:
    return NULL;
}
}

void get_cell_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int *ids)
{
  ids[0] = -1;
return;
}

fenics_integral* create_exterior_facet_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int subdomain_id)
{
  return NULL;
}

void get_exterior_facet_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int *ids)
{
  return;
}

fenics_integral* create_interior_facet_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int subdomain_id)
{
return NULL;
}

void get_interior_facet_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int *ids)
{
  return;
}

fenics_integral* create_vertex_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int subdomain_id)
{
return NULL;
}

void get_vertex_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int *ids)
{
  return;
}

fenics_custom_integral* create_custom_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int subdomain_id)
{
return NULL;
}

void get_custom_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(int *ids)
{
  return;
}

fenics_form* create_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6(void)
{
  fenics_form* form = malloc(sizeof(*form));

  form->signature = "5c5a87ad3d9a2b8e8d769724c23949ae5e46ef853949669d8f78abfd51b746413e9af67c1384388db46158ad31dd4ac7c7d71b3a786bb06fe111b8414b0c3639";
  form->rank = 2;
  form->num_coefficients = 0;
  form->num_constants = 0;
  form->original_coefficient_position = original_coefficient_position_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;

  form->coefficient_name_map = coefficient_name_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->constant_name_map = constant_name_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;

  form->create_coordinate_finite_element = create_coordinate_finite_element_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->create_coordinate_dofmap = create_coordinate_dofmap_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->create_coordinate_mapping = create_coordinate_mapping_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->create_finite_element = create_finite_element_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->create_dofmap = create_dofmap_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;

  form->get_cell_integral_ids = get_cell_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->get_exterior_facet_integral_ids = get_exterior_facet_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->get_interior_facet_integral_ids = get_interior_facet_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->get_vertex_integral_ids = get_vertex_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->get_custom_integral_ids = get_custom_integral_ids_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;

  form->num_cell_integrals = 1;
  form->num_exterior_facet_integrals = 0;
  form->num_interior_facet_integrals = 0;
  form->num_vertex_integrals = 0;
  form->num_custom_integrals = 0;

  form->create_cell_integral = create_cell_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->create_exterior_facet_integral = create_exterior_facet_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->create_interior_facet_integral = create_interior_facet_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->create_vertex_integral = create_vertex_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;
  form->create_custom_integral = create_custom_integral_vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6;

  return form;
};

// End of code for form vectorlaplacegradcurl_form_43661ed4ace3770ee12c74f1d0a7b3267bdbf8c6

// Code for form vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2

int original_coefficient_position_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int i)
{
if (i >= 1)
{
    // Invalid original coefficient index.
    return -1;
}
static const int64_t position[1] = { 0 };
return position[i];
}

// Return a list of the coefficient names.
const char** coefficient_name_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(void)
{
static const char* names[1] = { "w0" };
return names;
}

// Return a list of the constant names.
const char** constant_name_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(void)
{
return NULL;
}

fenics_finite_element* create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main(void);

fenics_finite_element* create_coordinate_finite_element_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(void)
{
return create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_finite_element_main();
}

fenics_dofmap* create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main(void);

fenics_dofmap* create_coordinate_dofmap_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(void)
{
return create_ffc_element_33e9a2dec3cd356f6d7d0c0aaa65e32a8b7e7f20_dofmap_main();
}

fenics_coordinate_mapping* create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main(void);

fenics_coordinate_mapping* create_coordinate_mapping_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(void)
{
return create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main();
}

fenics_finite_element* create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main(void);
fenics_finite_element* create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main(void);

fenics_finite_element* create_finite_element_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main();
case 1:
    return create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main();
default:
    return NULL;
}
}

fenics_dofmap* create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main(void);
fenics_dofmap* create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main(void);

fenics_dofmap* create_dofmap_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int i)
{
switch (i)
{
case 0:
    return create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main();
case 1:
    return create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main();
default:
    return NULL;
}
}

fenics_integral* create_cell_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int subdomain_id)
{
  switch (subdomain_id)
{
case -1:
    return create_vectorlaplacegradcurl_cell_integral_8be93e911f7d55be3deda9d5fe504d135698d4f2_otherwise();
default:
    return NULL;
}
}

void get_cell_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int *ids)
{
  ids[0] = -1;
return;
}

fenics_integral* create_exterior_facet_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int subdomain_id)
{
  return NULL;
}

void get_exterior_facet_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int *ids)
{
  return;
}

fenics_integral* create_interior_facet_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int subdomain_id)
{
return NULL;
}

void get_interior_facet_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int *ids)
{
  return;
}

fenics_integral* create_vertex_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int subdomain_id)
{
return NULL;
}

void get_vertex_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int *ids)
{
  return;
}

fenics_custom_integral* create_custom_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int subdomain_id)
{
return NULL;
}

void get_custom_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(int *ids)
{
  return;
}

fenics_form* create_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2(void)
{
  fenics_form* form = malloc(sizeof(*form));

  form->signature = "7aee017280295fffbe4c8e63aca287d86a77d87f9572ddd1c7031eddc4be4fff82f7de77fd66bd9f32da52eb31ae0c31068bf20a9f2688153eae6dea2a07ca4d";
  form->rank = 1;
  form->num_coefficients = 1;
  form->num_constants = 0;
  form->original_coefficient_position = original_coefficient_position_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;

  form->coefficient_name_map = coefficient_name_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->constant_name_map = constant_name_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;

  form->create_coordinate_finite_element = create_coordinate_finite_element_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->create_coordinate_dofmap = create_coordinate_dofmap_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->create_coordinate_mapping = create_coordinate_mapping_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->create_finite_element = create_finite_element_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->create_dofmap = create_dofmap_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;

  form->get_cell_integral_ids = get_cell_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->get_exterior_facet_integral_ids = get_exterior_facet_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->get_interior_facet_integral_ids = get_interior_facet_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->get_vertex_integral_ids = get_vertex_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->get_custom_integral_ids = get_custom_integral_ids_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;

  form->num_cell_integrals = 1;
  form->num_exterior_facet_integrals = 0;
  form->num_interior_facet_integrals = 0;
  form->num_vertex_integrals = 0;
  form->num_custom_integrals = 0;

  form->create_cell_integral = create_cell_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->create_exterior_facet_integral = create_exterior_facet_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->create_interior_facet_integral = create_interior_facet_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->create_vertex_integral = create_vertex_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;
  form->create_custom_integral = create_custom_integral_vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2;

  return form;
};

// End of code for form vectorlaplacegradcurl_form_8be93e911f7d55be3deda9d5fe504d135698d4f2

fenics_function_space* VectorLaplaceGradCurl_coefficientspace_w0_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_finite_element_main;
  space->create_dofmap = create_ffc_element_cec102c68e1aeff08ddd95ebe79ff66b7c806f33_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  return space;
}
fenics_function_space* VectorLaplaceGradCurl_form_a_functionspace_0_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  space->create_dofmap = create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  return space;
}

fenics_function_space* VectorLaplaceGradCurl_form_a_functionspace_1_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  space->create_dofmap = create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  return space;
}
fenics_function_space* VectorLaplaceGradCurl_form_L_functionspace_0_create(void)
{
  fenics_function_space* space = (fenics_function_space*) malloc(sizeof(*space));
  space->create_element = create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_finite_element_main;
  space->create_dofmap = create_ffc_element_65a8345789c58ddd630b7906307bbf7a38b6d1f7_dofmap_main;
  space->create_coordinate_mapping = create_ffc_coordinate_mapping_c1ca6cbb4a958561ea28731f4e91dcb590afbfd5_coordinate_mapping_main;
  return space;
}

