"DOLFIN output format."

__author__ = "Anders Logg (logg@tti-c.org)"
__date__ = "2004-10-14"
__copyright__ = "Copyright (c) 2004 Anders Logg"
__license__  = "GNU GPL Version 2"

format = { "coefficient": "w%d[%d]",
           "transform": "g%d%d",
           "determinant": "det",
           "geometry tensor": "G%d_%s",
           "geometry tensor simple": "G%d" }

def compile(form):
    "Generate code for DOLFIN."
    print "Compiling multi-linear form for C++ (DOLFIN)."
    
    # Choose name
    if form.rank == 1:
        type = "Linear"
    elif form.rank == 2:
        type = "Bilinear"
    else:
        print """DOLFIN can only handle linear or bilinear forms.
        I will try to generate the multi-linear form but you will not
        be able to use it with DOLFIN."""
        type = "Multilinear"

    # Get element
    element = (form.AKi.terms + form.AKb.terms)[0].A0.basisfunctions[0].element

    # Generate output
    output = ""
    output += __file_header(form, type)
    output += __element(form, element)
    output += __form(form, type)
    output += __file_footer()

    # Write file
    filename = form.name + ".h"
    file = open(filename, "w")
    file.write(output)
    file.close()

    # Write a nice message
    print "Output written on " + filename + "."
    
    return

def __file_header(form, type):
    "Generate file header for DOLFIN."
    return """\
// This file was automatically generated by FFC, the FEniCS Form Compiler.
// Licensed under the GNU GPL Version 2.

#ifndef __%s_%s_H
#define __%s_%s_H

#include <dolfin/NewFiniteElement.h>
#include <dolfin/%sForm.h>

using namespace dolfin;

""" % (__capall(form.name), __capall(type),
       __capall(form.name), __capall(type), type)

def __file_footer():
    "Generate file footer for DOLFIN."
    return "\n#endif\n"

def __element(form, element):
    "Generate finite element for DOLFIN."
    # Generate output
    return """\
/// This is the finite element for which the form is generated,
/// providing the information neccessary to do assembly.

class %sFiniteElement : public NewFiniteElement
{
public:

  %sFiniteElement() : NewFiniteElement() {}

  unsigned int spacedim() const
  {
    return %d;
  }

  unsigned int shapedim() const
  {
    return %d;
  }

  unsigned int vectordim() const
  {
    return %d;
  }

  // FIXME: Only works for nodal basis
  unsigned int dof(unsigned int i, const Cell& cell) const
  {
    return cell.nodeID(i);
  }

  // FIXME: Only works for nodal basis
  const Point& coord(unsigned int i, const Cell& cell) const
  {
    return cell.node(i).coord();
  }

};

""" % (form.name, form.name,
       element.spacedim, element.shapedim, element.vectordim)

def __form(form, type):
    "Generate form for DOLFIN."
    
    ptr = "".join(['*' for i in range(form.rank)])
    subclass = form.name + type + "Form"
    baseclass = type + "Form"
    
    # Class header
    output = """\
/// This class contains the form to be evaluated, including
/// contributions from the interior and boundary of the domain.

class %s : public %s
{
public:

  %s(const NewFiniteElement& element) : %s(element) {}
""" % (subclass, baseclass, subclass, baseclass)

    # Interior contribution (if any)
    if form.AKi.terms:
        output += """\

  bool interior(real%s A) const
  {
    // Compute geometry tensors
%s
    // Compute element tensor
%s
    return true;
  }
""" % (ptr,
       __geometry_tensor(form.AKi),
       __element_tensor(form.AKi, form.indices))

    # Boundary contribution (if any)
    if form.AKb.terms:
        output += """\

  bool boundary(real%s A) const
  {
    // Compute geometry tensors
%s
    // Compute element tensor
%s
    return true;
  }
""" % (ptr,
       __geometry_tensor(form.AKb),
       __element_tensor(form.AKb, form.indices))

    # Class footer
    output += """
};
"""

    return output

def __geometry_tensor(AK):
    "Generate expressions for computation of geometry tensors."
    output = ""
    for j in range(len(AK.terms)):
        GK = AK.terms[j].GK
        if GK.a.indices: aindices = GK.a.indices
        else: aindices = [[]]
        for a in aindices:
            name = GK.name(j, a, format)
            value = GK(a, format)
            output += "    %s = %s;\n" % (name, value)
    return output

def __element_tensor(AK, indices):
    "Generate expressions for computation of element tensor."
    output = ""
    for i in indices:
        name = "A[" + "][".join([str(index) for index in i]) + "]"
        value = AK(i)
        output += "    %s = %s;\n" % (name, value)
    return output

def __capall(s):
    "Return a string in which all characters are capitalized."
    return "".join([c.capitalize() for c in s])
