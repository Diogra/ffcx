"DOLFIN output format."

__author__ = "Anders Logg (logg@tti-c.org)"
__date__ = "2004-10-14"
__copyright__ = "Copyright (c) 2004 Anders Logg"
__license__  = "GNU GPL Version 2"

format = { "multiplication": "*",
           "determinant": "det",
           "floating point": lambda a: str(a),
           "coefficient": lambda j, k: "c[%d][%d]" % (j, k),
           "transform": lambda j, k: "g%d%d" % (j, k),
           "reference tensor" : lambda j, i, a: "not defined",
           "geometry tensor": lambda j, a: "G%d_%s" % (j, "".join(["%d" % index for index in a])),
           "element tensor": lambda i, k: "block[%d]" % k }

def compile(forms):
    "Generate code for DOLFIN."
    print "\nGenerating output for DOLFIN"

    # Get name of form
    name = forms[0].name

    # Write file header
    output = ""
    output += __file_header(name)

    # Write element
    # FIXME: Allow different elements, not just one element
    element = (forms[0].AKi.terms + forms[0].AKb.terms)[0].A0.basisfunctions[0].element
    output += __element(forms[0].name, element)

    # Write all forms
    for form in forms:

        # Choose name
        if form.rank == 1:
            type = "Linear"
        elif form.rank == 2:
            type = "Bilinear"
        else:
            print """DOLFIN can only handle linear or bilinear forms.
            I will try to generate the multi-linear form but you will not
            be able to use it with DOLFIN."""
            type = "Multilinear"

        # Write form
        output += __form(form, element, type)

    # Write file footer
    output += __file_footer()

    # Write file
    filename = name + ".h"
    file = open(filename, "w")
    file.write(output)
    file.close()
    print "Output written to " + filename
    
    return

def __file_header(name):
    "Generate file header for DOLFIN."
    return """\
// This file was automatically generated by FFC, the FEniCS Form Compiler.
// Licensed under the GNU GPL Version 2.

#ifndef __%s_H
#define __%s_H

#include <dolfin/NewFiniteElement.h>
#include <dolfin/LinearForm.h>
#include <dolfin/BilinearForm.h>

namespace dolfin { namespace %s {

""" % (__capall(name), __capall(name), name)

def __file_footer():
    "Generate file footer for DOLFIN."
    return """
} }

#endif\n"""

def __element(name, element):
    "Generate finite element for DOLFIN."

    # Generate code for initialization of tensor dimensions
    if element.rank > 0:
        diminit = "    tensordims = new unsigned int [%d];\n" % element.rank
        for j in range(element.rank):
            diminit += "    tensordims[%d] = %d;\n" % (j, element.tensordims[j])
    else:
        diminit = "    // Do nothing\n"

    # Generate code for tensordim function
    if element.rank > 0:
        tensordim = "dolfin_assert(i < %d);\n    return tensordims[i];" % element.rank
    else:
        tensordim = 'dolfin_error("Element is scalar.");\n    return 0;'

    # Generate code for dof mapping
    # FIXME: Move this somewhere else
    if element.rank > 0:
        # Assuming rank = 1
        n = element.spacedim / element.tensordims[0]
        mapping = "return (i/%d) * mesh.noNodes() + cell.nodeID(i %% %d);" % (n, n)
    else:
        mapping = "return cell.nodeID(i);"
        
    # Generate output
    return """\
/// This is the finite element for which the form is generated,
/// providing the information neccessary to do assembly.

class FiniteElement : public dolfin::NewFiniteElement
{
public:

  FiniteElement() : dolfin::NewFiniteElement(), tensordims(0)
  {
%s  }

  ~FiniteElement()
  {
    if ( tensordims ) delete [] tensordims;
  }

  inline unsigned int spacedim() const
  {
    return %d;
  }

  inline unsigned int shapedim() const
  {
    return %d;
  }

  inline unsigned int tensordim(unsigned int i) const
  {
    %s
  }

  inline unsigned int rank() const
  {
    return %d;
  }

  // FIXME: Only works for nodal basis
  inline unsigned int dof(unsigned int i, const Cell& cell, const Mesh& mesh) const
  {
    %s
  }

  // FIXME: Only works for nodal basis
  inline const Point coord(unsigned int i, const Cell& cell, const Mesh& mesh) const
  {
    Point p;
    return p;
  }

private:

  unsigned int* tensordims;

};

""" % (diminit,
       element.spacedim,
       element.shapedim,
       tensordim,
       element.rank,
       mapping)

def __form(form, element, type):
    "Generate form for DOLFIN."
    
    #ptr = "".join(['*' for i in range(form.rank)])
    subclass = type + "Form"
    baseclass = type + "Form"

    # Create argument list for form (functions)
    if form.nfunctions > 0:
        functions = ", ".join([("const NewFunction& w%d" % j) for j in range(form.nfunctions)])
    else:
        functions = ""
    
    # Class header
    output = """\
/// This class contains the form to be evaluated, including
/// contributions from the interior and boundary of the domain.

class %s : public dolfin::%s
{
public:

  %s(%s) : dolfin::%s()
""" % (subclass, baseclass, subclass, functions, baseclass)

    # Add functions (if any)
    if form.nfunctions > 0:
        output += """\
  {
    // Add functions
    init(%d, %d);\n""" % (form.nfunctions, element.spacedim)
        for j in range(form.nfunctions):
            output += "    add(w%d);\n" % j
        output += "  }\n"
    else:
        output += "  {\n  }\n"

    # Interior contribution (if any)
    if form.AKi.terms:
        output += """\

  bool interior(real* block) const
  {
    // Compute geometry tensors
%s
    // Compute element tensor
%s
    return true;
  }
""" % ("".join(["    real %s = %s;\n" % (gK.name, gK.value) for gK in form.AKi.gK]),
       "".join(["    %s = %s;\n" % (aK.name, aK.value) for aK in form.AKi.aK]))

    # Boundary contribution (if any)
    if form.AKb.terms:
        output += """\

  bool boundary(real* block) const
  {
    // Compute geometry tensors
%s
    // Compute element tensor
%s
    return true;
  }
""" % ("".join(["    real %s = %s;\n" % (gK.name, gK.value) for gK in form.AKb.gK]),
       "".join(["    %s = %s;\n" % (aK.name, aK.value) for aK in form.AKb.aK]))

    # Class footer
    output += """
};

"""

    return output

def __capall(s):
    "Return a string in which all characters are capitalized."
    return "".join([c.capitalize() for c in s])
