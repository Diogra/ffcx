"""Code generation for evaluation of finite element basis values. This module generates
code which is more or less a C++ representation of FIAT code. More specifically the
functions from the modules expansion.py and jacobi.py are translated into C++"""

__author__ = "Kristian B. Oelgaard (k.b.oelgaard@tudelft.nl)"
__date__ = "2007-04-04 -- 2007-04-16"
__copyright__ = "Copyright (C) 2007 Kristian B. Oelgaard"
__license__  = "GNU GPL Version 2"

# FFC common modules
from ffc.common.constants import *
from ffc.common.utils import *

# FFC fem modules
from ffc.fem.finiteelement import *
from ffc.fem.mixedelement import *

# FFC format modules
#from ffc.compiler.format.codesnippets import *

# Python modules
import math
import numpy

class IndentControl:
    "Class to control the indentation of code"

    def __init__(self):
        "Constructor"
        self.size = 0
        self.increment = 2

    def increase(self):
        "Increase indentation by increment"
        self.size += self.increment

    def decrease(self):
        "Decrease indentation by increment"
        self.size -= self.increment

    def indent(self, a):
        "Indent string input string by size"
        return indent(a, self.size)

def evaluate_basis(element, format):
    """Evaluate an element basisfunction at a point. The value(s) of the basisfunction is/are
    computed as in FIAT as the dot product of the coefficients (computed at compile time)
    and basisvalues which are dependent on the coordinate and thus have to be computed at
    run time.

    Currently the following elements are supported in 2D and 3D:

    Lagrange                + mixed/vector valued
    Discontinuous Lagrange  + mixed/vector valued
    Crouzeix-Raviart        + mixed/vector valued
    Brezzi-Douglas-Marini   + mixed/vector valued

    Not supported in 2D or 3D:

    Raviart-Thomas ? (not tested since it is broken in FFC, but should work)
    Nedelec (broken?)"""

# To be fixed:
# doc strings
# check that the code is language-independent

    code = []

    Indent = IndentControl()

    # Get coordinates and generate map
    code += generate_map(element, Indent, format)

    # Check if we have just one element
    if (element.num_sub_elements() == 1):

        code += dof_map(0, Indent, format)

        code += generate_element_code(element, 0, False, Indent, format)

    # If the element is vector valued or mixed
    else:
        code += generate_cases(element, Indent, format)

    return code

def generate_element_code(element, value_num, vector, Indent, format):
    "Generate code for each basis element"

    code = []

    # Tabulate coefficients
    code += tabulate_coefficients(element, Indent, format)

    # Compute scaling of y and z 1/2(1-y)^n and 1/2(1-z)^n
    code += compute_scaling(element, Indent, format)

    # Compute auxilliary functions currently only 2D and 3D is supported
    if (element.cell_shape() == 2):
        code += compute_psitilde_a(element, Indent, format)
        code += compute_psitilde_b(element, Indent, format)
    elif (element.cell_shape() == 3):
        code += compute_psitilde_a(element, Indent, format)
        code += compute_psitilde_b(element, Indent, format)
        code += compute_psitilde_c(element, Indent, format)
    else:
        raise RuntimeError(), "Cannot compute auxilliary functions for shape: %d" %(element.cell_shape())

    # Compute the basisvalues
    code += compute_basisvalues(element, Indent, format)

    # Compute the value of the basisfunction as the dot product of the coefficients
    # and basisvalues
    code += compute_values(element, value_num, vector, Indent, format)

    return code

def tabulate_coefficients(element, Indent, format):
    """This function tabulates the element coefficients that are generated by FIAT at
    compile time."""

    code = []

    format_block_begin = format["block begin"]
    format_block_end   = format["block end"]

    # Get coefficients from basis functions, computed by FIAT at compile time
    coefficients = element.basis().coeffs

    # Scalar valued basis element [Lagrange, Discontinuous Lagrange, Crouzeix-Raviart]
    if (element.value_rank() == 0):
        coefficients = [coefficients]

    # Vector valued basis element [Raviart-Thomas, Brezzi-Douglas-Marini (BDM)]
    elif (element.value_rank() == 1):
        coefficients = numpy.transpose(coefficients, [1,0,2])

    else:
        raise RuntimeError(), "Tensor elements not supported!"

    # Get number of components, must change for tensor valued elements
    num_components = element.value_dimension(0)

    # Get polynomial dimension of basis
    poly_dim = len(element.basis().base.bs)

    # Get the number of dofs from element
    num_dofs = element.space_dimension()

    code += [Indent.indent(format["comment"]("Table(s) of coefficients"))]

    # Generate tables for each component
    for i in range(num_components):

        # Extract coefficients for current component
        coeffs = coefficients[i]

        # Declare varable name for coefficients
        name = format["table declaration"] + "coefficients%d[%d][%d]" %(i, num_dofs, poly_dim)
        value = tabulate_matrix(coeffs, Indent, format)

        # Generate array of values
        code += [(Indent.indent(name), Indent.indent(value))] + [""]

    return code


def generate_map(element, Indent, format):
    """Generates map from reference triangle/tetrahedron to reference square/cube.
    The function is an implementation of the FIAT functions, eta_triangle( xi )
    and eta_tetrahedron( xi ) from expansions.py"""

    code = []

    # Prefetch formats to speed up code generation
    format_comment      = format["comment"]
    format_float        = format["float declaration"]
    format_floating_point = format["floating point"]
    format_coordinates  = format["coordinate access"]

    # Code snippets reproduced from FIAT: expansions.py: eta_triangle(xi) & eta_tetrahedron(xi)
    eta_triangle = [Indent.indent(format["snippet eta_triangle"]) %(format_floating_point(FFC_EPSILON))]

    eta_tetrahedron = [Indent.indent(format["snippet eta_tetrahedron"]) %(format_floating_point(FFC_EPSILON),\
                       format_floating_point(FFC_EPSILON))]

    # Dictionaries
    reference = {2:"square", 3:"cube"}
    mappings = {2:eta_triangle, 3:eta_tetrahedron}

    # Generate code
    # Get coordinates and map to the reference (FIAT) element from codesnippets.py
    code += [Indent.indent(format["coordinate map"](element.cell_shape()))] + [""]

    # Map coordinates to the reference square/cube
    code += [Indent.indent(format_comment("Map coordinates to the reference %s") % (reference[element.cell_shape()]))]
    code += mappings[element.cell_shape()]

    # Debug code
    #code += [Indent.indent("""// Debug code
    #        std::cout << "coordinates : " << coordinates[0] << " " << coordinates[1] << std::endl;
    #        std::cout << " mapped coordinates : " << x << " " << y << std::endl;""")]

    return code + [""]

def compute_scaling(element, Indent, format):
    """Generate the scalings of y and z coordinates. This function is an implementation of
    the FIAT function make_scalings( etas ) from expasions.py"""

    code = []

    # Get the element degree
    degree = element.degree()

    # Get the element shape
    element_shape = element.cell_shape()

    # Currently only 2D and 3D is supported
    if (element_shape == 2):
        scalings = ["y"]
        # Scale factor, for triangles 1/2*(1-y)^i i being the order of the element
        factors = ["(0.5 - 0.5 * y)"]
    elif (element_shape == 3):
        scalings = ["y", "z"]
        factors = ["(0.5 - 0.5 * y)", "(0.5 - 0.5 * z)"]
    else:
        raise RuntimeError(), "Cannot compute scaling for shape: %d" %(elemet_shape)

    code += [Indent.indent(format["comment"]("Generate scalings"))]

    # Can be optimized by leaving out the 1.0 variable
    for i in range(len(scalings)):

      name = format["const float declaration"] + "scalings_%s_%d" %(scalings[i], 0)
      value = "1.0"
      code += [(Indent.indent(name), value)]

      for j in range(1, degree+1):
          name = format["const float declaration"] + "scalings_%s_%d" %(scalings[i], j)
          value = "scalings_%s_%d*%s" %(scalings[i],j-1,factors[i])
          code += [(Indent.indent(name), value)]

    return code + [""]

def compute_psitilde_a(element, Indent, format):
    """Compute Legendre functions in x-direction. The function relies on
    eval_jacobi_batch(a,b,n) to compute the coefficients.

    The format is:
    psitilde_a[0] = 1.0
    psitilde_a[1] = a + b * x
    psitilde_a[n] = a * psitilde_a[n-1] + b * psitilde_a[n-1] * x + c * psitilde_a[n-2]
    where a, b and c are coefficients computed by eval_jacobi_batch(0,0,n)
    and n is the element degree"""

    code = []

    # Prefetch formats to speed up code generation
    format_float = format["floating point"]

    # Get the element degree
    degree = element.degree()

    code += [Indent.indent(format["comment"]("Compute psitilde_a"))]

    # Create list of variable names
    variables = ["x","psitilde_a"]

    for n in range(degree+1):
        # Declare variable
        name = format["const float declaration"] + variables[1] + "_%d" % n

        # Compute value
        value = eval_jacobi_batch_scalar(0, 0, n, variables, format)

        code += [(Indent.indent(name), value)]

    return code + [""]

def compute_psitilde_b(element, Indent, format):
    """Compute Legendre functions in y-direction. The function relies on
    eval_jacobi_batch(a,b,n) to compute the coefficients.

    The format is:
    psitilde_bs_0[0] = 1.0
    psitilde_bs_0[1] = a + b * y
    psitilde_bs_0[n] = a * psitilde_bs_0[n-1] + b * psitilde_bs_0[n-1] * x + c * psitilde_bs_0[n-2]
    psitilde_bs_(n-1)[0] = 1.0
    psitilde_bs_(n-1)[1] = a + b * y
    psitilde_bs_n[0] = 1.0
    where a, b and c are coefficients computed by eval_jacobi_batch(2*i+1,0,n-i) with i in range(0,n+1)
    and n is the element degree + 1"""

    code = []

    # Prefetch formats to speed up code generation
    format_float = format["floating point"]

    # Get the element degree
    degree = element.degree()

    code += [Indent.indent(format["comment"]("Compute psitilde_bs"))]

    for i in range(0, degree + 1):

        # Compute constants for jacobi function
        a = 2*i+1
        b = 0
        n = degree - i
            
        # Create list of variable names
        variables = ["y", "psitilde_bs_%d" % i]

        for j in range(n+1):
            # Declare variable
            name = format["const float declaration"] + variables[1] + "_%d" %j

            # Compute values
            value = eval_jacobi_batch_scalar(a, b, j, variables, format)

            code += [(Indent.indent(name), value)]

    return code + [""]

def compute_psitilde_c(element, Indent, format):
    """Compute Legendre functions in y-direction. The function relies on
    eval_jacobi_batch(a,b,n) to compute the coefficients.

    The format is:
    psitilde_cs_0[0] = 1.0
    psitilde_cs_0[1] = a + b * y
    psitilde_cs_0[n] = a * psitilde_cs_0[n-1] + b * psitilde_cs_0[n-1] * x + c * psitilde_cs_0[n-2]
    psitilde_cs_(n-1)[0] = 1.0
    psitilde_cs_(n-1)[1] = a + b * y
    psitilde_cs_n[0] = 1.0
    where a, b and c are coefficients computed by 

    [[jacobi.eval_jacobi_batch(2*(i+j+1),0, n-i-j) for j in range(0,n+1-i)] for i in range(0,n+1)]"""

    code = []

    # Prefetch formats to speed up code generation
    format_float = format["floating point"]

    # Get the element degree
    degree = element.degree()

    code += [Indent.indent(format["comment"]("Compute psitilde_cs"))]

    for i in range(0, degree + 1):
        for j in range(0, degree + 1 - i):

            # Compute constants for jacobi function
            a = 2*(i+j+1)
            b = 0
            n = degree - i - j
            
            # Create list of variable names
            variables = ["z", "psitilde_cs_%d%d" %(i,j)]

            for k in range(n+1):
                # Declare variable
                name = format["const float declaration"] + variables[1] + "_%d" % k

                # Compute values
                value = eval_jacobi_batch_scalar(a, b, k, variables, format)

                code += [(Indent.indent(name), value)]

    return code + [""]


def compute_basisvalues(element, Indent, format):
    """This function is an implementation of the loops inside the FIAT functions
    tabulate_phis_triangle( n , xs ) and tabulate_phis_tetrahedron( n , xs ) in
    expansions.py. It computes the basis values from all the previously tabulated variables."""

    code = []
    code += [Indent.indent(format["comment"]("Compute basisvalues"))]

    # Get polynomial dimension of base
    poly_dim = len(element.basis().base.bs)

    # Declare variable
    name = format["const float declaration"] + "basisvalues[%d]" % poly_dim
    value = "\\\n"

    # Get the element shape
    element_shape = element.cell_shape()

    # Optimize by declaring doubles instead of array
    # Currently only 2D and 3D is supported
    # 2D
    if (element_shape == 2):
        value += format["block begin"]
        var = []
        for k in range(0,element.degree() + 1):
            for i in range(0,k + 1):
                ii = k-i
                jj = i
                factor = math.sqrt( (ii+0.5)*(ii+jj+1.0) )
                var += [format["multiply"](["psitilde_a_%d" % ii, "scalings_y_%d" % ii,\
                        "psitilde_bs_%d_%d" %(ii, jj), format["floating point"](factor)])]

        value += ",\n".join(var)
        value += format["block end"]
    # 3D
    elif (element_shape == 3):
        value += format["block begin"]
        var = []

        for k in range(0, element.degree()+1):  # loop over degree
            for i in range(0, k+1):
                for j in range(0, k - i + 1):
                    ii = k-i-j
                    jj = j
                    kk = i
                    factor = math.sqrt( (ii+0.5) * (ii+jj+1.0) * (ii+jj+kk+1.5) )
                    var += []
                    var += [format["multiply"](["psitilde_a_%d" % ii, "scalings_y_%d" % ii,\
                        "psitilde_bs_%d_%d" % (ii, jj), "scalings_z_%d" % (ii+jj),\
                        "psitilde_cs_%d%d_%d" % (ii, jj, kk), format["floating point"](factor)])]

        value += ",\\\n ".join(var)
        value += format["block end"]
    else:
        raise RuntimeError(), "Cannot compute basis values for shape: %d" % elemet_shape

    code += [(Indent.indent(name), Indent.indent(value))]

    # Debug basis
#    code += ["std::cout" + "".join([" << basisvalues[%d] << " % i + '" "' for i in range(poly_dim)]) + " << std::endl;"]

    return code + [""]

def compute_values(element, value_num, vector, Indent, format):

    code = []
    code += [Indent.indent(format["comment"]("Compute value(s)"))]

    # Get number of components, change for tensor valued elements
    num_components = element.value_dimension(0)

    # Get polynomial dimension of base
    poly_dim = len(element.basis().base.bs)

    code += dot_product(num_components, poly_dim, "coefficients", value_num, vector, Indent, format)

    return code

def reset_values(num_components, value_num, vector, Indent, format):

    code = []

    if (vector or num_components != 1):
        # Reset values as it is a pointer
        code += [(Indent.indent("values[%d]" % (i+value_num)), "0.0") for i in range(num_components)]
    else:
        code += [(Indent.indent("*values"), "0.0")]

    return code

def dot_product(num_components, poly_dim, name_coefficients, value_num, vector, Indent, format):
    """This function computes the value of the basisfunction as the dot product of the
    coefficients and basisvalues """

    code = []

    # Reset values
    code += reset_values(num_components, value_num, vector, Indent, format)

    # Optimize by using scalars instead of array (basisvalues), skip loop
    if (vector or num_components != 1):
        # Loop dofs to generate dot product, 3D ready
        code += [Indent.indent(format["loop"]("j", poly_dim))]
        code += [Indent.indent(format["block begin"])]

        # Increase indentation
        Indent.increase()

        code += [Indent.indent(format["add equal"]("values[%d]" % (i+value_num),\
                 name_coefficients+"%d[dof][j]*basisvalues[j]" % i)) for i in range(num_components)]

        # Decrease indentation
        Indent.decrease()

        code += [Indent.indent(format["block end"])]
    else:
        # Loop poly_dim to generate dot product
        code += [Indent.indent(format["loop"]("j", poly_dim))]

        # Increase indentation
        Indent.increase()

        code += [Indent.indent(format["add equal"]("*values", name_coefficients +"0[dof][j]*basisvalues[j]"))]

        # Decrease indentation
        Indent.decrease()

    return code

def generate_cases(element, Indent, format):
    "Generate cases in the event of vector valued elements or mixed elements"

    code = []

    # Prefetch formats to speed up code generation
    format_block_begin = format["block begin"]
    format_block_end = format["block end"]

    # Extract basis elements, and determine number of elements
    elements = extract_elements(element)
    num_elements = len(elements)

    # Loop all elements
    code += [Indent.indent(format["loop"]("element", num_elements))]

    code += [Indent.indent(format["comment"]("Switch for each of the basis elements"))]
    code += [Indent.indent(format_block_begin)]
    # Increase indentation
    Indent.increase()

    # Generate switch
    code += [Indent.indent(format["switch"]("element"))]
    code += [Indent.indent(format_block_begin)]
    # Increase indentation
    Indent.increase()

    sum_value_num = 0
    sum_space_dim = 0

    # Generate cases
    for i in range(num_elements):
        code += [Indent.indent(format["case"](i))]
        code += [Indent.indent(format_block_begin)]
        # Increase indentation
        Indent.increase()

        # Get sub element
        basis_element = elements[i]

        # FIXME: This must most likely change for tensor valued elements
        value_dimension = basis_element.value_dimension(0)
        value_num = basis_element.value_dimension(0)
        space_dim = basis_element.space_dimension()

        # Determine if the element has a value, for the given dof
# Not languge-independent
        code += [Indent.indent("if (%d <= i and i <= %d)\n{" % (sum_space_dim, sum_space_dim + space_dim -1))]
        # Increase indentation
        Indent.increase()

        # Generate map from global to local dof
        code += [Indent.indent(format["comment"]("Compute local degree of freedom"))]
        code += dof_map(sum_space_dim, Indent, format)

        # Generate code for basis element
        code += generate_element_code(basis_element, sum_value_num, True, Indent, format)

        # Decrease indentation, finish block - end element code
        Indent.decrease()
        code += [Indent.indent(format_block_end)]

        # If the element does not have a value for the given dof, return 0.0
# Not languge-independent
        code += [Indent.indent("else\n{")]
        # Increase indentation
        Indent.increase()
        # Reset values
        code += reset_values(value_dimension, sum_value_num, True, Indent, format)
        # Decrease indentation
        Indent.decrease()
        code += [Indent.indent(format_block_end)]

        # End case
        code += [Indent.indent(format["break"])]
        # Decrease indentation
        Indent.decrease()
        code += [Indent.indent(format_block_end)]

        # Increase sum of value dimension, and space dimension
        sum_value_num += value_num
        sum_space_dim += space_dim

    # Decrease indentation, end switch
    Indent.decrease()
    code += [Indent.indent(format_block_end)]

    # Decrease indentation, end loop elements
    Indent.decrease()
    code += [Indent.indent(format_block_end)]

    return code

def extract_elements(element):
    """This function extracts the basis elements recursively from vector elements and mixed elements.
    Example, the following mixed element:

    element1 = FiniteElement("Lagrange", "triangle", 1)
    element2 = VectorElement("Lagrange", "triangle", 2)

    element  = element2 + element1

    has the structure: mixed-element[mixed-element[Lagrange order 2, Lagrange order 2], Lagrange order 1]

    This function returns the list of basis elements:
    elements = [Lagrange order 2, Lagrange order 2, Lagrange order 1]"""

    elements = []

    if isinstance(element, FiniteElement):
        elements += [element]
    else:
        for i in range(element.num_sub_elements()):
            elements += extract_elements(element.sub_element(i))

    return elements

def dof_map(sum_space_dim, Indent, format):
    """This function creates code to map a basis function to a local basis function.
    Example, the following mixed element:

    element = VectorElement("Lagrange", "triangle", 2)

    has the element list, elements = [Lagrange order 2, Lagrange order 2] and 12 dofs (6 each).

    However since only one unique element exists, the evaluation of basis function 8 is 
    mapped to 2 (8-6) for the unique element."""

    # Use snippet from codesnippets.py    
#    code = [Indent.indent(format["comment"]("Map basis function to local basisfunction"))]
#    code += [Indent.indent(format["snippet dof map"] % len(elements))]
    if sum_space_dim == 0:
        code = [(Indent.indent(format["const uint declaration"] + "dof"), "i")] + [""]
    else:
        code = [(Indent.indent(format["const uint declaration"] + "dof"), "i - %d" % (sum_space_dim))] + [""]

    return code

def tabulate_matrix(matrix, Indent, format):
    "Function that tabulates the values of a matrix, into an array."

    # Get size of array
    num_rows = numpy.shape(matrix)[0]
    num_cols = numpy.shape(matrix)[1]

    # Generate array of values
    value = "\\\n" + format["block begin"]
    rows = []
    for i in range(num_rows):
        rows += [format["block begin"] + ", ".join([format["floating point"](matrix[i,j])\
                 for j in range(num_cols)]) + format["block end"]]

    value += ",\n".join(rows)
    value += format["block end"]

    return value

def eval_jacobi_batch_array(a, b, n, variables, format):
    """Implementation of FIAT function eval_jacobi_batch(a,b,n,xs) from jacobi.py"""

    # Prefetch formats to speed up code generation
    format_float  = format["floating point"]
    format_mult   = format["multiply"]
    format_add   = format["add"]

    # Format variables
    access = lambda i: variables[1] + "[%d]" % i
    coord = variables[0]

    # Entry 0 is always 1.0
    value = format["block begin"] + "1.0"

    if n > 0:
        # Results for entry 1, of type (a + b * coordinate) (coordinate = x, y or z)
        res0 = 0.5 * (a - b)
        res1 = 0.5 * ( a + b + 2.0 )

        val0, val1 = ("", "")
        if (res0 != 0.0): # Only include if the value is not zero
            val0 = format_float(res0)

        if (res1 != 0.0): # Only include if the value is not zero
            if (res1 < 0.0): # If value is less than zero minus sign is needed
                val1 = format_mult([format_float(res1), coord])
            else:
                if (val0): # If the value in front is present plus sign is needed
                    val1 = " + " + format_mult([format_float(res1), coord])
                else:
                    val1 = format_mult([format_float(res1), coord])

        value += ", " + "".join([val0, val1])

        apb = a + b
        # Compute remaining entries, of type (a + b * coordinate) * psitilde[k-1] - c * psitilde[k-2])
        for k in range(2,n+1):
            a1 = 2.0 * k * ( k + apb ) * ( 2.0 * k + apb - 2.0 )
            a2 = ( 2.0 * k + apb - 1.0 ) * ( a * a - b * b )
            a3 = ( 2.0 * k + apb - 2.0 ) * ( 2.0 * k + apb - 1.0 ) * ( 2.0 * k + apb )
            a4 = 2.0 * ( k + a - 1.0 ) * ( k + b - 1.0 ) * ( 2.0 * k + apb )
            a2 = a2 / a1
            a3 = a3 / a1
            # Note:  we subtract the value of a4!
            a4 = -a4 / a1

            val2, val3, val4 = ("", "", "")
            if (a2 != 0.0): # Only include if the value is not zero
                val2 = format_mult([format_float(a2), access(k-1)])

            if (a3 != 0.0): # Only include if the value is not zero
                if (a3 < 0.0): # If value is less than zero minus sign is needed
                   val3 = format_mult([format_float(a3), coord, access(k-1)])
                else:
                    if (val2): # If the value in front is present plus sign is needed
                        val3 = " + " + format_mult([format_float(a3), coord, access(k-1)])
                    else:
                        val3 = format_mult([format_float(a3), coord, access(k-1)])

            if (a4 != 0.0): # Only include if the value is not zero
                if (a4 < 0.0): # If value is less than zero minus sign is needed
                    val4 = format_mult([format_float(a4), access(k-2)])
                else:
                    if (val2 or val3): # If the value(s) in front is/are present plus sign is needed
                        val4 = " + " + format_mult([format_float(a4), access(k-2)])
                    else:
                        val4 = format_mult([format_float(a4), access(k-2)])

            value += ", " + "".join([val2, val3, val4])

    value += format["block end"]

    return value

def eval_jacobi_batch_scalar(a, b, n, variables, format):
    """Implementation of FIAT function eval_jacobi_batch(a,b,n,xs) from jacobi.py"""

    # Prefetch formats to speed up code generation
    format_float  = format["floating point"]
    format_mult   = format["multiply"]
    format_add   = format["add"]

    # Format variables
    access = lambda i: variables[1] + "_%d" % i
    coord = variables[0]

    # Entry 0 is always 1.0
    value = format["block begin"] + "1.0"

    if n == 0:
        return "1.0"
    if n == 1:
        # Results for entry 1, of type (a + b * coordinate) (coordinate = x, y or z)
        res0 = 0.5 * (a - b)
        res1 = 0.5 * ( a + b + 2.0 )
        val0, val1 = ("", "")
        if (res0 != 0.0): # Only include if the value is not zero
            val0 = format_float(res0)

        if (res1 != 0.0): # Only include if the value is not zero
            if (res1 < 0.0): # If value is less than zero minus sign is needed
                val1 = format_mult([format_float(res1), coord])
            else:
                if (val0): # If the value in front is present plus sign is needed
                    val1 = " + " + format_mult([format_float(res1), coord])
                else:
                    val1 = format_mult([format_float(res1), coord])

        return "".join([val0, val1])

    else:
        apb = a + b
        # Compute remaining entries, of type (a + b * coordinate) * psitilde[n-1] - c * psitilde[n-2])
        a1 = 2.0 * n * ( n + apb ) * ( 2.0 * n + apb - 2.0 )
        a2 = ( 2.0 * n + apb - 1.0 ) * ( a * a - b * b )
        a3 = ( 2.0 * n + apb - 2.0 ) * ( 2.0 * n + apb - 1.0 ) * ( 2.0 * n + apb )
        a4 = 2.0 * ( n + a - 1.0 ) * ( n + b - 1.0 ) * ( 2.0 * n + apb )
        a2 = a2 / a1
        a3 = a3 / a1
        # Note:  we subtract the value of a4!
        a4 = -a4 / a1

        val2, val3, val4 = ("", "", "")
        if (a2 != 0.0): # Only include if the value is not zero
            val2 = format_mult([format_float(a2), access(n-1)])

        if (a3 != 0.0): # Only include if the value is not zero
            if (a3 < 0.0): # If value is less than zero minus sign is needed
                val3 = format_mult([format_float(a3), coord, access(n-1)])
            else:
                if (val2): # If the value in front is present plus sign is needed
                    val3 = " + " + format_mult([format_float(a3), coord, access(n-1)])
                else:
                    val3 = format_mult([format_float(a3), coord, access(n-1)])

        if (a4 != 0.0): # Only include if the value is not zero
            if (a4 < 0.0): # If value is less than zero minus sign is needed
                val4 = format_mult([format_float(a4), access(n-2)])
            else:
                if (val2 or val3): # If the value(s) in front is/are present plus sign is needed
                    val4 = " + " + format_mult([format_float(a4), access(n-2)])
                else:
                    val4 = format_mult([format_float(a4), access(n-2)])

        return "".join([val2, val3, val4])
