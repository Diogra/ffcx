"""Code generation for evaluation of finite element basis values. This module generates
   code which is more or less a C++ representation of FIAT code. More specifically the
   functions from the modules expansion.py and jacobi.py are translated into C++"""

__author__ = "Kristian B. Oelgaard (k.b.oelgaard@tudelft.nl)"
__date__ = "2007-04-04 -- 2007-04-16"
__copyright__ = "Copyright (C) 2007 Kristian B. Oelgaard"
__license__  = "GNU GPL Version 2"

# FFC common modules
from ffc.common.constants import *

# FFC fem modules
from ffc.fem.finiteelement import *
from ffc.fem.mixedelement import *

# Python modules
import math
import numpy

def evaluate_basis(element, format):
    """Evaluate an element basisfunction at a point. The value(s) of the basisfunction is/are
       computed as in FIAT as the dot product of the coefficients (computed at compile time)
       and basisvalues which are dependent on the coordinate and thus have to be computed at
       run time.

       Currently the following elements are supported in 2D and 3D:

       Lagrange                + mixed/vector valued
       Discontinuous Lagrange  + mixed/vector valued
       Crouzeix-Raviart        + mixed/vector valued
       Brezzi-Douglas-Marini   + mixed/vector valued

       Not supported in 2D or 3D:

       Raviart-Thomas ? (not tested since it is broken in FFC, but should work)
       Nedelec (broken?)"""

# To be fixed:
# check that the code is language-independent

    code = []

    # Check if we have just one element
    if (element.num_sub_elements() == 1):
        code += generate_element_code(element, format)

    # If the element is vector valued or mixed
    else:
        code += generate_cases(element, format)

    return code

def generate_element_code(element, format):
    "Generate code for each basis element"

    code = []

    # Tabulate coefficients
    code += tabulate_coefficients(element, format)

    # Get coordinates and generate map
    code += generate_map(element, format)

    # Compute scaling of y and z 1/2(1-y)^n and 1/2(1-z)^n
    code += compute_scaling(element, format)

    # Compute auxilliary functions
    code += compute_psitilde_a(element, format)
    code += compute_psitilde_b(element, format)
    code += compute_psitilde_c(element, format)

    # Compute the basisvalues
    code += compute_basisvalues(element, format)

    # Compute the value of the basisfunction as the dot product of the coefficients
    # and basisvalues
    code += dot_product(element, format)

    return code

def tabulate_coefficients(element, format):
    """This function tabulates the element coefficients that are generated by FIAT at
    compile time."""

    code = []

    # Prefetch formats to speed up code generation
    format_block_begin  = format["block begin"]
    format_block_end    = format["block end"]

    # Get coefficients from basis functions, computed by FIAT at compile time
    coefficients = element.basis().coeffs

    # Get shape of coefficients
    shape = numpy.shape(coefficients)

    # Scalar valued basis element [Lagrange, Discontinuous Lagrange, Crouzeix-Raviart]
    if (len(shape) == 2):
        num_components = 1
        poly_dim = shape[1]
        coefficients = [coefficients]

    # Vector valued basis element [Raviart-Thomas, Brezzi-Douglas-Marini (BDM)]
    elif (len(shape) == 3):
        num_components = shape[1]
        poly_dim = shape[2]
        coefficients = numpy.transpose(coefficients, [1,0,2])

    # ???
    else:
        raise RuntimeError(), "These coefficients have a strange shape!"

    # Get the number of dofs from element
    num_dofs = element.space_dimension()

    code += [format["comment"]("Table(s) of coefficients")]

    # Generate tables for each component
    for i in range(num_components):

        # Extract coefficients for current component
        coeffs = coefficients[i]

        # Declare varable name for coefficients
        name = format["table declaration"] + "coefficients%d[%d][%d]" %(i, num_dofs, poly_dim,)

        # Generate array of values
        value = "\\\n" + format_block_begin
        rows = []
        for j in range(num_dofs):
            rows += [format_block_begin + ", ".join([format["floating point"](coeffs[j,k])\
                     for k in range(poly_dim)]) + format_block_end]

        value += ",\n".join(rows)
        value += format_block_end

        code += [(name, value)] + [""]

    return code


def generate_map(element, format):
    """Generates map from reference triangle/tetrahedron to reference square/cube.
       The function is an implementation of the FIAT functions, eta_triangle( xi )
       and eta_tetrahedron( xi ) from expansions.py"""

    code = []

    # Prefetch formats to speed up code generation
    format_comment      = format["comment"]
    format_float        = format["float declaration"]
    format_coordinates  = format["coordinate access"]

    # Code snippets reproduced from FIAT: expansions.py: eta_triangle(xi) & eta_tetrahedron(xi)
    eta_triangle = ["if (%s < %s)" % (format["absolute value"]("y - 1.0"), format["floating point"](FFC_EPSILON),),\
    (indent("x",2), -1.0), "else", (indent("x",2), "2.0 * (1.0 + x)/(1.0 - y) - 1.0")]

    eta_tetrahedron = ["if (%s < %s)" % (format["absolute value"]("y + z"), format["floating point"](FFC_EPSILON),),\
    (indent("x",2), 1.0), "else", (indent("x",2), "-2.0 * (1.0 + x)/(y + z) - 1.0"),\
    "if (%s < %s)" % (format["absolute value"]("z - 1.0"), format["floating point"](FFC_EPSILON),),\
    (indent("y",2), -1.0), "else", (indent("y",2), "2.0 * (1.0 + y)/(1.0 - z) - 1.0")]

    # List of coordinate declarations
    coordinates = [(format_float + "x", format_coordinates(0)), \
    (format_float + "y", format_coordinates(1)), (format_float + "z", format_coordinates(2))]

    # Dictionaries
    reference = {2:"square", 3:"cube"}
    mappings = {2:eta_triangle, 3:eta_tetrahedron}

    # Generate code
    code += [format_comment("Get coordinates")]
    code += [coordinates[i] for i in range(element.cell_shape())] + [""]
    code += [format_comment("Map coordinates to the reference %s" % (reference[element.cell_shape()]))]
    code += mappings[element.cell_shape()]

    return code + [""]

def compute_scaling(element, format):
    """Generate the scalings of y and z coordinates. This function is an implementation of
       the FIAT function make_scalings( etas ) from expasions.py"""

    code = []

    # Get the element degree
    degree = element.degree()

    # Get the element shape
    element_shape = element.cell_shape()

    # Currently only 2D and 3D is supported
    if (element_shape == 2):
        scalings = ["y"]
        # Scale factor, for triangles 1/2*(1-y)^i i being the order of the element
        factors = ["(0.5 - 0.5 * y)"]
    elif (element_shape == 3):
        scalings = ["y", "z"]
        factors = ["(0.5 - 0.5 * y)", "(0.5 - 0.5 * z)"]
    else:
        raise RuntimeError(), "Cannot compute scaling for shape: %d" %(elemet_shape)

    code += [format["comment"]("Generate scalings")]

    for i in range(len(scalings)):
      # Declare scaling variable
      name = format["const float declaration"] + "scalings_%s[%d]" %(scalings[i], degree+1,)
      value = format["block begin"] + "1.0"
      if degree > 0:
          value += ", " + ", ".join(["scalings_%s[%d]*%s" %(scalings[i],j-1,factors[i])\
                                     for j in range(1, degree+1)])
      value += format["block end"]

      code += [(name, value)] + [""]

    return code

def compute_psitilde_a(element, format):
    """Compute Legendre functions in x-direction. The function relies on
       eval_jacobi_batch(a,b,n) to compute the coefficients.

       The format is:
       psitilde_a[0] = 1.0
       psitilde_a[1] = a + b * x
       psitilde_a[n] = a * psitilde_a[n-1] + b * psitilde_a[n-1] * x + c * psitilde_a[n-2]
       where a, b and c are coefficients computed by eval_jacobi_batch(0,0,n)
       and n is the element degree"""

    code = []

    # Prefetch formats to speed up code generation
    format_float = format["floating point"]

    # Get the element degree
    degree = element.degree()

    code += [format["comment"]("Compute psitilde_a")]

    # Create list of variable names
    variables = ["x","psitilde_a"]

    # Declare variable
    name = format["const float declaration"] + variables[1] + "[%d]" %(degree+1,)

    # Compute values
    value = eval_jacobi_batch(0, 0, degree, variables, format)

    code += [(name, value)]

    return code + [""]

def compute_psitilde_b(element, format):
    """Compute Legendre functions in y-direction. The function relies on
       eval_jacobi_batch(a,b,n) to compute the coefficients.

       The format is:
       psitilde_bs_0[0] = 1.0
       psitilde_bs_0[1] = a + b * y
       psitilde_bs_0[n] = a * psitilde_bs_0[n-1] + b * psitilde_bs_0[n-1] * x + c * psitilde_bs_0[n-2]
       psitilde_bs_(n-1)[0] = 1.0
       psitilde_bs_(n-1)[1] = a + b * y
       psitilde_bs_n[0] = 1.0
       where a, b and c are coefficients computed by eval_jacobi_batch(2*i+1,0,n-i) with i in range(0,n+1)
       and n is the element degree + 1"""

    code = []

    # Prefetch formats to speed up code generation
    format_float = format["floating point"]

    # Get the element degree
    degree = element.degree()

    code += [format["comment"]("Compute psitilde_bs")]

    for i in range(0, degree + 1):

        # Compute constants for jacobi function
        a = 2*i+1
        b = 0
        n = degree - i
            
        # Create list of variable names
        variables = ["y", "psitilde_bs_%d" %(i)]

        # Declare variable
        name = format["const float declaration"] + variables[1] + "[%d]" %(n+1)

        # Compute values
        value = eval_jacobi_batch(a, b, n, variables, format)

        code += [(name, value)] + [""]

    return code

def compute_psitilde_c(element, format):
    """Compute Legendre functions in y-direction. The function relies on
       eval_jacobi_batch(a,b,n) to compute the coefficients.

       The format is:
       psitilde_cs_0[0] = 1.0
       psitilde_cs_0[1] = a + b * y
       psitilde_cs_0[n] = a * psitilde_cs_0[n-1] + b * psitilde_cs_0[n-1] * x + c * psitilde_cs_0[n-2]
       psitilde_cs_(n-1)[0] = 1.0
       psitilde_cs_(n-1)[1] = a + b * y
       psitilde_cs_n[0] = 1.0
       where a, b and c are coefficients computed by 

       [[jacobi.eval_jacobi_batch(2*(i+j+1),0, n-i-j) for j in range(0,n+1-i)] for i in range(0,n+1)]
       """

    code = []

    # Prefetch formats to speed up code generation
    format_float = format["floating point"]

    # Get the element degree
    degree = element.degree()

    code += [format["comment"]("Compute psitilde_cs")]

    for i in range(0, degree + 1):
        for j in range(0, degree + 1 - i):

            # Compute constants for jacobi function
            a = 2*(i+j+1)
            b = 0
            n = degree - i - j
            
            # Create list of variable names
            variables = ["z", "psitilde_cs_%d%d" %(i,j)]

            # Declare variable
            name = format["const float declaration"] + variables[1] + "[%d]" %(n+1)

            # Compute values
            value = eval_jacobi_batch(a, b, n, variables, format)

            code += [(name, value)] + [""]

    return code


def compute_basisvalues(element, format):
    """This function is an implementation of the loops inside the FIAT functions
       tabulate_phis_triangle( n , xs ) and tabulate_phis_tetrahedron( n , xs ) in
       expansions.py. It computes the basis values from all the previously tabulated variables."""

    code = []
    code += [format["comment"]("Compute basisvalues")]

    # Get coefficients from basis functions, computed by FIAT at compile time
    coefficients = element.basis().coeffs

    # Get shape of coefficients
    shape = numpy.shape(coefficients)

    # Scalar valued basis element [Lagrange, Discontinuous Lagrange, Crouzeix-Raviart]
    if (len(shape) == 2):
        poly_dim = shape[1]

    # Vector valued basis element [Raviart-Thomas, Brezzi-Douglas-Marini (BDM)]
    elif (len(shape) == 3):
        poly_dim = shape[2]

    # ???
    else:
        raise RuntimeError(), "These coefficients have a strange shape!"

    # Declare variable
    name = format["const float declaration"] + "basisvalues[%d]" %(poly_dim,)
    value = ""

    # Get the element shape
    element_shape = element.cell_shape()

    # Currently only 2D and 3D is supported
    # 2D
    if (element_shape == 2):
        value += format["block begin"]
        var = []
        for k in range(0,element.degree() + 1):
            for i in range(0,k + 1):
                ii = k-i
                jj = i
                factor = math.sqrt( (ii+0.5)*(ii+jj+1.0) )
                var += [format["multiply"](["psitilde_a[%d]" %(ii), "scalings_x[%d]" %(ii),\
                        "psitilde_bs_%d[%d]" %(ii,jj), format["floating point"](factor)])]

        value += ", ".join(var)
        value += format["block end"]
    # 3D
    elif (element_shape == 3):
        value += format["block begin"]
        var = []

        for k in range(0, element.degree()+1):  # loop over degree
            for i in range(0, k+1):
                for j in range(0, k - i + 1):
                    ii = k-i-j
                    jj = j
                    kk = i
                    factor = math.sqrt( (ii+0.5) * (ii+jj+1.0) * (ii+jj+kk+1.5) )
                    var += []
                    var += [format["multiply"](["psitilde_a[%d]" %(ii), "scalings_y[%d]" %(ii),\
                        "psitilde_bs_%d[%d]" %(ii,jj), "scalings_z[%d]" %(ii+jj),\
                        "psitilde_cs_%d%d[%d]" %(ii,jj,kk), format["floating point"](factor)])]

        value += ", ".join(var)
        value += format["block end"]
    else:
        raise RuntimeError(), "Cannot compute basis values for shape: %d" %(elemet_shape)

    code += [(name, value)]

    return code + [""]

def dot_product(element, format):
    """This function computes the value of the basisfunction as the dot product of the
       coefficients and basisvalues """

    code = []

    code += [format["comment"]("Compute values")]

    # Get coefficients from basis functions, computed by FIAT at compile time
    coefficients = element.basis().coeffs

    # Get shape of coefficients
    shape = numpy.shape(coefficients)

    # Scalar valued basis element [Lagrange, Discontinuous Lagrange, Crouzeix-Raviart]
    if (len(shape) == 2):
        poly_dim = shape[1]

        # Reset value as it is a pointer
        code += [("*values", "0.0")]

        # Loop dofs to generate dot product, 3D ready
        code += [format["loop"]("j", "j", poly_dim, "j")]
        code += [indent(format["add equal"]("*values","coefficients0[i][j]*basisvalues[j]"),2)]

    # Vector valued basis element [Raviart-Thomas, Brezzi-Douglas-Marini (BDM)]
    elif (len(shape) == 3):
        num_components = shape[1]
        poly_dim = shape[2]

        # Reset value as it is a pointer
        code += [("values[%d]" %(i), "0.0") for i in range(num_components)]

        # Loop dofs to generate dot product, 3D ready
        code += [format["loop"]("j", "j", poly_dim, "j")]
        code += [format["block begin"]]
        code += [indent(format["add equal"]("values[%d]" %(i),\
                 "coefficients%d[i][j]*basisvalues[j]" %(i)),2) for i in range(num_components)]
        code += [format["block end"]]

    # ???
    else:
        raise RuntimeError(), "These coefficients have a strange shape!"

    return code

def eval_jacobi_batch(a, b, n, variables, format):
    """Implementation of FIAT function eval_jacobi_batch(a,b,n,xs) from jacobi.py"""

    # Prefetch formats to speed up code generation
    format_float  = format["floating point"]
    format_mult   = format["multiply"]
    format_add   = format["add"]

    # Format variables
    access = lambda i: variables[1] + "[%d]" %(i)
    coord = variables[0]

    # Entry 0 is always 1.0
    value = format["block begin"] + "1.0"

    if n > 0:
        # Results for entry 1, of type (a + b * coordinate) (coordinate = x, y or z)
        res0 = 0.5 * (a - b)
        res1 = 0.5 * ( a + b + 2.0 )

        val0, val1 = ("", "")
        if (res0 != 0.0): # Only include if the value is not zero
            val0 = format_float(res0)

        if (res1 != 0.0): # Only include if the value is not zero
            if (res1 < 0.0): # If value is less than zero minus sign is needed
                val1 = format_mult([format_float(res1), coord])
            else:
                if (val0): # If the value in front is present plus sign is needed
                    val1 = " + " + format_mult([format_float(res1), coord])
                else:
                    val1 = format_mult([format_float(res1), coord])

        value += ", " + "".join([val0, val1])

        apb = a + b
        # Compute remaining entries, of type (a + b * coordinate) * psitilde[k-1] - c * psitilde[k-2])
        for k in range(2,n+1):
            a1 = 2.0 * k * ( k + apb ) * ( 2.0 * k + apb - 2.0 )
            a2 = ( 2.0 * k + apb - 1.0 ) * ( a * a - b * b )
            a3 = ( 2.0 * k + apb - 2.0 ) * ( 2.0 * k + apb - 1.0 ) * ( 2.0 * k + apb )
            a4 = 2.0 * ( k + a - 1.0 ) * ( k + b - 1.0 ) * ( 2.0 * k + apb )
            a2 = a2 / a1
            a3 = a3 / a1
            # Note:  we subtract the value of a4!
            a4 = -a4 / a1

            val2, val3, val4 = ("", "", "")
            if (a2 != 0.0): # Only include if the value is not zero
                val2 = format_mult([format_float(a2), access(k-1)])

            if (a3 != 0.0): # Only include if the value is not zero
                if (a3 < 0.0): # If value is less than zero minus sign is needed
                   val3 = format_mult([format_float(a3), coord, access(k-1)])
                else:
                    if (val2): # If the value in front is present plus sign is needed
                        val3 = " + " + format_mult([format_float(a3), coord, access(k-1)])
                    else:
                        val3 = format_mult([format_float(a3), coord, access(k-1)])

            if (a4 != 0.0): # Only include if the value is not zero
                if (a4 < 0.0): # If value is less than zero minus sign is needed
                    val4 = format_mult([format_float(a4), access(k-2)])
                else:
                    if (val2 or val3): # If the value(s) in front is/are present plus sign is needed
                        val4 = " + " + format_mult([format_float(a4), access(k-2)])
                    else:
                        val4 = format_mult([format_float(a4), access(k-2)])

            value += ", " + "".join([val2, val3, val4])

    value += format["block end"]

    return value


def generate_cases(element, format):
    "Generate cases in the event of vector valued elements or mixed elements"

    # Prefetch formats to speed up code generation
    format_block_begin = format["block begin"]
    format_block_end = format["block end"]

    # Extract basis elements
    elements = extract_elements(element)

    code, unique_elements = element_types(elements, format)

    code += dof_map(elements, format)

    num_unique_elements = len(unique_elements)
    if (num_unique_elements > 1):
        code += [format["switch"]("element")]
        code += [format_block_begin]

        for i in range(len(unique_elements)):
            code += [format["case"](i)]
            code += [format_block_begin]
            element = unique_elements[i]
            code += generate_element_code(element, format)
            code += [format["break"]]
            code += [format_block_end]

        code += [format_block_end]

    else:
        element = unique_elements[0]
        code += generate_element_code(element, format)

    return code

def extract_elements(element):
    """This function extracts the individual elements from vector elements and mixed elements.
    Example, the following mixed element:

    element1 = FiniteElement("Lagrange", "triangle", 1)
    element2 = VectorElement("Lagrange", "triangle", 2)

    element  = element2 + element1

    has the structure: mixed-element[mixed-element[Lagrange order 2, Lagrange order 2], Lagrange order 1]

    This function returns the list of basis elements:
    elements = [Lagrange order 2, Lagrange order 2, Lagrange order 1]"""

    elements = [element.sub_element(i) for i in range(element.num_sub_elements())]

    mixed = True
    while (mixed == True):
        mixed = False
        for i in range(len(elements)):
            sub_element = elements[i]
            if isinstance(sub_element, MixedElement):
                mixed = True
                elements.pop(i)
                for j in range(sub_element.num_sub_elements()):
                    elements.insert(i+j, sub_element.sub_element(j))

    return elements

def element_types(elements, format):
    """This function creates a list of element types and a list of unique elements.

    Example, the following mixed element:

    element1 = FiniteElement("Lagrange", "triangle", 1)
    element2 = VectorElement("Lagrange", "triangle", 2)

    element  = element2 + element1

    has the element list, elements = [Lagrange order 2, Lagrange order 2, Lagrange order 1]

    Unique elements are: unique_elements = [Lagrange order 2, Lagrange order 1]
    and the element types, element_types = [0, 0, 1]"""

    code = []

    # Prefetch formats to speed up code generation
    format_block_begin = format["block begin"]
    format_block_end = format["block end"]

    unique_elements = [elements[0]]
    types = [0]

    for i in range(1, len(elements)):
        unique = True
        element = elements[i]
        elem_type = len(unique_elements)
        for j in range(elem_type):
            if (element.signature() == unique_elements[j].signature()):
                unique = False
                elem_type = j
                break
        if unique:
            unique_elements += [element]
        types += [elem_type]

    code += [format["comment"]("Element types")]

    # Declare element types and tabulate
    name = format["const uint declaration"] + "element_types[%d]" %(len(elements),)
    value = format_block_begin
    value += ", ".join(["%d" %(element_type) for element_type in types])
    value += format_block_end
    code += [(name, value)] + [""]

    # Declare dofs_per_element variable and tabulate
    code += [format["comment"]("Number of degrees of freedom per element")]
    name = format["const uint declaration"] + "dofs_per_element[%d]" %(len(elements),)
    value = format_block_begin
    value += ", ".join(["%d" %(element.space_dimension()) for element in elements])
    value += format_block_end
    code += [(name, value)] + [""]


    return (code, unique_elements)


def dof_map(elements, format):
    """This function creates code to map a basis function to a local basis function.
    Example, the following mixed element:

    element = VectorElement("Lagrange", "triangle", 2)

    has the element list, elements = [Lagrange order 2, Lagrange order 2] and 12 dofs (6 each).

    However since only one unique element exists, the evaluation of basis function 8 is 
    mapped to 2 (8-6) for the unique element."""
    
    code = []

    # Prefetch formats to speed up code generation
    format_block_begin = format["block begin"]
    format_block_end = format["block end"]
    format_comment =  format["comment"]

    code += [format_comment("Map basis function to local basisfunction")]

    # Declare variable for dof map
    code += [(format["uint declaration"] + "element",0)]
    code += [(format["uint declaration"] + "tmp",0)]

    # Loop elements
    code += [format["loop"]("j", "j", len(elements), "j")]
    code += [format_block_begin]
    # if
    code += [indent("if (tmp +  dofs_per_element[j] > i)",2)]
    code += [indent(format_block_begin,2)]
    code += [(indent("i",4), "i - tmp")]
    code += [(indent("element",4), "element_types[j]")]
    code += [indent(format["break"],4)]
    code += [indent(format_block_end,2)]
    # else
    code += [indent("else",2)]
    code += [indent(format_block_begin,2)]
    code += [indent(format["add equal"]("tmp","dofs_per_element[j]"),4)]
    code += [indent(format_block_end,2)]

    # end loop    
    code += [format_block_end]

    return code
