
from uflacs.utils.log import uflacs_assert
from ufl.classes import Terminal, Indexed, Grad, Restricted, Argument, Product, Sum, Division

def strip_modified_terminal(v):
    "Extract core Terminal from a modified terminal or return None."
    while not isinstance(v, Terminal):
        if isinstance(v, (Indexed, Grad, Restricted)):
            v = v.operands()[0]
        else:
            return None
    return v

def build_argument_component_sets(SV):
    "Build mapping {argument_count: {vertex_number: modified_terminal}} with all argument vertices."
    arg_sets = {}
    for i,v in enumerate(SV):
        a = strip_modified_terminal(v)
        if not isinstance(a, Argument):
            continue
        c = a.count()
        s = arg_sets.get(c)
        if s is None:
            s = {}
            arg_sets[c] = s
        s[i] = v
    return arg_sets

def build_valid_argument_combinations(arg_sets):
    "Build all valid permuations of argument products combinations."
    if not arg_sets:
        return set(), []
    counts = sorted(arg_sets.keys())
    arg_indices = set(arg_sets[counts[0]])
    arg_combos = [(i,) for i in sorted(arg_indices)]
    for c in counts[1:]:
        js = sorted(arg_sets[c])
        arg_indices.update(js)
        arg_combos = [comb + (j,) for comb in arg_combos for j in js]
    return arg_indices, arg_combos

def build_argument_dependencies(SV, dependencies, arg_indices):
    "Preliminary algorithm: build list of argument vertex indices each vertex (indirectly) depends on."
    A = [[] for i in range(len(SV))] # TODO: Use array
    for i,v in enumerate(SV):
        deps = dependencies[i]
        argdeps = []
        for j in deps:
            if j in arg_indices:
                argdeps.append(j)
            else:
                argdeps.extend(A[j])
        A[i] = sorted(argdeps)
    return A

def collect_argument_factors(SV, dependencies, arg_indices):
    "TODO:"
    # TODO: Instead of argdeps being a list of argument vertex indices v (indirectly) depends on,
    #       it should be a mapping { combo: factors } to handle e.g. (u + fu')(gv + v')

    A = [None]*len(SV) # TODO: Use array
    for i,v in enumerate(SV):
        deps = dependencies[i]

        if len(deps):
            if isinstance(v, Product):
                fac0 = A[deps[0]]
                fac1 = A[deps[1]]
                if fac0 is None and fac1 is None:
                    factors = None
                elif fac0 is None:
                    v0 = (deps[0],)
                    factors = {}
                    for k1,v1 in fac1.items():
                        k = k1
                        v = v1 + v0
                        factors[k] = v
                elif fac1 is None:
                    v1 = (deps[1],)
                    factors = {}
                    for k0,v0 in fac0.items():
                        k = k0
                        v = v0 + v1
                        factors[k] = v
                else:
                    factors = {}
                    keys0 = tuple(fac0.keys())
                    keys1 = tuple(fac1.keys())
                    # For all permutations of items in fac0, fac1:
                    for k0,v0 in fac0.items():
                        for k1,v1 in fac1.items():
                            # Concatenate both key and value tuples, collecting products factors
                            k = k0 + k1
                            v = v0 + v1
                            factors[k] = v
            elif isinstance(v, Sum):
                # TODO: Test!
                # Merge items in fac0 and fac1
                fac0 = A[deps[0]]
                fac1 = A[deps[1]]
                if fac0 is None and fac1 is None:
                    factors = None
                else:
                    uflacs_assert(fac0 is not None and fac1 is not None, "Not expecting different argument factor status for summands.")
                    uflacs_assert(set(fac0.keys()) == set(fac1.keys()), "Not expecting different argument factor status terms fro summands.")
                    factors = {}
                    for k in fac0.keys():
                        factors[k] = fac0[k] + fac1[k]

            elif isinstance(v, Division):
                # TODO: Handle v/f as v*(1/f), maybe by adding -index_of_f to factor list?
                notimplemented

            else:
                # TODO: Check
                notimplemented
        else:
            if i in arg_indices:
                factors = { (i,): () }
            else:
                factors = None

        print 'fac:', i, factors
        A[i] = factors

    return A

def compute_argument_factorization(SV, svs, dependencies):
    if 1: # Disable algorithm
        return None, None

    arg_sets = build_argument_component_sets(SV)

    arg_indices, valid_arg_combos = build_valid_argument_combinations(arg_sets)

    A = build_argument_dependencies(SV, dependencies, arg_indices)

    if 1:
        print 'SV:'
        print '\n'.join("%d: %s" % (i,v) for i,v in enumerate(SV))
        print 'svs:'
        print svs
        print 'dependencies:'
        print dependencies
        print 'arg_sets:'
        print '\n'.join(map(str,arg_sets.items()))
        print 'arg_indices:'
        print arg_indices
        print 'valid_arg_combos:'
        print valid_arg_combos
        print 'A:'
        print A

    F = collect_argument_factors(SV, dependencies, arg_indices)
    print 'F:'
    print F

    for j in svs:
        it = F[j]
        (k, v), = it.items()
        args   = " * ".join(str(SV[j]) for j in k)
        coeffs = " * ".join(str(SV[j]) for j in v)
        print "s_%d = (%s) * (%s)" % (j, coeffs, args)

    return F, arg_sets
