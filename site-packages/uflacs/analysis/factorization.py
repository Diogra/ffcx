
from uflacs.utils.log import uflacs_assert
from ufl.classes import Terminal, Indexed, Grad, Restricted, Argument, Product, Sum, Division

def strip_modified_terminal(v):
    "Extract core Terminal from a modified terminal or return None."
    while not isinstance(v, Terminal):
        if isinstance(v, (Indexed, Grad, Restricted)):
            v = v.operands()[0]
        else:
            return None
    return v

def build_argument_component_sets(SV):
    "Build mapping {argument_count: {vertex_number: modified_terminal}} with all argument vertices."
    arg_sets = {}
    for i,v in enumerate(SV):
        a = strip_modified_terminal(v)
        if not isinstance(a, Argument):
            continue
        c = a.count()
        s = arg_sets.get(c)
        if s is None:
            s = {}
            arg_sets[c] = s
        s[i] = v
    return arg_sets

def build_valid_argument_combinations(arg_sets):
    "Build all valid permuations of argument products combinations."
    if not arg_sets:
        return set(), []
    counts = sorted(arg_sets.keys())
    arg_indices = set(arg_sets[counts[0]])
    arg_combos = [(i,) for i in sorted(arg_indices)]
    for c in counts[1:]:
        js = sorted(arg_sets[c])
        arg_indices.update(js)
        arg_combos = [comb + (j,) for comb in arg_combos for j in js]
    return arg_indices, arg_combos

def build_argument_dependencies(SV, dependencies, arg_indices):
    "Preliminary algorithm: build list of argument vertex indices each vertex (indirectly) depends on."
    A = [[] for i in range(len(SV))] # TODO: Use array
    for i,v in enumerate(SV):
        deps = dependencies[i]
        argdeps = []
        for j in deps:
            if j in arg_indices:
                argdeps.append(j)
            else:
                argdeps.extend(A[j])
        A[i] = sorted(argdeps)
    return A

def collect_argument_factors(SV, dependencies, arg_indices):
    "TODO:"
    # TODO: Instead of argdeps being a list of argument vertex indices v (indirectly) depends on,
    #       it should be a mapping { combo: factors } to handle e.g. (u + fu')(gv + v')

    # Reuse these empty objects where appropriate to save memory
    noargs = {}
    nocoeffs = [(),]

    F = [None]*len(SV) # TODO: Use array
    for i,v in enumerate(SV):
        deps = dependencies[i]

        if not len(deps):
            # v is a modified terminal... 
            if i in arg_indices:
                # ... a modified Argument
                argkey = (i,)
                factors = { argkey: nocoeffs }
            else:
                # ... a modified something else
                factors = noargs

        elif isinstance(v, Sum): # FIXME: Test test test!
            # Merge items in fac0 and fac1
            uflacs_assert(len(deps) == 2, "Assuming binary sum here. This can be fixed if needed.")
            fac0 = F[deps[0]]
            fac1 = F[deps[1]]
            uflacs_assert(len(fac0) == len(fac1), "Not expecting different argument factor status terms from summands.")

            # Format of facN = { argkey: [dep1tuple, dep2tuple] }
            factors = {}
            for argkey in fac0.iterkeys():
                # Concatenate coefficient factor tuple lists for this argument key,
                # e.g. f*v + g*v -> [(findex,)] + [(gindex,)] = [(findex,), (gindex,)]
                factors[argkey] = fac0[argkey] + fac1[argkey]

        elif isinstance(v, Product): # FIXME: Test test test!
            uflacs_assert(len(deps) == 2, "Assuming binary product here. This can be fixed if needed.")
            fac0 = F[deps[0]]
            fac1 = F[deps[1]]

            if not fac0 and not fac1:
                factors = noargs

            elif not fac0:
                # FIXME: Changed format of factors
                v0 = (deps[0],)
                factors = {}
                for k1,v1 in fac1.items():
                    argkey = k1
                    v = v1 + v0
                    factors[argkey] = v

            elif not fac1:
                # FIXME: Changed format of factors
                v1 = (deps[1],)
                factors = {}
                for k0,v0 in fac0.items():
                    argkey = k0
                    v = v0 + v1
                    factors[argkey] = v
            else:
                # FIXME: Changed format of factors
                factors = {}
                # For all permutations of items in fac0, fac1:
                for k0, v0 in fac0.items():
                    for k1, v1 in fac1.items():
                        # Concatenate both key and value tuples, collecting products factors
                        argkey = k0 + k1
                        v = v0 + v1
                        factors[argkey] = v

        elif isinstance(v, Division):
            # TODO: Handle v/f as v*(1/f), maybe by adding -index_of_f to factor list?
            notimplemented

        else:
            # TODO: Check
            notimplemented

        print 'fac:', i, factors
        F[i] = factors

    assert not noargs, "This dict was not supposed to be filled with anything!"

    return F

def compute_argument_factorization(SV, svs, dependencies):
    arg_sets = build_argument_component_sets(SV)

    arg_indices, valid_arg_combos = build_valid_argument_combinations(arg_sets)

    A = build_argument_dependencies(SV, dependencies, arg_indices)

    if 1:
        print 'SV:'
        print '\n'.join("%d: %s" % (i,v) for i,v in enumerate(SV))
        print 'svs:'
        print svs
        print 'dependencies:'
        print dependencies
        print 'arg_sets:'
        print '\n'.join(map(str,arg_sets.items()))
        print 'arg_indices:'
        print arg_indices
        print 'valid_arg_combos:'
        print valid_arg_combos
        print 'A:'
        print A

    F = collect_argument_factors(SV, dependencies, arg_indices)
    print 'F:'
    print F

    for j in svs:
        it = F[j]
        (k, v), = it.items()
        args   = " * ".join(str(SV[j]) for j in k)
        coeffs = " * ".join(str(SV[j]) for j in v)
        print "s_%d = (%s) * (%s)" % (j, coeffs, args)

    return F, arg_sets
