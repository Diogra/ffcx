
from ufl.classes import (Terminal, Grad, Indexed, FixedIndex,
                         Restricted, PositiveRestricted, NegativeRestricted,
                         FacetAvg, CellAvg,
                         Coefficient, Argument, GeometricQuantity)
from ufl.sorting import sorted_expr

from uflacs.utils.log import uflacs_assert, warning, error

# TODO: Add FacetAvg and CellAvg to modifiers everywhere relevant and handle in table extraction
# TODO: Make this more robust by looping like analyse_modified_terminal, currently assumes that transformations have been applied.
def is_modified_terminal(v):
    _accepted_types = (Terminal, Grad, Restricted, FacetAvg, CellAvg)
    return (isinstance(v, _accepted_types)
            or (isinstance(v, Indexed) and isinstance(v.operands()[0], _accepted_types)))

class ModifiedTerminal(object):
    def __init__(self, terminal, derivatives, averaged, restriction, component):
        self.terminal = terminal
        self.derivatives = derivatives
        self.averaged = averaged
        self.restriction = restriction
        self.component = component

terminal_modifier_types = (Grad, Restricted, Indexed, FacetAvg, CellAvg)
def analyse_modified_terminal2(o, form_argument_mapping={}):
    """Analyse a so-called 'modified terminal' expression and return its properties in more compact form.

    A modified terminal expression is:
    an object of a Terminal subtype,
    wrapped in 0-* Grad objects,
    wrapped in 0-1 Restricted object,
    wrapped in 0-1 Indexed object.

    The returned values are:

    (terminal, component, derivatives, restriction)

    # TODO: Explain the format of these values for future reference.
    """
    t = o
    component = None
    derivatives = []
    restriction = None
    averaged = None
    while not isinstance(t, Terminal):
        if not isinstance(t, terminal_modifier_types):
            error("Unexpected type %s object %s." % (type(t), repr(t)))

        if isinstance(t, Indexed):
            uflacs_assert(component is None, "Got twice indexed terminal.")
            t, i = t.operands()
            uflacs_assert(all(isinstance(j, FixedIndex) for j in i), "Expected only fixed indices.")
            component = [int(j) for j in i]

        elif isinstance(t, Grad):
            uflacs_assert(len(component), "Got gradient of terminal without prior indexing.")
            derivatives.append(component[-1])
            component = component[:-1]
            t, = t.operands()

        elif isinstance(t, Restricted):
            uflacs_assert(restriction is None, "Got twice restricted terminal!")
            restriction = t._side
            t, = t.operands()

        elif isinstance(t, CellAvg):
            uflacs_assert(averaged is None, "Got twice averaged terminal!")
            averaged = "cell"
            t, = t.operands()

        elif isinstance(t, FacetAvg):
            uflacs_assert(averaged is None, "Got twice averaged terminal!")
            averaged = "facet"
            t, = t.operands()

    t = form_argument_mapping.get(t,t)
    component = tuple(component) if component else ()
    derivatives = tuple(sorted(derivatives))

    uflacs_assert(len(component) == t.rank(),
                  "Length of component does not match rank of terminal.")
    uflacs_assert(all(c >= 0 and c < d for c,d in zip(component, t.shape())),
                  "Component indices %s are outside terminal shape %s" % (component, t.shape()))

    # FIXME: Return mt and update all callers, then use averaged state
    mt = ModifiedTerminal(t, derivatives, averaged, restriction, component)
    return mt

def analyse_modified_terminal(o, form_argument_mapping={}): # FIXME: Temporary wrapper to transition from tuple to mt struct
    mt = analyse_modified_terminal2(o, form_argument_mapping)
    return (mt.terminal, mt.component, mt.derivatives, mt.restriction)

class DependencyHandler2(object):
    """Class used to collect dependencies during early compilation stages."""
    def __init__(self, modified_terminals, cell,
                 form_argument_mapping=None, object_names=None):
        # Store cell TODO: Probably need domain later
        self.cell = cell

        # FIXME: A bit confused now, which objects are relabeled and which are not?
        # Mapping from original to relabeled form argument objects
        self.form_argument_mapping = form_argument_mapping or {}

        # Store object names, an id(obj) -> name mapping
        self.object_names = object_names or {}

        # FIXME: Start by building a new structure here, then use that instead of the below structures
        # FIXME: Split up in more data structures, typically need to iterate over geometry,
        #        coefficients, arguments separately in other places
        # FIXME: Change from tuple to struct of (t, c, d, r), then add avg
        # FIXME: Sort modified terminals in topological ordering w.r.t. their computational dependencies

        # ... New data structures:
        self.constant_geometry_data = []
        self.varying_geometry_data = []
        self.constant_coefficient_data = []
        self.varying_coefficient_data = []
        self.argument_data = []

        for o in sorted_expr(modified_terminals):
            # FIXME: Apply form_argument_mapping prior to getting here, then remove it here
            mt = analyse_modified_terminal2(o, form_argument_mapping)
            t = mt.terminal

            if isinstance(t, GeometricQuantity):
                if t.is_piecewise_constant():
                    self.constant_geometry_data.append(mt)
                else:
                    self.varying_geometry_data.append(mt)
            if isinstance(t, Coefficient):
                if t.is_piecewise_constant():
                    self.constant_coefficient_data.append(mt)
                else:
                    self.varying_coefficient_data.append(mt)
            elif isinstance(t, Argument):
                self.argument_data.append(mt)
            else:
                error("Unkonwn terminal type %s." % str(type(t)))

        # TODO: Sorting?
        #self.constant_geometry = sorted(self.constant_geometry, key=...)
        #self.varying_geometry = sorted(self.varying_geometry, key=...)

        self.constant_coefficient_data = sorted(self.constant_coefficient_data,
                                                key=lambda mt: (mt.terminal.count(),) + mt.key)
        self.varying_coefficient_data = sorted(self.varying_coefficient_data,
                                               key=lambda mt: (mt.terminal.count(),) + mt.key)
        self.argument_data = sorted(self.argument_data,
                                    key=lambda mt: (mt.terminal.count(),) + mt.key)

        # ...

class DependencyHandler(object):
    """Class used to collect dependencies during early compilation stages."""
    def __init__(self, modified_terminals, cell,
                 form_argument_mapping=None, object_names=None):
        # Store cell TODO: Probably need domain later
        self.cell = cell

        # FIXME: A bit confused now, which objects are relabeled and which are not?
        # Mapping from original to relabeled form argument objects
        self.form_argument_mapping = form_argument_mapping or {}

        # Store object names, an id(obj) -> name mapping
        self.object_names = object_names or {}

        # Analyse modified terminals and store data about them in a canonical ordering
        self.terminal_data = [analyse_modified_terminal(o, form_argument_mapping)
                              for o in sorted_expr(modified_terminals)]

        # Extract referenced functions without modifiers and duplicates and sort by count
        self.mapped_coefficients = sorted(set(td[0] for td in self.terminal_data
                                              if isinstance(td[0], Coefficient)),
                                              key=lambda x: x.count())
        self.mapped_arguments = sorted(set(td[0] for td in self.terminal_data
                                           if isinstance(td[0], Argument)),
                                           key=lambda x: x.count())

        # TODO: This is here to make the dolfin compiler work, improve somehow?
        self.coefficient_names = dict((c,"w%d" % i) for i,c in enumerate(self.mapped_coefficients))


        # TODO: Add averaging state to (c,d,r)
        # A mapping { expr: {(c,d,r): code} } used to record visited dependencies
        self.required = {}

    def require(self, o, component, derivatives, restriction, code):
        "Helper function for remembering modified terminal dependencies."

        # FIXME: Do we get mapped functions here?
        # FIXME: Check that we have this entry in terminal_data!
        # FIXME: Record which entries we do not have in terminal_data!

        reqdata = self.required.get(o)
        if reqdata is None:
            reqdata = {}
            self.required[o] = reqdata

        avg = None # FIXME: Take as input
        key = (tuple(component), tuple(derivatives), restriction)#, avg)
        oldcode = reqdata.get(key)
        uflacs_assert((not oldcode) or (oldcode == code),
                      "Generated different code for same expression.")
        reqdata[key] = code

        return code
