
from uflacs.utils.log import error
from uflacs.utils.assertions import uflacs_assert

import ufl
from ufl.algorithms.transformations import MultiFunction


class CppLiteralFormatter(object):
    "Formatting rules for literal constants."

    def constant_value(self, o):
        error("Missing rule for constant value type %s." % o._uflclass)

    def int_value(self, o):
        return "%d" % int(o)

    def float_value(self, o):
        # Using configurable precision parameter from ufl
        return ufl.constantvalue.format_float(float(o))

    def zero(self, o):
        return "0"


class CppArithmeticFormatter(object):
    "Formatting rules for arithmetic operations."

    def sum(self, o, *ops):
        return " + ".join(ops)

    def product(self, o, *ops):
        return " * ".join(ops)

    def division(self, o, a, b):
        return "%s / %s" % (a, b)


class CppCmathFormatter(object):
    "Formatting rules for <cmath> functions."

    def power(self, o, a, b):
        return "std::pow(%s, %s)" % (a, b)

    def sqrt(self, o, op):
        return "std::sqrt(%s)" % (op,)

    def ln(self, o, op):
        return "std::log(%s)" % (op,)

    def exp(self, o, op):
        return "std::exp(%s)" % (op,)

    def abs(self, o, op):
        return "std::abs(%s)" % (op,)

    def cos(self, o, op):
        return "std::cos(%s)" % (op,)

    def sin(self, o, op):
        return "std::sin(%s)" % (op,)

    def tan(self, o, op):
        return "std::tan(%s)" % (op,)

    def acos(self, o, op):
        return "std::acos(%s)" % (op,)

    def asin(self, o, op):
        return "std::asin(%s)" % (op,)

    def atan(self, o, op):
        return "std::atan(%s)" % (op,)


class CppConditionalFormatter(object):
    "Formatting rules for conditional expressions."

    def conditional(self, o, c, t, f):
        return "%s ? %s: %s" % (c, t, f)

    def eq(self, o, a, b):
        return " == ".join((a, b))

    def ne(self, o, a, b):
        return " != ".join((a, b))

    def le(self, o, a, b):
        return " <= ".join((a, b))

    def ge(self, o, a, b):
        return " >= ".join((a, b))

    def lt(self, o, a, b):
        return " < ".join((a, b))

    def gt(self, o, a, b):
        return " > ".join((a, b))

    def and_condition(self, o, a, b):
        return " && ".join((a, b))

    def or_condition(self, o, a, b):
        return " || ".join((a, b))

    def not_condition(self, o, a):
        return "!%s" % a


class CppLiftingFormatter(object):
    "Not sure how to handle this or whether it makes sense to have a formatter for it."

    def lifting_result(self, o, *ops):
        raise NotImplemented

    def lifting_operator_result(self, o, *ops):
        raise NotImplemented

    def lifting_function_result(self, o, *ops):
        raise NotImplemented

    def lifting_operator(self, o, *ops):
        raise NotImplemented

    def lifting_function(self, o, *ops):
        raise NotImplemented


class CppFormatterErrorRules(object):
    "Error rules catching groups of missing types by their superclasses."

    def expr(self, o):
        error("Missing C formatting rule for expr type %s." % o._uflclass)

    def terminal(self, o):
        error("Missing C formatting rule for terminal type %s." % o._uflclass)

    def variable(self, o, *ops):
        error("Should strip away variables before formatting C code.")
        return ops[0] # or just do this if necessary

    def geometric_quantity(self, o, component=(), derivatives=(), restriction=None):
        error("Missing C formatting rule for geometric quantity type %s." % o._uflclass)

    def algebra_operator(self, o, *ops):
        error("Missing rule for algebra operator type %s." % o._uflclass)

    def index_sum(self, o, *ops):
        error("Found an IndexSum, this should be handled before code formatting.")

    def wrapper_type(self, o, *ops):
        error("Found a %s, this should be handled before code formatting." % o._uflclass)

    def compound_tensor_operator(self, o, *ops):
        error("Found a %s, have you forgot to apply expand_compounds?" % o._uflclass)

    def indexed(self, o):
        error("Not expecting an indexed.")

    def derivative(self, o):
        error("Not expecting a derivative.")

    def restricted(self, o):
        error("Not expecting a restriction.")


class CppFormatterRules(MultiFunction,
                        CppFormatterErrorRules,
                        CppLiteralFormatter,
                        CppArithmeticFormatter,
                        CppCmathFormatter,
                        CppConditionalFormatter,
                        CppLiftingFormatter):
    """Base class for target specific cpp formatter class.
    See CppTestFormatter for example of how to specialise
    for a particular target. Remember to call the constructor
    of this class from your subclass."""

    def __init__(self, target_formatter=None):
        MultiFunction.__init__(self)
        self.target_formatter = target_formatter

    # Redirect geometric quantities to target formatter:

    def spatial_coordinate(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.spatial_coordinate(o, component, derivatives, restriction)

    def facet_normal(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.facet_normal(o, component, derivatives, restriction)

    def cell_volume(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.cell_volume(o, component, derivatives, restriction)

    def circumradius(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.circumradius(o, component, derivatives, restriction)

    # Redirect form arguments to target formatter:

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.coefficient(o, component, derivatives, restriction)

    def argument(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.argument(o, component, derivatives, restriction)
