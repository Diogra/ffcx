
from uflacs.utils.log import error
from uflacs.utils.assertions import uflacs_assert

import ufl
from ufl.algorithms.transformations import MultiFunction


class CppLiteralFormatter(object):
    "Formatting rules for literal constants."

    def constant_value(self, o):
        error("Missing rule for constant value type %s." % o._uflclass)

    def int_value(self, o):
        return "%d" % int(o)

    def float_value(self, o):
        # Using configurable precision parameter from ufl
        return ufl.constantvalue.format_float(float(o))

    def zero(self, o):
        return "0"


class CppArithmeticFormatter(object):
    "Formatting rules for arithmetic operations."

    def sum(self, o, *ops):
        return " + ".join(ops)

    def product(self, o, *ops):
        return " * ".join(ops)

    def division(self, o, a, b):
        return "%s / %s" % (a, b)


class CppCmathFormatter(object):
    "Formatting rules for <cmath> functions."

    def power(self, o, a, b):
        return "std::pow(%s, %s)" % (a, b)

    def sqrt(self, o, op):
        return "std::sqrt(%s)" % (op,)

    def ln(self, o, op):
        return "std::log(%s)" % (op,)

    def exp(self, o, op):
        return "std::exp(%s)" % (op,)

    def abs(self, o, op):
        return "std::abs(%s)" % (op,)

    def cos(self, o, op):
        return "std::cos(%s)" % (op,)

    def sin(self, o, op):
        return "std::sin(%s)" % (op,)

    def tan(self, o, op):
        return "std::tan(%s)" % (op,)

    def acos(self, o, op):
        return "std::acos(%s)" % (op,)

    def asin(self, o, op):
        return "std::asin(%s)" % (op,)

    def atan(self, o, op):
        return "std::atan(%s)" % (op,)


class CppConditionalFormatter(object):
    "Formatting rules for conditional expressions."

    def conditional(self, o, c, t, f):
        return "%s ? %s: %s" % (c, t, f)

    def eq(self, o, a, b):
        return " == ".join((a, b))

    def ne(self, o, a, b):
        return " != ".join((a, b))

    def le(self, o, a, b):
        return " <= ".join((a, b))

    def ge(self, o, a, b):
        return " >= ".join((a, b))

    def lt(self, o, a, b):
        return " < ".join((a, b))

    def gt(self, o, a, b):
        return " > ".join((a, b))

    def and_condition(self, o, a, b):
        return " && ".join((a, b))

    def or_condition(self, o, a, b):
        return " || ".join((a, b))

    def not_condition(self, o, a):
        return "!%s" % a


class CppLiftingFormatter(object):
    "Not sure how to handle this or whether it makes sense to have a formatter for it."

    def lifting_result(self, o, *ops):
        raise NotImplemented

    def lifting_operator_result(self, o, *ops):
        raise NotImplemented

    def lifting_function_result(self, o, *ops):
        raise NotImplemented

    def lifting_operator(self, o, *ops):
        raise NotImplemented

    def lifting_function(self, o, *ops):
        raise NotImplemented


class CppFormatterErrorRules(object):
    "Error rules catching groups of missing types by their superclasses."

    def expr(self, o):
        error("Missing C formatting rule for expr type %s." % o._uflclass)

    def terminal(self, o):
        error("Missing C formatting rule for terminal type %s." % o._uflclass)

    def variable(self, o, *ops):
        error("Should strip away variables before formatting C code.")
        return ops[0] # or just do this if necessary

    def geometric_quantity(self, o, component=(), derivatives=(), restriction=None):
        error("Missing C formatting rule for geometric quantity type %s." % o._uflclass)

    def algebra_operator(self, o, *ops):
        error("Missing rule for algebra operator type %s." % o._uflclass)

    def index_sum(self, o, *ops):
        error("Found an IndexSum, this should be handled before code formatting.")

    def wrapper_type(self, o, *ops):
        error("Found a %s, this should be handled before code formatting." % o._uflclass)

    def compound_tensor_operator(self, o, *ops):
        error("Found a %s, have you forgot to apply expand_compounds?" % o._uflclass)

    def derivative(self, o, *ops):
        error("Found a %s, have you forgot to apply expand_derivatives?" % o._uflclass)


class CppFormatterRules(MultiFunction,
                        CppFormatterErrorRules,
                        CppLiteralFormatter,
                        CppArithmeticFormatter,
                        CppCmathFormatter,
                        CppConditionalFormatter,
                        CppLiftingFormatter):
    """Base class for target specific cpp formatter class.
    See CppTestFormatter for example of how to specialise
    for a particular target. Remember to call the constructor
    of this class from your subclass."""

    def __init__(self, target_formatter=None):
        MultiFunction.__init__(self)
        self.target_formatter = target_formatter

    # Redirect geometric quantities and form arguments to target formatter:

    def spatial_coordinate(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.spatial_coordinate(o, component, derivatives, restriction)

    def facet_normal(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.facet_normal(o, component, derivatives, restriction)

    def cell_volume(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.cell_volume(o, component, derivatives, restriction)

    def circumradius(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.circumradius(o, component, derivatives, restriction)

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.coefficient(o, component, derivatives, restriction)

    def argument(self, o, component=(), derivatives=(), restriction=None):
        return self.target_formatter.argument(o, component, derivatives, restriction)


class CppDefaultFormatter(object):
    """Example cpp formatter class, used for the test cases.
    Override the same functions for your particular target."""
    def __init__(self):
        self.required = {}

    def require(self, o, component, derivatives, restriction, code):
        s = self.required.get(o) or {}

        key = (tuple(component), tuple(derivatives))
        oldcode = s.get(key)
        uflacs_assert((not oldcode) or (oldcode == code),
                      "Generated different code for same expression.")
        s[key] = code

        self.required[o] = s
        return code

    def spatial_coordinate(self, o, component=(), derivatives=(), restriction=None):
        if len(derivatives) > 1:
            return "0"

        # Restriction has no effect on x
        #postfix = {None:"", "+": "_p", "-": "_m"}[restriction]

        if component:
            i, = component
        else:
            i = 0

        if derivatives:
            d, = derivatives
            return "1" if i == d else "0"
        else:
            code = "x[%d]" % i
            self.require(o, component, derivatives, restriction, code)
            return code

    def facet_normal(self, o, component=(), derivatives=(), restriction=None):
        if derivatives:
            return "0"

        postfix = {None:"", "+": "_p", "-": "_m"}[restriction]

        if component:
            i, = component
        else:
            i = 0

        code = "n%s[%d]" % (postfix, i)

        self.require(o, component, derivatives, restriction, code)
        return code

    def cell_volume(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(not component, "Expecting no component for scalar value.")

        if derivatives:
            return "0"

        postfix = {None:"", "+": "_p", "-": "_m"}[restriction]

        code = "K_vol" + postfix

        self.require(o, component, derivatives, restriction, code)
        return code

    def circumradius(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(not component, "Expecting no component for scalar value.")

        if derivatives:
            warning("Compiler should be able to remove derivatives of constants!")
            return "0"

        postfix = {None:"", "+": "_p", "-": "_m"}[restriction]

        code = "K_rad" + postfix

        self.require(o, component, derivatives, restriction, code)
        return code

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, have you preprocessed the expression?")
        return self.form_argument(o, component, derivatives, restriction,
                                  'w%d' % o.count())

    def argument(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, have you preprocessed the expression?")
        return self.form_argument(o, component, derivatives, restriction,
                                  'v%d' % o.count())

    def form_argument(self, o, component, derivatives, restriction, common_name):
        postfix = {None:"", "+": "_p", "-": "_m"}[restriction]
        base_name = common_name + postfix

        if derivatives:
            code = 'd%d_%s' % (len(derivatives), base_name)
            code += "".join("[%d]" % d for d in derivatives)
        else:
            code = base_name

        if component: # TODO: Or should we use a flat array?
            code += "".join("[%d]" % c for c in component)

        self.require(o, component, derivatives, restriction, code)
        return code
