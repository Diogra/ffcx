from uflacs.utils.assertions import uflacs_assert
from uflacs.utils.log import warning

class CppDefaultFormatter(object):
    """Example cpp formatter class, used for the test cases.
    Override the same functions for your particular target."""
    def __init__(self):
        self.required = {}
        self.form_argument_numbering = {}

    def require(self, o, component, derivatives, restriction, code):
        s = self.required.get(o) or {}

        key = (tuple(component), tuple(derivatives))
        oldcode = s.get(key)
        uflacs_assert((not oldcode) or (oldcode == code),
                      "Generated different code for same expression.")
        s[key] = code

        self.required[o] = s
        return code

    def spatial_coordinate(self, o, component=(), derivatives=(), restriction=None):
        if len(derivatives) > 1:
            warning("Compiler should be able to simplify derivatives of x!")
            return "0"

        # Restriction has no effect on x
        #postfix = {None:"", "+": "_p", "-": "_m"}[restriction]

        if component:
            i, = component
        else:
            i = 0

        if derivatives:
            warning("Compiler should be able to simplify derivatives of x!")
            d, = derivatives
            return "1" if i == d else "0"
        else:
            code = "x[%d]" % i
            self.require(o, component, derivatives, restriction, code)
            return code

    def facet_normal(self, o, component=(), derivatives=(), restriction=None):
        if derivatives:
            warning("Compiler should be able to simplify derivatives of constants!")
            return "0"

        postfix = {None:"", "+": "_p", "-": "_m"}[restriction]

        if component:
            i, = component
        else:
            i = 0

        code = "n%s[%d]" % (postfix, i)

        self.require(o, component, derivatives, restriction, code)
        return code

    def cell_volume(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(not component, "Expecting no component for scalar value.")

        if derivatives:
            warning("Compiler should be able to simplify derivatives of constants!")
            return "0"

        postfix = {None:"", "+": "_p", "-": "_m"}[restriction]

        code = "K_vol" + postfix

        self.require(o, component, derivatives, restriction, code)
        return code

    def circumradius(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(not component, "Expecting no component for scalar value.")

        if derivatives:
            warning("Compiler should be able to simplify derivatives of constants!")
            return "0"

        postfix = {None:"", "+": "_p", "-": "_m"}[restriction]

        code = "K_rad" + postfix

        self.require(o, component, derivatives, restriction, code)
        return code

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        return self.form_argument(o, component, derivatives, restriction, 'w%d')

    def argument(self, o, component=(), derivatives=(), restriction=None):
        return self.form_argument(o, component, derivatives, restriction, 'v%d')

    def form_argument(self, o, component, derivatives, restriction, common_name):
        count = self.form_argument_numbering.get(o, o.count())
        uflacs_assert(count >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        postfix = {None:"", "+": "_p", "-": "_m"}[restriction]
        base_name = (common_name % (count,)) + postfix

        if derivatives:
            code = 'd%d_%s' % (len(derivatives), base_name)
            code += "".join("[%d]" % d for d in derivatives)
        else:
            code = base_name

        if component: # TODO: Or should we use a flat array?
            code += "".join("[%d]" % c for c in component)

        self.require(o, component, derivatives, restriction, code)
        return code
