from uflacs.utils.assertions import uflacs_assert
from uflacs.utils.log import warning

from ufl.classes import (Terminal, Indexed, Grad,
                         Restricted, PositiveRestricted, NegativeRestricted,
                         Coefficient, Argument,
                         GeometricQuantity, SpatialCoordinate,
                         FacetNormal, FacetArea,
                         CellVolume, CellSurfaceArea, FacetArea, Circumradius)

def analyse_terminalish(o):
    t = o
    ngrads = 0
    r = ""
    while not isinstance(t, Terminal):
        if isinstance(t, Grad):
            t, = t.operands()
            ngrads += 1
        elif isinstance(t, Restricted):
            t, = t.operands()
            assert r == ""
            r = t._side
        else:
            error("Unexpected %s." % t)
    return (t, ngrads, r)

class DefaultFormatterDependencyHandler(object):
    def __init__(self, object_names=None):
        # Mappings providing names of objects
        self.object_names = object_names or {}
        self.coefficient_names = {}
        self.argument_names = {}

        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        self.required = {}

        # Lists used to store terminal objects visited
        self.terminals = []
        self.coefficients = []
        self.arguments = []

    def require(self, o, component, derivatives, restriction, code):
        "Helper function for remembering terminal-ish dependencies."

        s = self.required.get(o) or {}

        key = (tuple(component), tuple(derivatives), restriction)
        oldcode = s.get(key)
        uflacs_assert((not oldcode) or (oldcode == code),
                      "Generated different code for same expression.")
        s[key] = code

        self.required[o] = s
        return code

    def update_terminals(self, terminals):
        "Callback for updating set of terminals from inside compiler algorithm."

        # Store terminals in a stable sorting
        self.terminals = sorted(terminals, key=lambda x: repr(x))

        # Extract functions
        coefficients = set()
        arguments = set()
        for o in terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient):
                coefficients.add(t)
            elif isinstance(t, Argument):
                arguments.add(t)
        self.coefficients = sorted(coefficients, key=lambda x: x.count())
        self.arguments = sorted(arguments, key=lambda x: x.count())

        # Number and name functions, each coefficient name becomes a member name:
        for i, c in enumerate(self.coefficients):
            default = "w%d" % i
            self.coefficient_names[c] = self.object_names.get(id(c), default)

        for i, c in enumerate(self.arguments):
            default = "v%d" % i
            self.argument_names[c] = self.object_names.get(id(c), default)

class CppDefaultStatementFormatter(DefaultFormatterDependencyHandler):
    def __init__(self, object_names):
        DefaultFormatterDependencyHandler.__init__(self, object_names)

    # --- Functions for generating definitions and other statements

    def define_registers(self, num_registers):
        return ['double s[%d];' % (num_registers,)]

    def define_quadrature_for_loop(self, points=None, weights=None):
        code = []
        if points is not None and weights is not None:
            # This should be sufficient for most uses
            n = len(points)
            d = len(points[0])
            psep = ", " # Could add a newline here
            pstr = psep.join("{ %s }" % (", ".join("%g"%x for x in p),) for p in points)
            wstr = ", ".join("%g"%w for w in weights)
            code += ["const int num_quadrature_points = %d;" % n]
            code += ["const double quadrature_points[%d][%d] = { %s };" % (n, d, pstr)]
            code += ["const double quadrature_weights[%d] = { %s };" % (n, wstr)]
        else:
            pass # Just assume above variables are defined already
        code += ["for (int iq=0; iq<num_quadrature_points; ++iq)"]
        return code

    def define_quadrature_loop_vars(self):
        # This should be sufficient for most uses
        code = []
        code += ["const double *x = quadrature_points[iq];"]
        code += ["const double qw = quadrature_weights[iq];"]
        return code

    def integration_scaling_factor(self):
        return "D"

    def define_argument_for_loop(self, argument_count):
        iname = "i%d" % (argument_count,)
        isize = "n%d" % (argument_count,)
        return "for (int %s = 0; %s < %s; ++%s)" % (iname, iname, isize, iname)

    def define_argument_loop_vars(self, argument_count):
        return ["// Compute argument %d and evt. its derivatives" % (argument_count,)]

    def output_variable_names(self, num_variables):
        return ["A[%d]" % (i,) for i in xrange(num_variables)]

# FIXME: This is probably implemented somewhere else
def flatten_component(component, shape, symmetry=None):
    n = len(component)
    if n == 0:
        return 0
    elif n == 1:
        return component[0]
    else:
        uflacs_error("FIXME: Use shape, use symmetry!")

class CppDefaultGeometryFormatter(object):
    """Example cpp formatter class, used for the test cases.
    Override the same functions for your particular target."""
    def __init__(self, cellcg):
        if cellcg is None:
            from uflacs.geometry.cellcodegen import CellGeometryNames
            cellcg = CellGeometryNames() # FIXME: This design is a bit messy, e.g. missing restriction argument here
        self._cellcg = cellcg

    def define_piecewise_geometry(self):
        lines = ["// Compute piecewise constant geometry and coeffs in DG0 and R:"]

        # FIXME: Delegate this computation to cellcg!
        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        for expr, req in self.required.iteritems():
            if isinstance(expr, GeometricQuantity) and expr.is_cellwise_constant():
                for (c,d,r), code in req.iteritems():
                    impl = ["// TODO: Implement %s" % code]
                    lines += impl

        lines += [""]
        return lines

    def define_x_dependent_geometry(self):
        lines = ["// Compute x dependent geometry"]

        # FIXME: Delegate this computation to cellcg!
        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        for expr, req in self.required.iteritems():
            if isinstance(expr, GeometricQuantity) and not expr.is_cellwise_constant():
                for (c,d,r), code in req.iteritems():
                    impl = ["// TODO: Implement %s" % code]
                    lines += impl

        lines += [""]
        return lines

    def _piecewise_constant_geometry(self, o, component, derivatives, restriction, name, never_scalar=False):
        uflacs_assert(not derivatives, "Compiler should be able to simplify derivatives of x.")
        sh = o.shape()
        if sh or never_scalar:
            code = "%s[%d]" % (name, flatten_component(component, sh, None))
        else:
            code = name
        self.require(o, component, derivatives, restriction, code)
        return code

    def spatial_coordinate(self, o, component=(), derivatives=(), restriction=None):
        return self._piecewise_constant_geometry(o, component, derivatives, restriction,
                                                 self._cellcg.x(),
                                                 never_scalar=True) # Force [0] for scalar

    def cell_volume(self, o, component=(), derivatives=(), restriction=None):
        return self._piecewise_constant_geometry(o, component, derivatives, restriction,
                                                 self._cellcg.cell_volume())

    def circumradius(self, o, component=(), derivatives=(), restriction=None):
        return self._piecewise_constant_geometry(o, component, derivatives, restriction,
                                                 self._cellcg.circumradius())

    def cell_surface_area(self, o, component=(), derivatives=(), restriction=None):
        return self._piecewise_constant_geometry(o, component, derivatives, restriction,
                                                 self._cellcg.cell_surface_area())

    def facet_area(self, o, component=(), derivatives=(), restriction=None):
        return self._piecewise_constant_geometry(o, component, derivatives, restriction,
                                                 self._cellcg.facet_area())

    def facet_normal(self, o, component=(), derivatives=(), restriction=None):
        return self._piecewise_constant_geometry(o, component, derivatives, restriction,
                                                 self._cellcg.facet_normal())

class CppDefaultFormArgumentFormatter(object):
    """Example cpp formatter class, used for the test cases.
    Override the same functions for your particular target."""
    def __init__(self):
        # A FormArgument:FormArgument mapping to override
        # counts and elements of functions without rebuilding integrand
        self.form_argument_mapping = {}

    def define_piecewise_coefficients(self):
        return ["// Coefficients in DG0 and R are just fetched directly from ufc array w[][]", ""]

    def define_x_dependent_coefficients(self):
        return ["// Compute x dependent coefficients and evt. their derivatives"]

    def _piecewise_constant_coefficient(self, o, component, derivatives, restriction):
        uflacs_assert(not derivatives, "Compiler should be able to simplify derivatives of constant coefficients!")
        uflacs_assert(not restriction, "Not yet handling restriction of coefficients!")
        comp = flatten_component(component, o.shape(), o.element().symmetry())
        o = self.form_argument_mapping.get(o, o)
        return "w[%d][%d]" % (o.count(), comp)

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        if o.is_cellwise_constant():
            return self._piecewise_constant_coefficient(o, component, derivatives, restriction)
        else:
            return self.form_argument(o, component, derivatives, restriction, 'w%d')

    def argument(self, o, component=(), derivatives=(), restriction=None):
        return self.form_argument(o, component, derivatives, restriction, 'v%d')

    def form_argument(self, o, component, derivatives, restriction, common_name):
        o = self.form_argument_mapping.get(o, o)
        count = o.count()
        uflacs_assert(count >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        base_name = (common_name % (count,))

        rcode = {None:"", "+": "_p", "-": "_m"}[restriction]

        def indstring(indices):
            # FIXME: Indexing flat or nested in C++?
            if 1:
                return "".join("[%s]" % i for i in indices)
            else:
                return ("[%s]" % (", ".join(map(str,indices))))

        if derivatives:
            dcodepre  = 'd%d_' % (len(derivatives),)
            dcodepost = indstring(derivatives)
        else:
            dcodepre, dcodepost = "", ""

        if component:
            icode = indstring(component)
        else:
            icode = ""

        code = dcodepre + base_name + rcode + icode + dcodepost

        self.require(o, component, derivatives, restriction, code)
        return code

class CppDefaultFormatter(CppDefaultStatementFormatter,
                          CppDefaultGeometryFormatter,
                          CppDefaultFormArgumentFormatter):
    """Example cpp formatter class, used for the test cases.
    Override the same functions for your particular target."""
    def __init__(self, object_names=None, cellcg=None):
        CppDefaultStatementFormatter.__init__(self, object_names)
        CppDefaultGeometryFormatter.__init__(self, cellcg)
        CppDefaultFormArgumentFormatter.__init__(self)
