from uflacs.utils.assertions import uflacs_assert
from uflacs.utils.log import warning, error

from ufl.classes import (Terminal, Indexed, Grad,
                         Restricted, PositiveRestricted, NegativeRestricted,
                         Coefficient, Argument,
                         GeometricQuantity, SpatialCoordinate,
                         FacetNormal, FacetArea,
                         CellVolume, CellSurfaceArea, FacetArea, Circumradius)

from uflacs.codeutils.cpp_format import CppFormatterRulesCollection

from uflacs.geometry.generate_geometry_snippets import (
    generate_jacobian_snippets,
    generate_jacobian_inverse_snippets,
    generate_x_from_xi_snippets,
    generate_xi_from_x_snippets)

# FIXME: This is probably implemented somewhere else
def flatten_component(component, shape, symmetry=None):
    assert not symmetry, "Not implemented"
    n = len(component)
    if n == 0:
        return 0
    elif n == 1:
        return component[0]
    else:
        # FIXME: Test this, or just use other existing implementation
        c = 0
        stride = 1
        for i in range(n):
            c += component[n-1-i]*stride
            if i < n-1:
                stride *= shape[n-1-i]
        return c

# FIXME: This is probably implemented somewhere else
def component_value_size(shape, symmetry=None):
    assert not symmetry, "Not implemented"
    n = len(shape)
    if n == 0:
        return 0
    elif n == 1:
        return shape[0]
    else:
        return product(shape)

def analyse_terminalish(o):
    t = o
    ngrads = 0
    r = ""
    # FIXME: Allow Indexed? Need to identify dependencies on e.g. v[:] vs only v[1].
    while not isinstance(t, Terminal):
        if isinstance(t, Grad):
            ngrads += 1
            t, = t.operands()
        elif isinstance(t, Restricted):
            assert r == ""
            r = t._side
            t, = t.operands()
        else:
            error("Unexpected type %s object %s." % (type(t), repr(t)))
    return (t, ngrads, r)


class DependencyHandler(object):
    """Class used to collect dependencies during early compilation stages."""
    def __init__(self, object_names=None, form_argument_mapping=None):
        # FIXME: A bit confused now, which objects are relabeled and which are not?

        # Mappings providing names of objects
        self.object_names = object_names or {}
        self.coefficient_names = {}
        self.argument_names = {}

        # Mapping from original to relabeled form argument objects
        self.form_argument_mapping = form_argument_mapping or {}

        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        self.required = {}

        # Lists used to store terminal objects visited
        self.terminals = []
        self.coefficients = []
        self.arguments = []

    def require(self, o, component, derivatives, restriction, code):
        "Helper function for remembering terminal-ish dependencies."

        s = self.required.get(o) or {}

        key = (tuple(component), tuple(derivatives), restriction)
        oldcode = s.get(key)
        uflacs_assert((not oldcode) or (oldcode == code),
                      "Generated different code for same expression.")
        s[key] = code

        self.required[o] = s
        return code

    def update_terminals(self, terminals):
        "Callback for updating set of terminals from inside compiler algorithm."

        # Store terminals in a stable sorting
        self.terminals = sorted(terminals, key=lambda x: repr(x)) # FIXME: Use ufl sorting
        self.terminal_data = [analyse_terminalish(o) for o in self.terminals]

        # Extract functions without modifiers and duplicates,
        # e.g. both grad(f) and f can occur among terminals:
        coefficients = set(td[0] for td in self.terminal_data
                           if isinstance(td[0], Coefficient))
        arguments = set(td[0] for td in self.terminal_data
                        if isinstance(td[0], Argument))

        # Store functions in a stable sorting
        self.coefficients = sorted(coefficients, key=lambda x: x.count())
        self.arguments = sorted(arguments, key=lambda x: x.count())

        # Number and name functions, each coefficient name becomes a member name:
        for i, c in enumerate(self.coefficients):
            default = "w%d" % i
            self.coefficient_names[c] = self.object_names.get(id(c), default)

        for i, c in enumerate(self.arguments):
            default = "v%d" % i
            self.argument_names[c] = self.object_names.get(id(c), default)


class CppStatementFormatter(object):
    """Class containing functions for generating definitions of registers,
    argument loops, and output variable names."""
    def __init__(self, dependency_handler, cell):
        self._dependency_handler = dependency_handler
        self._cell = cell

        # FIXME: Make parameters:
        self._enable_accumulation = True
        self._enable_coord_loop = True # False for vertex point integral
        self._points_are_local = True # False for multiple point integral
        self._num_points_name = "num_points"
        self._points_name = "points"
        self._weights_name = "weights"

    def define_registers(self, num_registers, partition=None): # Partition is not yet used by compiler
        code = ["// Declaring variables for intermediate computations:"]

        name = "s" if partition is None else ("s%d" % partition)
        code += ["double %s[%d];" % (name, num_registers)]

        code.append("")
        return code

    def define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # TODO: Build this from terminal data and dependency dict
        needed = {
            "J": ("",),
            "detJ": ("",),
            "K": ("",),
            }

        # Generate code in fixed ordering
        for r in needed.get("J", ()):
            code.extend(generate_jacobian_snippets(self._cell, r))
        # TODO: Separate detJ computation
        for r in needed.get("K", ()):
            code.extend(generate_jacobian_inverse_snippets(self._cell, r))

        # TODO: Add all cell geometry stuff here, cell volume etc.
        #for r in needed.get("volume", ()):
        #    code.extend(generate_volume_snippets(self._cell, r))
        #for r in needed.get("circumradius", ()):
        #    code.extend(generate_circumradius_snippets(self._cell, r))

        code.append("")
        return code

    def _define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # A dependency graph like this might be a way to
        # automatically figure out which quantities to generate?
        dependencies = {
            "J": ("vertex_coordinates",),
            "detJ": ("J",),
            "K": ("J","detJ"),
            "x": ("xi", "J", "vertex_coordinates"),
            "xi": ("x", "K", "vertex_coordinates"),
            }
        geometric_quantity_name = str

        # Get the set of all geometry we need
        needed = set()
        for (t, ngrads, r) in self._dependency_handler.terminal_data:
            if isinstance(t, GeometricQuantity):
                uflacs_assert(ngrads == 0, "Derivatives of geometry not supported.")
                needed.add((geometric_quantity_name(t), r))

        # Make an intermediate stable but arbitrary sorting
        workstack = sorted(needed)

        # Make a set of already known quantities
        done = set()
        done.add("vertex_coordinates")

        # Make a set of quantities to postphone
        skip = set(item for item in workstack if item[0] in ("x","xi"))
        # ... but keep these in workstack to build dependencies properly!

        # Build list of geometry including dependencies
        ordered = []
        while workstack:
            # Get next item to do
            item = workstack.pop(0)
            # Drop it if already done
            if item in done:
                continue
            # Get dependencies of item that are not done
            deps = [(d, r) for d in dependencies[item[0]]
                    if (d, r) not in done]
            if deps:
                # If we have any dependencies, put them first on the stack
                workstack = deps + [item] + workstack
            else:
                # If we have no dependencies, do this item next,
                # unless it's postphoned
                if item not in skip:
                    ordered.append(item)

        # Finally we can generate some code
        for name, restriction in ordered:
            code.append("// TODO: Compute %s%s here" % (name, restriction))

        code.append("")
        return code

    def old_define_piecewise_geometry(self):
        code = ["// Compute piecewise constant geometry:"]

        # FIXME: Delegate this computation to cellcg!
        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        for expr, req in self._dependency_handler.required.iteritems():
            #key = (tuple(component), tuple(derivatives), restriction)
            if isinstance(expr, GeometricQuantity) and expr.is_cellwise_constant():
                for (c,d,r), code in req.iteritems():
                    impl = ["// TODO: Implement %s" % code]
                    code += impl

        code.append("")
        return code

    def define_coord_loop(self):
        if self._enable_coord_loop:
            code = ["",
                    "// Loop over coordinates",
                    "for (int iq=0; iq<%s; ++iq)" % self._num_points_name]
            return code
        else:
            return None

    def define_coord_vars(self):
        code = ["// Computing coordinates in necessary coordinate systems:"]

        # TODO: Parameter to pick behaviour here:
        # For dx, we need xi -> x
        # For ds, we need xi_facet -> xi -> x
        # For dS, we need xi_facet -> xi0,xi1 -> x0,x1
        # For dP(points), we need x -> xi
        # For dP(vertex), we need
        #   x = &vertex_coordinates[vertex*gd]; # TODO: Assumption on ordering of vertices?
        #   xi = &reference_vertex_coordinates[vertex*gd]

        if self._points_are_local:
            # cell integral
            code += ["const double *xi = &%s[%d*iq];" % (
                self._points_name, self._cell.topological_dimension())]
            # TODO: Restrictions
            code.extend(generate_x_from_xi_snippets(self._cell, ""))
        else:
            # multiple point evaluation
            code += ["const double *x = &%s[%d*iq];" % (
                self._points_name, self._cell.geometric_dimension())]
            # TODO: Restrictions
            code.extend(generate_xi_from_x_snippets(self._cell, ""))

        # Define weights
        if self._enable_accumulation:
            code += ["", "// Compute accumulation weight:"]
            code += ["const double qw = %s[iq];" % (self._weights_name,)]
            # TODO: Use correct name for 'det', depending on integral type?
            code += ["const double D = qw * std::abs(detJ);"] # TODO: Store absolute value?

        code += [""]
        return code

    def define_coord_dependent_geometry(self):
        code = ["// Compute x dependent geometry"]

        # FIXME: Delegate this computation to cellcg!
        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        for expr, req in self._dependency_handler.required.iteritems():
            if isinstance(expr, GeometricQuantity) and not expr.is_cellwise_constant():
                for (c,d,r), expr_code in req.iteritems():
                    impl = ["// TODO: Implement %s" % expr_code]
                    code += impl

        code += [""]
        return code

    def accumulation_scaling_factor(self):
        if self._enable_accumulation:
            return "D"
        else:
            return None

    def define_piecewise_coefficients(self):
        dh = self._dependency_handler
        code = ["// %s = w[%d][:]" % (dh.coefficient_names[c], i)
                for i, c in enumerate(dh.coefficients)
                if c.is_cellwise_constant()]
        if code:
            return ["// These constant coefficients are fetched directly from dof array w[][]:"] + code + [""]
        else:
            return []

    def define_coord_dependent_coefficients(self):
        return ["// Compute x dependent coefficients and evt. their derivatives"]

    def define_argument_for_loop(self, argument_count):
        iname = "i%d" % (argument_count,)
        isize = "n%d" % (argument_count,)
        return "for (int %s = 0; %s < %s; ++%s)" % (iname, iname, isize, iname)

    def define_argument_loop_vars(self, argument_count):
        return ["// Compute argument %d and evt. its derivatives" % (argument_count,)]

    def output_variable_names(self, num_variables):
        return ["A[%d]" % (i,) for i in xrange(num_variables)]



from ufl.algorithms import MultiFunction
class CppLanguageFormatter(MultiFunction, CppFormatterRulesCollection):
    """Example cpp formatter class, used for the test cases.
    Override the same functions for your particular target."""
    def __init__(self, dependency_handler, form_argument_mapping):
        MultiFunction.__init__(self)
        CppFormatterRulesCollection.__init__(self)

        # An object used to track who depends on what
        self._dependency_handler = dependency_handler

        # A FormArgument:FormArgument mapping to override
        # counts and elements of functions without rebuilding integrand
        self._form_argument_mapping = form_argument_mapping

    def geometric_quantity(self, o, component=(), derivatives=(), restriction=None):
        "Generic rendering of variable names for all piecewise constant geometric quantities."
        uflacs_assert(not derivatives,
                      "Compiler should be able to simplify derivatives of geometry.")

        # Simply using the UFL str to define the name in the generated code, ensures consistency
        name = str(o)
        if restriction:
            name = name + restriction

        # Indexing if there is a shape
        sh = o.shape()
        if sh:
            uflacs_assert(component, "Missing component for nonscalar %r." % o)
            code = "%s[%d]" % (name, flatten_component(component, sh, None))
        else:
            uflacs_assert(component == (), "Component specified for scalar %r." % o)
            code = name

        # Make a record of dependency
        self._dependency_handler.require(o, component, derivatives, restriction, code)

        return code

    def facet_area(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(restriction is None, "Assuming facet_area is not restricted.")
        return self.geometric_quantity(o, component, derivatives, restriction)

    def _piecewise_constant_coefficient(self, o, component, derivatives, restriction):
        uflacs_assert(not derivatives,
                      "Not expecting derivatives of constant coefficients!")

        comp = flatten_component(component, o.shape(), o.element().symmetry())

        if restriction == "+":
            comp += component_value_size(o.shape(), o.element().symmetry())

        o = self._form_argument_mapping.get(o, o)
        return "w[%d][%d]" % (o.count(), comp)

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        if o.is_cellwise_constant():
            return self._piecewise_constant_coefficient(o, component, derivatives, restriction)
        else:
            return self.form_argument(o, component, derivatives, restriction, "w%d")

    def argument(self, o, component=(), derivatives=(), restriction=None):
        return self.form_argument(o, component, derivatives, restriction, "v%d")

    def form_argument(self, o, component, derivatives, restriction, common_name):
        o = self._form_argument_mapping.get(o, o)
        count = o.count()
        uflacs_assert(count >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        base_name = (common_name % (count,))

        rcode = {None:"", "+": "_p", "-": "_m"}[restriction]

        def indstring(indices):
            # FIXME: Indexing flat or nested in C++?
            if 1:
                return "".join("[%s]" % i for i in indices)
            else:
                return ("[%s]" % (", ".join(map(str,indices))))

        if derivatives:
            dcodepre  = "d%d_" % (len(derivatives),)
            dcodepost = indstring(derivatives)
        else:
            dcodepre, dcodepost = "", ""

        if component:
            icode = indstring(component)
        else:
            icode = ""

        code = dcodepre + base_name + rcode + icode + dcodepost

        self._dependency_handler.require(o, component, derivatives, restriction, code)
        return code
