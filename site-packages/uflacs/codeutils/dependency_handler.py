
from ufl.classes import (Terminal, Grad, Indexed, FixedIndex,
                         Restricted, PositiveRestricted, NegativeRestricted,
                         Coefficient, Argument)
from ufl.sorting import sorted_expr

from uflacs.utils.assertions import uflacs_assert
from uflacs.utils.log import warning, error

# TODO: Make this more robust by looping like analyse_modified_terminal, currently assumes that transformations have been applied.
def is_modified_terminal(v):
    return (isinstance(v, (Terminal, Grad, Restricted))
            or (isinstance(v, Indexed) and isinstance(v.operands()[0], (Terminal, Grad, Restricted))))

terminal_modifier_types = (Grad, Restricted, Indexed)
def analyse_modified_terminal(o):
    """Analyse a so-called 'modified terminal' expression and return its properties in more compact form.

    A modified terminal expression is:
    an object of a Terminal subtype,
    wrapped in 0-* Grad objects,
    wrapped in 0-1 Restricted object,
    wrapped in 0-1 Indexed object.

    The returned values are:

    (terminal, component, derivatives, restriction)

    # TODO: Explain the format of these values for future reference.
    """
    t = o
    component = None
    derivatives = []
    r = None
    while not isinstance(t, Terminal):
        if not isinstance(t, terminal_modifier_types):
            error("Unexpected type %s object %s." % (type(t), repr(t)))

        if isinstance(t, Indexed):
            uflacs_assert(component is None, "Got twice indexed terminal.")
            t, i = t.operands()
            uflacs_assert(all(isinstance(j, FixedIndex) for j in i), "Expected only fixed indices.")
            component = [int(j) for j in i]

        elif isinstance(t, Grad):
            uflacs_assert(len(component), "Got gradient of terminal without prior indexing.")
            derivatives += component[-1]
            component = component[:-1]
            t, = t.operands()

        elif isinstance(t, Restricted):
            uflacs_assert(r is None, "Got twice restricted terminal!")
            r = t._side
            t, = t.operands()

    component = tuple(component) if component else ()
    derivatives = tuple(sorted(derivatives))

    uflacs_assert(len(component) == t.rank(), "Length of component does not match rank of terminal.")
    uflacs_assert(all(c >= 0 and c < d for c,d in zip(component, t.shape())),
                  "Component indices %s are outside terminal shape %s" % (component, t.shape()))

    return (t, component, derivatives, r)


class DependencyHandler(object):
    """Class used to collect dependencies during early compilation stages."""
    def __init__(self, modified_terminals, cell, form_argument_mapping=None, object_names=None):

        # Store modified terminals in a canonical ordering
        self.modified_terminals = sorted_expr(modified_terminals)

        self.cell = cell

        # FIXME: A bit confused now, which objects are relabeled and which are not?
        # Mapping from original to relabeled form argument objects
        self.form_argument_mapping = form_argument_mapping or {}

        # Store object names, an id(obj) -> name mapping
        self.object_names = object_names or {}

        # Analyse modified terminals and store data about them
        self.terminal_data = [analyse_modified_terminal(o) for o in self.modified_terminals]

        # Extract functions without modifiers and duplicates and sort by count
        self.coefficients = sorted(set(td[0] for td in self.terminal_data
                                       if isinstance(td[0], Coefficient)),
                                       key=lambda x: x.count())
        self.arguments = sorted(set(td[0] for td in self.terminal_data
                                    if isinstance(td[0], Argument)),
                                    key=lambda x: x.count())

        # Number and name functions, each coefficient name becomes a member name:
        self.coefficient_names = {}
        for i, c in enumerate(self.coefficients):
            default = "w%d" % i
            self.coefficient_names[c] = self.object_names.get(id(c), default)

        # A mapping { expr: {(c,d,r): code} } used to record visited dependencies
        self.required = {}


    def require(self, o, component, derivatives, restriction, code):
        "Helper function for remembering terminal-ish dependencies."

        s = self.required.get(o) or {}

        key = (tuple(component), tuple(derivatives), restriction)
        oldcode = s.get(key)
        uflacs_assert((not oldcode) or (oldcode == code),
                      "Generated different code for same expression.")
        s[key] = code

        self.required[o] = s
        return code
