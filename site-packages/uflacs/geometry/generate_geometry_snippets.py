from uflacs.codeutils.format_code_structure import Indented

# A dependency graph like this might be a way to automatically figure out which quantities to generate?
dependencies = {
   'J': ('vertex_coordinates',),
   'detJ': ('J',),
   'K': ('J','detJ'),
   'x': ('xi', 'J', 'vertex_coordinates'),
   'xi': ('x', 'K', 'vertex_coordinates'),
  }

#def missing_geometry_snippets(existing, wanted):
#    ...
#def generate_missing_geometry_snippets(existing, wanted, restriction):
#    ...

# TODO: Get names from some central place? Or is it good enough to just rely on convention?


### Generating generic code snippets such as matrix-multiply

def generate_array_definition_snippets(name, expressions, d, typename="const double"):
    "Generate combined definition and declaration of name[] = expressions[] dimension d."
    decl = ['%s %s[%d] = {' % (typename, name, d),
            Indented([e+',' for e in expressions[:-1]]
                     + [expressions[-1], '};'])]
    return decl

def generate_z_Axpy_snippets(name_z, name_A, name_x, name_y, zd, xd):
    fmt_A = dict(((i,j), '%s[%d*%d+%d]' % (name_A, i, xd, j)) for i in xrange(zd) for j in xrange(xd))
    fmt_x = ['%s[%d]' % (name_x, j) for j in xrange(xd)]
    fmt_y = ['%s[%d]' % (name_y, i) for i in xrange(zd)]
    fmt_Ax = [' + '.join('%s * %s' % (fmt_A[(i,j)], fmt_x[j]) for j in xrange(xd)) for i in xrange(zd)]
    fmt_z = ['%s + %s' % (fmt_Ax[i], fmt_y[i]) for i in xrange(zd)]
    return generate_array_definition_snippets(name_z, fmt_z, zd)

def generate_z_Axmy_snippets(name_z, name_A, name_x, name_y, zd, xd):
    "Generate combined definition and declaration of z = A (x - y) with dimensions zd,xd."
    fmt_A = dict(((i,j), '%s[%d*%d+%d]' % (name_A, i, xd, j)) for i in xrange(zd) for j in xrange(xd))
    fmt_xmy = ['(%s[%d] - %s[%d])' % (name_x, j, name_y, j) for j in xrange(xd)]
    fmt_z = [' + '.join('%s * %s' % (fmt_A[(i,j)], fmt_xmy[j]) for j in xrange(xd)) for i in xrange(zd)]
    return generate_array_definition_snippets(name_z, fmt_z, zd)


### Generating inline computations of geometry

def generate_x_from_xi_snippets(cell, restriction):
    "Generate combined definition and declaration of x = J xi + v."
    gd = cell.geometric_dimension()
    td = cell.topological_dimension()
    name_A = "J%s" % restriction
    name_x = "xi%s" % restriction
    name_y = "vertex_coordinates%s" % restriction
    name_z = "x%s" % restriction
    return generate_z_Axpy_snippets(name_z, name_A, name_x, name_y, gd, td)

def generate_xi_from_x_snippets(cell, restriction):
    "Generate combined definition and declaration of xi = K (x - v)."
    gd = cell.geometric_dimension()
    td = cell.topological_dimension()
    name_A = "K%s" % restriction
    name_x = "x%s" % restriction
    name_y = "vertex_coordinates%s" % restriction
    name_z = "xi%s" % restriction
    return generate_z_Axmy_snippets(name_z, name_A, name_x, name_y, td, gd)


### Generating calls to functions from ufc_geometry.h

_code = {
    "interval": {
        1: [],
        2: [],
        3: [],
        },
    "triangle": {
        2: [],
        3: [],
        },
    "tetrahedron": {
        3: [],
        }
    }

jacobian_code = {
    "interval": {
        1: ["double J[1];",
            "compute_jacobian_interval_1d(J, vertex_coordinates);"],
        2: ["double J[2];",
            "compute_jacobian_interval_2d(J, vertex_coordinates);"],
        3: ["double J[3];",
            "compute_jacobian_interval_3d(J, vertex_coordinates);"],
        },
    "triangle": {
        2: ["double J[4];",
            "compute_jacobian_triangle_2d(J, vertex_coordinates);"],
        3: ["double J[6];",
            "compute_jacobian_triangle_3d(J, vertex_coordinates);"],
        },
    "tetrahedron": {
        3: ["double J[9];",
            "compute_jacobian_tetrahedron_3d(J, vertex_coordinates);"],
        }
    }

jacobian_determinants_code = {
    "interval": {
        1: ["double detJ;",
            "compute_jacobian_determinants_interval_1d(detJ, J);"],
        2: ["double det2;", "double detJ;",
            "compute_jacobian_determinants_interval_2d(det2, detJ, J);"],
        3: ["double det2;", "double detJ;",
            "compute_jacobian_determinants_interval_3d(det2, detJ, J);"],
        },
    "triangle": {
        2: ["double detJ;",
            "compute_jacobian_determinants_triangle_2d(detJ, J);"],
        3: ["double den;", "double det2;", "double detJ;", "double c[3];",
            "compute_jacobian_determinants_triangle_3d(den, det2, detJ, c, J);"],
        },
    "tetrahedron": {
        3: ["double detJ;", "double d[9];",
            "compute_jacobian_determinants_tetrahedron_3d(detJ, d, J);"],
        }
    }

jacobian_inverse_code = {
    "interval": {
        1: ["double K[1];",
            "new_compute_jacobian_inverse_interval_1d(K, detJ);",],
        2: ["double K[2];",
            "new_compute_jacobian_inverse_interval_2d(K, det2, J);"],
        3: ["double K[3];",
            "new_compute_jacobian_inverse_interval_3d(K, det2, J);"],
        },
    "triangle": {
        2: ["double K[4];",
            "new_compute_jacobian_inverse_triangle_2d(K, detJ, J);"],
        3: ["double K[6];",
            "new_compute_jacobian_inverse_triangle_3d(K, den, c, J);"],
        },
    "tetrahedron": {
        3: ["double K[9];",
            "new_compute_jacobian_inverse_tetrahedron_3d(K, detJ, d);"],
        }
    }

cell_volume_code = {
    "interval": {
        1: ["double volume = std::fabs(detJ);"],
        2: ["double volume = std::fabs(detJ);"],
        3: ["double volume = std::fabs(detJ);"],
        },
    "triangle": {
        2: ["double volume = std::fabs(detJ) / 2.0;"],
        3: ["double volume = std::fabs(detJ) / 2.0;"],
        },
    "tetrahedron": {
        3: ["double volume = std::fabs(detJ) / 6.0;"],
        }
    }

circumradius_code = {
    "interval": {
        1: ["double circumradius = volume / 2.0;"],
        2: ["double circumradius = volume / 2.0;"],
        3: ["double circumradius = volume / 2.0;"],
        },
    "triangle": {
        2: ["double circumradius;",
            "compute_circumradius_triangle_2d(circumradius, vertex_coordinates, J, volume);"],
        3: ["double circumradius;",
            "compute_circumradius_triangle_3d(circumradius, vertex_coordinates, J, volume);"],
        },
    "tetrahedron": {
        3: ["double circumradius;",
            "compute_circumradius_tetrahedron_3d(circumradius, vertex_coordinates, J, volume);"],
        }
    }

facet_scaling_code = {
    "interval": {
        1: [],
        2: [],
        3: [],
        },
    "triangle": {
        2: ["double dx[2];",
            "compute_edge_scaling_factors_triangle_2d(dx, vertex_coordinates, facet);",
            "double det;",
            "compute_facet_scaling_factor_triangle_2d(det, dx);"],
        3: ["double dx[3];",
            "compute_edge_scaling_factors_triangle_3d(dx, vertex_coordinates, facet);",
            "double det;",
            "compute_facet_scaling_factor_triangle_3d(det, dx);"],
        },
    "tetrahedron": {
        3: ["double a[3];",
            "compute_face_scaling_factors_tetrahedron_3d(a, vertex_coordinates, facet);",
            "double det;",
            "compute_facet_scaling_factor_tetrahedron_3d(det, a);"],
        }
    }

facet_area_code = {
    "interval": {
        1: ["double facetarea = 1.0;"],
        2: ["double facetarea = 1.0;"],
        3: ["double facetarea = 1.0;"],
        },
    "triangle": {
        2: ["double facetarea = det;"],
        3: ["double facetarea = det;"],
        },
    "tetrahedron": {
        3: ["double facetarea = det / 2.0;"], # 'det' is scaled by area of reference triangle
        }
    }

facet_direction_code = {
    "interval": {
        1: ["bool direction;",
            "compute_facet_normal_direction_interval_1d(direction, vertex_coordinates, facet);"],
        2: [],
        3: [],
        },
    "triangle": {
        2: ["bool direction;",
            "compute_facet_normal_direction_triangle_2d(direction, vertex_coordinates, dx, facet);"],
        3: [],
        },
    "tetrahedron": {
        3: ["bool direction;",
            "compute_facet_normal_direction_tetrahedron_3d(direction, vertex_coordinates, a, facet);"],
        }
    }

facet_normal_code = {
    "interval": {
        1: ["double n[1];",
            "compute_facet_normal_interval_1d(n, direction);"],
        2: ["double n[2];",
            "compute_facet_normal_interval_2d(n, vertex_coordinates, facet);"],
        3: ["double n[3];",
            "compute_facet_normal_interval_3d(n, vertex_coordinates, facet);"],
        },
    "triangle": {
        2: ["double n[2];",
            "compute_facet_normal_triangle_2d(n, dx, det, direction);"],
        3: ["double n[3];",
            "compute_facet_normal_triangle_3d(n, vertex_coordinates, facet);"],
        },
    "tetrahedron": {
        3: ["double n[3];",
            "compute_facet_normal_tetrahedron_3d(n, a, det, direction);"],
        }
    }

def generate_jacobian_snippets(cell, restriction):
    assert not restriction
    return list(jacobian_code[cell.cellname()][cell.geometric_dimension()])

def generate_jacobian_determinants_snippets(cell, restriction):
    assert not restriction
    return list(jacobian_determinants_code[cell.cellname()][cell.geometric_dimension()])

def generate_jacobian_inverse_snippets(cell, restriction):
    assert not restriction
    return list(jacobian_inverse_code[cell.cellname()][cell.geometric_dimension()])

def generate_cell_scaling_factor_snippets(cell):
    code = ['double det = std::fabs(detJ);']
    return code

def generate_cell_volume_snippets(cell, restriction):
    assert not restriction
    return list(cell_volume_code[cell.cellname()][cell.geometric_dimension()])

def generate_circumradius_snippets(cell, restriction):
    assert not restriction
    return list(circumradius_code[cell.cellname()][cell.geometric_dimension()])

def generate_facet_scaling_factor_snippets(cell, restriction):
    assert not restriction
    return list(facet_scaling_code[cell.cellname()][cell.geometric_dimension()])

def generate_facet_direction_snippets(cell, restriction):
    assert not restriction
    return list(facet_direction_code[cell.cellname()][cell.geometric_dimension()])

def generate_facet_normal_snippets(cell, restriction):
    assert not restriction
    return list(facet_normal_code[cell.cellname()][cell.geometric_dimension()])

def generate_facet_area_snippets(cell, restriction):
    assert not restriction
    return list(facet_area_code[cell.cellname()][cell.geometric_dimension()])
