
# A dependency graph like this might be a way to automatically figure out which quantities to generate?
dependencies = {
   'J': ('vertex_coordinates',),
   'detJ': ('J',),
   'K': ('J','detJ'),
   'x': ('xi', 'J', 'vertex_coordinates'),
   'xi': ('x', 'K', 'vertex_coordinates'),
  }

#def missing_geometry_snippets(existing, wanted):
#    ...
#def generate_missing_geometry_snippets(existing, wanted, restriction):
#    ...

### Generating generic code snippets

def generate_array_definition_snippets(name, expressions, d):
    "Generate combined definition and declaration of name[] = expressions[] dimension d."
    decl = ['double %s[%d] = {' % (name, d)]
    decl += [e+',' for e in expressions[:-1]]
    decl += [expressions[-1]]
    decl += ['    };']
    return decl

def generate_z_Axpy_snippets(name_z, name_A, name_x, name_y, zd, xd):
    fmt_A = dict(((i,j), '%s[%d*%d+%d]' % (name_A, i, xd, j)) for i in xrange(zd) for j in xrange(xd))
    fmt_x = ['%s[%d]' % (name_x, j) for j in xrange(xd)]
    fmt_y = ['%s[%d]' % (name_y, i) for i in xrange(zd)]
    fmt_Ax = [' + '.join('%s * %s' % (fmt_A[(i,j)], fmt_x[j]) for j in xrange(xd)) for i in xrange(zd)]
    fmt_z = ['%s + %s' % (fmt_Ax[i], fmt_y[i]) for i in xrange(zd)]
    return generate_array_definition_snippets(name_z, fmt_z, zd)

def generate_z_Axmy_snippets(name_z, name_A, name_x, name_y, zd, xd):
    "Generate combined definition and declaration of z = A (x - y) with dimensions zd,xd."
    fmt_A = dict(((i,j), '%s[%d*%d+%d]' % (name_A, i, xd, j)) for i in xrange(zd) for j in xrange(xd))
    fmt_xmy = ['(%s[%d] - %s[%d])' % (name_x, j, name_y, j) for j in xrange(xd)]
    fmt_z = [' + '.join('%s * %s' % (fmt_A[(i,j)], fmt_xmy[j]) for j in xrange(xd)) for i in xrange(zd)]
    return generate_array_definition_snippets(name_z, fmt_z, zd)

### Generating calls to functions from ufc_geometry.h

def generate_jacobian_snippets(cell, restriction):
    decl = 'double J%s[%d*%d];' % (restriction, cell.geometric_dimension(), cell.topological_dimension())
    comp = 'compute_jacobian_%s_%dd(J%s, vertex_coordinates%s);' % (
        cell.cellname(), cell.geometric_dimension(), restriction, restriction)
    return [decl, comp]

def generate_jacobian_inverse_snippets(cell, restriction):
    decl = ['double det%s;' % restriction,
            'double K%s[%d*%d];' % (restriction, cell.geometric_dimension(), cell.topological_dimension())]
    comp = 'compute_jacobian_inverse_%s_%dd(K%s, det%s, J%s);' % (
        cell.cellname(), cell.geometric_dimension(), restriction, restriction, restriction)
    return decl + [comp]

### Generating inline computations of geometry

def generate_x_from_xi_snippets(cell, restriction):
    "Generate combined definition and declaration of x = J xi + v."
    gd = cell.geometric_dimension()
    td = cell.topological_dimension()
    name_A = "J%s" % restriction
    name_x = "xi%s" % restriction
    name_y = "vertex_coordinates%s" % restriction
    name_z = "x%s" % restriction
    return generate_z_Axpy_snippets(name_z, name_A, name_x, name_y, gd, td)

def generate_xi_from_x_snippets(cell, restriction):
    "Generate combined definition and declaration of xi = K (x - v)."
    gd = cell.geometric_dimension()
    td = cell.topological_dimension()
    name_A = "K%s" % restriction
    name_x = "x%s" % restriction
    name_y = "vertex_coordinates%s" % restriction
    name_z = "xi%s" % restriction
    return generate_z_Axmy_snippets(name_z, name_A, name_x, name_y, td, gd)
