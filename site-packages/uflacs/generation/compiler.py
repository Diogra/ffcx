
import numpy
from uflacs.utils.tictoc import TicToc
from uflacs.utils.log import error, uflacs_assert

from uflacs.analysis.graph import build_graph
from uflacs.analysis.graph_vertices import build_scalar_graph_vertices
from uflacs.analysis.graph_rebuild import rebuild_scalar_e2i
from uflacs.analysis.graph_ssa import (compute_dependencies,
                                         mark_active,
                                         mark_partitions,
                                         compute_dependency_count,
                                         invert_dependencies,
                                         default_cache_score_policy,
                                         compute_cache_scores,
                                         allocate_registers)
from uflacs.analysis.factorization import compute_argument_factorization, rebuild_scalar_graph_from_factorization
from uflacs.analysis.dependency_handler import DependencyHandler

from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.element_tensor_formatter import build_loops
from uflacs.codeutils.format_lines import format_assignments, format_scaled_additions


def build_partition_labels(rank, num_points, dofranges, dofblocks):

    # - build numbering of partitions:
    #   - piecewise: 1
    #   - for each np:
    #     - varying: 1 + conditionals
    #       - conditional: for each conditional expression case?
    #     - argument: for each argument for each dofrange
    #     - integrand: for each dofblock

    # Build a numbering of partitions, where p2 > p1 if p1 occurs before p2 in the same code path
    partition_labels = {}
    p = 1

    # "piecewise": partition of expressions independent of quadrature and argument loops
    partition_labels["piecewise"] = p; p += 1

    # "varying", [np]: partition of expressions dependent on np quadrature but independent of argument loops
    partition_labels["varying"] = {}
    for np in num_points:
        partition_labels["varying"][np] = p; p += 1

    # "argument", [np][iarg][dofrange]: partition depending on this dofrange of argument iarg
    partition_labels["argument"] = {}
    for np in num_points:
        partition_labels["argument"][np] = {}
        for iarg in range(rank):
            partition_labels["argument"][np][iarg] = {}
            for dofrange in dofranges[np][iarg]:
                partition_labels["argument"][np][iarg][dofrange] = p; p += 1

    # "integrand", [np][dofblock]: partition depending on this dofblock
    partition_labels["integrand"] = {}
    for np in num_points:
        partition_labels["integrand"][np] = {}
        for dofblock in dofblocks[np]:
            partition_labels["integrand"][np][dofblock] = p; p += 1

    # TODO: Add partition labels for conditional cases?
    #       Maybe nested label tuples? This is not thought through...
    #partition_labels["conditional"][np] = {}
    #partition_labels["conditional"][np][conditional_true] = p; p += 1
    #partition_labels["conditional"][np][conditional_false] = p; p += 1

    max_p = p
    return partition_labels, max_p


# FFC compiler calls:
# 1) compile_expression_partitions
# 2) generate_code_from_ssa
# 3) generate_expression_body

def compile_expression_partitions(expression, form_argument_mapping, parameters):
    # Timing object
    tt = TicToc('compile_expression_partitions')

    # TODO: Cleaner way to set rank
    rank = len(set(arg for arg in form_argument_mapping if isinstance(arg, Argument)))

    # Build the initial coarse computational graph of the expression
    tt.step('build_graph')
    G = build_graph([expression])

    # Build more fine grained computational graph of scalar subexpressions
    tt.step('rebuild_scalar_e2i')
    # FIXME: Apply form_argument_mapping in here?
    # FIXME: Apply Grad -> GeometryJacobi * LocalGrad change at this point?
    # FIXME: Apply Piola mappings at this point?
    unused_e2i, NV, unused_W, terminals, nvs = rebuild_scalar_e2i(G, DEBUG=False)
    # Target expression is NV[nvs[:]].
    # TODO: Make it target expressionS, expressions[k] -> NV[nvs[k][:]], len(nvs[k]) == value_size(expressions[k])

    # Straigthen out V to represent single operations
    tt.step('build_scalar_graph_vertices')
    se2i, SV, target_variables = build_scalar_graph_vertices([NV[s] for s in nvs])

    # Compute sparse dependency matrix
    tt.step('compute_dependencies')
    dependencies = compute_dependencies(se2i, SV)

    # Compute factorization of arguments
    tt.step('compute_dependencies')
    # TODO: Fix factorization algorithm for multiple target variables! Or is there any point?
    if parameters["enable_factorization"] and len(target_variables) == 1:
        # AV, FV, IM
        argument_factors, factorized_vertices, argument_factorization = \
            compute_argument_factorization(SV, target_variables, dependencies)

        # Rebuild some graphs from factorization
        SV, se2i, dependencies = rebuild_scalar_graph_from_factorization(\
            argument_factors, factorized_vertices, argument_factorization)

        # TODO: target_variables for non-scalar or multiple expressions
        target_variables = [len(SV)-1]

    if 0: # FIXME: Use this!

        # XXX: FIXME: find dofrange for each argument_factors value
        #dofranges[np][iarg] = [...]

        # XXX: FIXME: find dofblock for each argument_factorization item
        #dofblocks[np] = [...]

        partition_labels, max_p = build_partition_labels(rank, num_points, dofranges, dofblocks)

        # TODO: reorder vertices grouped by partition number
        # FIXME: change mark_partitions to use this numbering instead
        # FIXME: change code generation to use this numbering instead

    # Mark subexpressisons that are actually needed for final result
    tt.step('mark_active')
    max_symbol = len(SV)

    active, num_active = mark_active(max_symbol, dependencies, target_variables)

    # Mark subexpressions with which loop they belong inside
    tt.step('mark_partitions')
    # NB! This one assumes that argument mapping has been applied in SV, which it currently hasn't.
    # However this code may be superseeded soon anyway?
    partitions = mark_partitions(SV, active, dependencies, rank)

    # Count the number of dependencies every subexpr has
    tt.step('compute_dependency_count')
    depcount = compute_dependency_count(dependencies)

    # Build the 'inverse' of the sparse dependency matrix
    tt.step('invert_dependencies')
    inverse_dependencies = invert_dependencies(dependencies, depcount)

    # Use heuristics to mark the usefulness of storing every subexpr in a variable
    tt.step('compute_cache_scores')
    scores = compute_cache_scores(SV,
                                  active,
                                  dependencies,
                                  inverse_dependencies,
                                  partitions,
                                  cache_score_policy=default_cache_score_policy)

    if 0:
        print '\n'*5
        print "SV:"
        print '\n'.join('  {}: {}'.format(i,s) for i,s in enumerate(SV))
        print "scores:"
        print '\n'.join('  {}: {}'.format(i,s) for i,s in enumerate(scores))
        print '\n'*5

    # Allocate variables to store subexpressions in
    tt.step('allocate_registers')
    allocations = allocate_registers(active, partitions, target_variables,
                                     scores, int(parameters["max_registers"]), int(parameters["score_threshold"]))
    target_registers = [allocations[r] for r in target_variables]
    num_registers = sum(1 if x >= 0 else 0 for x in allocations)
    # TODO: If we renumber we can allocate registers separately for each partition, which is probably a good idea.

    # Print timing
    tt.stop()
    if parameters["enable_profiling"]:
        print "Profiling results:"
        print tt

    ir = {}
    ir["num_registers"] = num_registers
    ir["SV"] = SV
    ir["active"] = active
    ir["partitions"] = partitions
    ir["allocations"] = allocations
    ir["target_registers"] = target_registers
    ir["terminals"] = terminals
    return ir

# TODO: Move these to [target_]expr_formatter:
def format_assignment_statement(lhs, rhs):
    return "%s = %s;" % (lhs, rhs)

def format_register_variable(p, r):
    return "s[%d]" % (r,) # TODO: Maybe make it "s%d[%d]" % (p, r)

def generate_partition_code(SV, allocations, active, partitions, p, language_formatter):
    # This is a transformer that collects terminal modifiers
    # and delegates formatting to the language_formatter
    expr_formatter = ExprFormatter(language_formatter, {})
    code = []
    # Generate assignment code for each expression with an allocated register in partition p
    for i, v in enumerate(SV):
        vreg = allocations[i]
        if active[i] and partitions[i] == p and vreg >= 0:
            vname = format_register_variable(p, vreg)
            vcode = expr_formatter.visit(v)
            assignment = format_assignment_statement(vname, vcode)
            code.append(assignment)
            expr_formatter.variables[v] = vname
    return code

def generate_code_from_ssa(partitions_ir, language_formatter):
    # Fetch stuff from ir:
    SV = partitions_ir["SV"]
    active = partitions_ir["active"]
    partitions = partitions_ir["partitions"]
    allocations = partitions_ir["allocations"]
    target_registers = partitions_ir["target_registers"]

    # Find partition range, skip negative which means inactive vertices
    min_p = max(0,min(partitions))
    max_p = max(partitions)

    # Handle partitions one at a time, in order
    partition_codes = []
    for p in range(min_p, max_p+1):
        code = generate_partition_code(SV, allocations, active, partitions, p, language_formatter)
        partition_codes.append((p,code))

    p = max_p # TODO: Add partitions to target_registers, or is this fine?
    final_variable_names = [format_register_variable(p, r) for r in target_registers]
    return partition_codes, final_variable_names

# FIXME: Replace generate_expression_body and FFCStatementFormatter with the new IntegralGenerator class
def generate_expression_body(target_statement_formatter, partition_codes,
                             final_variable_names, num_registers):
    "Join partitions with target specific loops and declarations."
    # Use shorter name below
    tfmt = target_statement_formatter
    dh = target_statement_formatter._dependency_handler
    rank = len(dh.mapped_arguments)

    # Make a shallow copy of dict, we consume the dict entries below
    partition_codes = dict(partition_codes)

    # Both 'required' and 'terminals' are filled during partition compilation
    #req = dh.required
    #term = dh.terminals

    # Build loop structure (intended for tabulate_tensor)
    loops = []
    definitions = []
    partitions = []

    def update_loops(loop, defs, p):
        loops.append(loop)
        definitions.append(defs)
        partitions.append(partition_codes.get(p,""))
        if p in partition_codes:
            del partition_codes[p]

    # TODO: This partition numbering is maybe too "magic"? At least make named constants!
    # --- Partition 0: independent of x and arguments.
    p = 0
    if 1:
        piecewise_defs = []
        piecewise_defs += tfmt.define_output_variables_reset()
        piecewise_defs += tfmt.define_piecewise_geometry()
        piecewise_defs += tfmt.define_piecewise_coefficients()
        # TODO: Make registers separately for each partition level?
        if num_registers:
            piecewise_defs += tfmt.define_registers(num_registers)
        piecewise_defs += [""]
        update_loops(None, piecewise_defs, p)

    # --- Partition 1: x dependency
    # FIXME: Separate cleanly between:
    # - x assumed known
    # - xi assumed known
    # - xi defined by inserted quadrature loop
    # - x defined by inserted quadrature loop
    # ... Probably best to configure tfmt to know this beforehand some place?
    p = 1
    if 1:
        coord_loop = tfmt.define_coord_loop() # Can be None
        coord_dependent_defs = []
        coord_dependent_defs += tfmt.define_coord_vars()
        coord_dependent_defs += tfmt.define_coord_dependent_geometry()
        update_loops(coord_loop, coord_dependent_defs, p)

    # --- Partition 2: coord and coefficient dependency
    p = 2
    if 1:
        w_dependent_defs = []
        w_dependent_defs += tfmt.define_coord_dependent_coefficients()
        update_loops(None, w_dependent_defs, p)

    # --- Partitions 3...3+rank-1: argument function dependency
    poffset = 3
    for ac in range(rank):
        p = poffset + ac
        update_loops(tfmt.define_argument_for_loop(ac),
                     tfmt.define_argument_loop_vars(ac),
                     p)

    # --- Final partition: final assignments
    p = poffset + rank
    if 1:
        assign_to_variables = tfmt.output_variable_names(len(final_variable_names))
        scaling_factor = tfmt.accumulation_scaling_factor()
        if scaling_factor is None:
            final_statements = list(format_assignments(zip(assign_to_variables,
                                                           final_variable_names)))
        else:
            final_statements = list(format_scaled_additions(zip(assign_to_variables,
                                                                final_variable_names),
                                                            scaling_factor))
        update_loops(None, final_statements, p)

    # --- Should be nothing left now
    assert not partition_codes

    # Stitch it together
    code = build_loops(loops, definitions, partitions)

    return code

def generate_expression_code(partitions_ir, form_argument_mapping, object_names,
                             create_language_formatter, create_statement_formatter):
    "Core of toy expression compiler."

    # Create an object to track dependencies across other components
    dependency_handler = DependencyHandler(partitions_ir["terminals"], form_argument_mapping, object_names)

    # This formatter is a multifunction implementing target specific formatting rules
    language_formatter = create_language_formatter(dependency_handler, partitions_ir)

    # Create a formatter for blocks of statements
    statement_formatter = create_statement_formatter(dependency_handler, partitions_ir)

    # Generate code partitions from ir
    partition_codes, final_variable_names = generate_code_from_ssa(partitions_ir, language_formatter)

    # Generate full code from snippets
    code = generate_expression_body(statement_formatter,
                                    partition_codes,
                                    final_variable_names,
                                    partitions_ir["num_registers"])

    # Leave final formatting to the caller
    return code, dependency_handler
