
from itertools import izip

from ufl.common import product
from ufl.permutation import compute_indices
from ufl.classes import Terminal, Indexed, ComponentTensor, ListTensor, UtilityType, Index
from ufl.algorithms.traversal import traverse_terminals, fast_post_traversal

import numpy

def int_array(size):
    return numpy.zeros(size, dtype=int)

def object_array(size):
    # TODO: Any gain in using a numpy array for object lists?
    #return numpy.array(dtype=object)
    return [None]*size

def sorted_indices(indices):
    return sorted(indices, key=lambda x: x.count())

def build_node_counts(expr):
    "Build a dict mapping unique Expr node -> unique count."
    i = 0
    e2i = {}

    # Terminals first... (TODO: Not really necessary, but nice, or?)
    for e in traverse_terminals(expr):
        if isinstance(e, UtilityType):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1

    # ... then the rest
    for e in fast_post_traversal(expr):
        if isinstance(e, Terminal):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1

    assert len(e2i) == i
    return e2i

def build_array_from_counts(e2i):
    nv = len(e2i)
    V = object_array(nv)
    for e,i in e2i.iteritems():
        V[i] = e
    return V

def build_node_shapes(V):
    V_shapes  = object_array(len(V))
    for i,v in enumerate(V):
        # Regular shape
        sh = v.shape()
        # Index "shape"
        idims = v.index_dimensions()
        ish = tuple(idims[idx] for idx in sorted_indices(v.free_indices()))
        # Store "total" shape and size
        V_shapes[i] = sh + ish
    return V_shapes

def build_node_offsets(V_shapes):
    nv = len(V_shapes)
    V_sizes = int_array(nv)
    V_offsets = int_array(nv)
    total_value_size = 0
    for i,sh in enumerate(V_shapes):
        s = product(sh)
        V_sizes[i] = s
        V_offsets[i] = total_value_size
        total_value_size += s
    return V_sizes, V_offsets, total_value_size

def build_node_symbols(G):
    V_symbols = int_array(G.total_value_size)

    def new_symbols(n):
        o = new_symbols.symbol_count
        new_symbols.symbol_count += n
        return list(xrange(o, o+n))
    new_symbols.symbol_count = 0

    for i in xrange(G.nv):
        v = G.V[i]
        #sh = G.V_shapes[i]
        n = G.V_sizes[i]
        o = G.V_offsets[i]

        if isinstance(v, Indexed):
            # Reuse symbols of arg A for Aii
            Aii = v
            A = Aii.operands()[0]

            # Get symbols of argument A
            j = G.e2i[A]
            A_o = G.V_offsets[j]
            A_n = G.V_sizes[j]
            A_symbols = V_symbols[A_o:A_o+A_n]

            # Map A_symbols to Aii_symbols
            d = map_indexed_arg_components(Aii)
            symbols = [A_symbols[k] for k in d]

        elif isinstance(v, ComponentTensor):
            # Reuse symbols of arg Aii for A
            A = v
            Aii = A.operands()[0]

            # Get symbols of argument Aii
            j = G.e2i[Aii]
            Aii_o = G.V_offsets[j]
            Aii_n = G.V_sizes[j]
            Aii_symbols = V_symbols[Aii_o:Aii_o+Aii_n]

            # Map A_symbols to Aii_symbols
            d = map_component_tensor_arg_components(A)
            symbols = [Aii_symbols[k] for k in d]

        elif isinstance(v, ListTensor):
            A = v
            rows = A.operands()
            js = [G.e2i[row] for row in rows]

            if 0:
                symbols = FIXME # Fetch symbols from argument, need mapping between extended shapes
            else:
                symbols = new_symbols(n)

        else:
            # Simply create one new symbol for each scalar component:
            symbols = new_symbols(n)
            # TODO: How/where to handle literals? Maybe use negative symbol indices?
            # TODO: How/where to handle derivatives? Probably want separate symbols for those.
            # TODO: Ignoring symmetries, reuse, etc. at this point

        V_symbols[o:o+n] = symbols

    total_unique_symbols = new_symbols.symbol_count
    return V_symbols, total_unique_symbols

class Graph2(object):
    def __init__(self):
        pass

def build_graph(expr, DEBUG=False): # TODO: Split this into multiple functions
    if DEBUG:
        print "In build_graph:"
        print "expr = ", str(expr)
        print "expr = ", repr(expr)
        print

    # Make empty graph
    G = Graph2()

    # Count unique expression nodes
    G.e2i = build_node_counts(expr)
    G.nv = len(G.e2i)

    # Make a list of the nodes by their ordering
    G.V = build_array_from_counts(G.e2i)
    if DEBUG:
        print "\nV:"
        for i, v in enumerate(G.V):
            print "%d\t%s\t%s" % (i, type(v).__name__, str(v))

    # Compute the total shape (value shape x index dimensions) for each node
    G.V_shapes = build_node_shapes(G.V)
    if DEBUG:
        print "\nV_shapes", G.V_shapes

    # Compute the offsets of nodes into a flattened scalar array
    G.V_sizes, G.V_offsets, G.total_value_size = build_node_offsets(G.V_shapes)
    if DEBUG:
        print "\nV_sizes", G.V_sizes
        print "V_offsets", G.V_offsets
        print "total_value_size", G.total_value_size

    # Mark values with symbols
    G.V_symbols, G.total_unique_symbols = build_node_symbols(G)
    if DEBUG:
        print "\nsymbols:"
        for i, o in enumerate(G.V_offsets):
            print "%d:\t%s" % (i, G.V_symbols[o:o+G.V_sizes[i]])

    # TODO: What more information to generate?
    return G

def rebuild_expression(v, i, G, wops):
    return [0 for k in compute_indices(G.V_shapes[i])]

def rebuild_expression_from_graph(G): # FIXME: Implement something like this
    # Regenerate expression via symbols?
    W = object_array(G.total_unique_symbols)
    for i in xrange(G.nv):
        v = G.V[i]

        # Find symbols of operands
        sops = []
        for j, vop in enumerate(v.operands()):
            if isinstance(vop, UtilityType):
                sops.append(()) # TODO: Not sure how to handle this
            else:
                oi = G.e2i[vop]
                on = G.V_sizes[oi]
                oo = G.V_offsets[oi]
                os = G.V_symbols[oo:oo+on]
                sops.append(os)

        # Find symbols of v
        vn = G.V_sizes[i]
        vo = G.V_offsets[i]
        vs = G.V_symbols[vo:vo+vn]

        # Store expressions for v symbols
        wops = [tuple(W[k] for k in s) for s in sops]
        w = rebuild_expression(v, i, G, wops)
        for j,k in enumerate(vs):
            W[k] = w[j]

    # Find symbols of final v
    i = G.nv-1
    v = G.V[i]
    vn = G.V_sizes[i]
    vo = G.V_offsets[i]
    vs = G.V_symbols[vo:vo+vn]

    w = [W[k] for k in vs]

    return w

def shape_to_strides(sh):
    n = len(sh)
    if not n:
        return ()
    strides = [None]*n
    strides[n-1] = 1
    for i in xrange(n-1, 0, -1):
        strides[i-1] = strides[i]*sh[i]
    return tuple(strides)

def multiindex_to_component(ii, strides):
    return sum(i*s for i,s in izip(ii,strides))

def component_to_multiindex(c, strides):
    ii = []
    rest = c
    for s in strides:
        k = rest // s
        ii.append(k)
        rest -= k*s
    return tuple(ii)

def indexing_to_component(ii, ind, sh):
    strides = shape_to_strides(sh)
    # TODO: Handle ind
    assert not ind

    index = ii
    c = multiindex_to_component(index, strides)
    return c

def map_indexed_to_arg_components(indexed):
    e1 = indexed
    assert isinstance(e1, Indexed)
    A1, mi1 = e1.operands()
    e2 = A1

    # Compute index shape
    ind1 = sorted_indices(e1.free_indices())
    ind2 = sorted_indices(e2.free_indices())
    idims1 = e1.index_dimensions()
    idims2 = e2.index_dimensions()
    ish1 = tuple(idims1[i] for i in ind1)
    ish2 = tuple(idims2[i] for i in ind2)

    # Compute regular and total shape
    sh1 = e1.shape()
    sh2 = e2.shape()
    tsh1 = sh1 + ish1
    tsh2 = sh2 + ish2
    str1 = shape_to_strides(tsh1)
    str2 = shape_to_strides(tsh2)
    assert product(tsh1) == product(tsh2)
    assert (not sh1) and (ish1) and (sh2) and (not ish2)

    sh_to_ind_map = [ind1.index(i) for i in mi1 if isinstance(i, Index)]
    comp1 = []
    comp2 = []
    for p2 in compute_indices(sh2):
        p1 = [None]*len(p2)
        for j, p in enumerate(p2):
            p1[sh_to_ind_map[j]] = p
        c1 = multiindex_to_component(p1, str1)
        c2 = multiindex_to_component(p2, str2)
        print c1, c2
        comp1.append(c1)
        comp2.append(c2)
    return tuple(comp1), tuple(comp2)
def map_indexed_arg_components2(Aii): # TODO: Remove when the new version is better tested
    c1, c2 = map_indexed_to_arg_components(Aii)
    d = [None]*len(c1)
    for k in range(len(c1)):
        d[c1[k]] = k
    return d


def map_indexed_arg_components4(indexed):
    assert isinstance(indexed, Indexed)
    e1 = indexed
    e2, mi = e1.operands()

    # Compute index shape
    ind1 = sorted_indices(e1.free_indices())
    ind2 = sorted_indices(e2.free_indices())
    idims1 = e1.index_dimensions()
    idims2 = e2.index_dimensions()
    ish1 = tuple(idims1[i] for i in ind1)
    ish2 = tuple(idims2[i] for i in ind2)

    # Compute regular and total shape
    sh1 = e1.shape()
    sh2 = e2.shape()
    tsh1 = sh1 + ish1
    tsh2 = sh2 + ish2
    str1 = shape_to_strides(tsh1)
    #str2 = shape_to_strides(tsh2)
    assert product(tsh1) == product(tsh2)
    assert (not sh1) and (ish1) and (sh2) and (not ish2)

    # Build map from ind1/ish1 position to mi position
    mi = [i for i in mi if isinstance(i, Index)]
    nmi = len(mi)
    ind1_to_mi_map = [None]*nmi
    for k in xrange(nmi):
        ind1_to_mi_map[ind1.index(mi[k])] = k

    # Build map from flattened e1 component to flattened e2 component
    indices2 = compute_indices(sh2)
    ni = len(indices2)
    d1 = [None]*ni
    d2 = [None]*ni
    for c2, p2 in enumerate(indices2):
        p1 = [p2[k] for k in ind1_to_mi_map]
        c1 = multiindex_to_component(p1, str1)
        d1[c1] = c2
        d2[c2] = c1
    assert d1 == d2
    return d1

def map_component_tensor_arg_components4(component_tensor):
    assert isinstance(component_tensor, ComponentTensor)
    e2 = component_tensor
    e1, mi = e2.operands()

    # Compute index shape
    ind1 = sorted_indices(e1.free_indices())
    ind2 = sorted_indices(e2.free_indices())
    idims1 = e1.index_dimensions()
    idims2 = e2.index_dimensions()
    ish1 = tuple(idims1[i] for i in ind1)
    ish2 = tuple(idims2[i] for i in ind2)

    # Compute regular and total shape
    sh1 = e1.shape()
    sh2 = e2.shape()
    tsh1 = sh1 + ish1
    tsh2 = sh2 + ish2
    str1 = shape_to_strides(tsh1)
    #str2 = shape_to_strides(tsh2)
    assert product(tsh1) == product(tsh2)
    assert (not sh1) and (ish1) and (sh2) and (not ish2)

    # Build map from ind1/ish1 position to mi position
    mi = [i for i in mi if isinstance(i, Index)]
    nmi = len(mi)
    ind1_to_mi_map = [None]*nmi
    for k in xrange(nmi):
        ind1_to_mi_map[ind1.index(mi[k])] = k

    # Build map from flattened e1 component to flattened e2 component
    indices2 = compute_indices(sh2)
    ni = len(indices2)
    d1 = [None]*ni
    d2 = [None]*ni
    for c2, p2 in enumerate(indices2):
        p1 = [p2[k] for k in ind1_to_mi_map]
        c1 = multiindex_to_component(p1, str1)
        d1[c1] = c2
        d2[c2] = c1
    assert d1 == d2
    return d2


def map_indexed_arg_components(indexed):
    assert isinstance(indexed, Indexed)
    e1 = indexed
    e2, mi = e1.operands()
    return map_tensor_components(e2, e1, mi)

def map_component_tensor_arg_components(component_tensor):
    assert isinstance(component_tensor, ComponentTensor)
    e2 = component_tensor
    e1, mi = e2.operands()
    return map_tensor_components(e2, e1, mi)

def map_tensor_components(tensor, indexed, multiindex):
    e2 = tensor
    e1 = indexed
    mi = multiindex

    # Compute index shape
    ind1 = sorted_indices(e1.free_indices())
    ind2 = sorted_indices(e2.free_indices())
    idims1 = e1.index_dimensions()
    idims2 = e2.index_dimensions()
    ish1 = tuple(idims1[i] for i in ind1)
    ish2 = tuple(idims2[i] for i in ind2)

    # Compute regular and total shape
    sh1 = e1.shape()
    sh2 = e2.shape()
    tsh1 = sh1 + ish1
    tsh2 = sh2 + ish2
    str1 = shape_to_strides(tsh1)
    #str2 = shape_to_strides(tsh2)
    assert product(tsh1) == product(tsh2)
    assert (not sh1) and (ish1) and (sh2) and (not ish2)

    # Build map from ind1/ish1 position to mi position
    mi = [i for i in mi if isinstance(i, Index)]
    nmi = len(mi)
    ind1_to_mi_map = [None]*nmi
    for k in xrange(nmi):
        ind1_to_mi_map[ind1.index(mi[k])] = k

    # Build map from flattened e1 component to flattened e2 component
    indices2 = compute_indices(sh2)
    ni = len(indices2)
    d1 = [None]*ni
    d2 = [None]*ni
    for c2, p2 in enumerate(indices2):
        p1 = [p2[k] for k in ind1_to_mi_map]
        c1 = multiindex_to_component(p1, str1)
        d1[c1] = c2
        d2[c2] = c1
    assert d1 == d2
    return d2
