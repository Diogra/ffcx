
import numpy
from ufl.classes import Terminal, Indexed, ComponentTensor, ListTensor, UtilityType
from ufl.algorithms.traversal import traverse_terminals, fast_post_traversal
from uflacs.algorithms.indexing import *

def int_array(size):
    return numpy.zeros(size, dtype=int)

def object_array(size):
    # TODO: Any gain in using a numpy array for object lists?
    #return numpy.array(dtype=object)
    return [None]*size

def build_node_counts(expr):
    "Build a dict mapping unique Expr node -> unique count."
    i = 0
    e2i = {}

    # Terminals first... (TODO: Not really necessary, but nice, or?)
    for e in traverse_terminals(expr):
        if isinstance(e, UtilityType):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1

    # ... then the rest
    for e in fast_post_traversal(expr):
        if isinstance(e, Terminal):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1

    assert len(e2i) == i
    return e2i

def build_array_from_counts(e2i):
    nv = len(e2i)
    V = object_array(nv)
    for e,i in e2i.iteritems():
        V[i] = e
    return V

def build_node_shapes(V):
    V_shapes  = object_array(len(V))
    for i,v in enumerate(V):
        # Regular shape
        sh = v.shape()
        # Index "shape"
        idims = v.index_dimensions()
        ish = tuple(idims[idx] for idx in sorted_indices(v.free_indices()))
        # Store "total" shape and size
        V_shapes[i] = sh + ish
    return V_shapes

def build_node_offsets(V_shapes):
    nv = len(V_shapes)
    V_sizes = int_array(nv)
    V_offsets = int_array(nv)
    total_value_size = 0
    for i,sh in enumerate(V_shapes):
        s = product(sh)
        V_sizes[i] = s
        V_offsets[i] = total_value_size
        total_value_size += s
    return V_sizes, V_offsets, total_value_size

def build_node_symbols(G):
    V_symbols = int_array(G.total_value_size)

    def new_symbols(n):
        o = new_symbols.symbol_count
        new_symbols.symbol_count += n
        return list(xrange(o, o+n))
    new_symbols.symbol_count = 0

    for i in xrange(G.nv):
        v = G.V[i]
        #sh = G.V_shapes[i]
        n = G.V_sizes[i]
        o = G.V_offsets[i]

        if isinstance(v, Indexed):
            # Reuse symbols of arg A for Aii
            Aii = v
            A = Aii.operands()[0]

            # Get symbols of argument A
            j = G.e2i[A]
            A_o = G.V_offsets[j]
            A_n = G.V_sizes[j]
            A_symbols = V_symbols[A_o:A_o+A_n]

            # Map A_symbols to Aii_symbols
            d = map_indexed_arg_components(Aii)
            symbols = [A_symbols[k] for k in d]

        elif isinstance(v, ComponentTensor):
            # Reuse symbols of arg Aii for A
            A = v
            Aii = A.operands()[0]

            # Get symbols of argument Aii
            j = G.e2i[Aii]
            Aii_o = G.V_offsets[j]
            Aii_n = G.V_sizes[j]
            Aii_symbols = V_symbols[Aii_o:Aii_o+Aii_n]

            # Map A_symbols to Aii_symbols
            d = map_component_tensor_arg_components(A)
            symbols = [Aii_symbols[k] for k in d]

        elif isinstance(v, ListTensor):
            A = v
            rows = A.operands()
            js = [G.e2i[row] for row in rows]

            if 0:
                symbols = FIXME # Fetch symbols from argument, need mapping between extended shapes
            else:
                symbols = new_symbols(n)

        else:
            # Simply create one new symbol for each scalar component:
            symbols = new_symbols(n)
            # TODO: How/where to handle literals? Maybe use negative symbol indices?
            # TODO: How/where to handle derivatives? Probably want separate symbols for those.
            # TODO: Ignoring symmetries, reuse, etc. at this point

        if len(symbols) != n:
            print "XXX"
            print str(v)
            print symbols
            print "YYY"
        V_symbols[o:o+n] = symbols

    total_unique_symbols = new_symbols.symbol_count
    return V_symbols, total_unique_symbols

class Graph2(object):
    def __init__(self):
        pass

def build_graph(expr, DEBUG=False):
    if DEBUG:
        print "In build_graph:"
        print "expr = ", str(expr)
        print "expr = ", repr(expr)
        print

    # Make empty graph
    G = Graph2()

    # Count unique expression nodes
    G.e2i = build_node_counts(expr)
    G.nv = len(G.e2i)

    # Make a list of the nodes by their ordering
    G.V = build_array_from_counts(G.e2i)
    if DEBUG:
        print "\nV:"
        for i, v in enumerate(G.V):
            print "%d\t%s\t%s" % (i, type(v).__name__, str(v))

    # Compute the total shape (value shape x index dimensions) for each node
    G.V_shapes = build_node_shapes(G.V)
    if DEBUG:
        print "\nV_shapes", G.V_shapes

    # Compute the offsets of nodes into a flattened scalar array
    G.V_sizes, G.V_offsets, G.total_value_size = build_node_offsets(G.V_shapes)
    if DEBUG:
        print "\nV_sizes", G.V_sizes
        print "V_offsets", G.V_offsets
        print "total_value_size", G.total_value_size

    # Mark values with symbols
    G.V_symbols, G.total_unique_symbols = build_node_symbols(G)
    if DEBUG:
        print "\nsymbols:"
        for i, o in enumerate(G.V_offsets):
            print "%d:\t%s" % (i, G.V_symbols[o:o+G.V_sizes[i]])

    # TODO: What more information to generate?
    return G

def rebuild_expression(v, i, G, wops):
    return [0 for k in compute_indices(G.V_shapes[i])]

def rebuild_expression_from_graph(G): # FIXME: Implement something like this
    # Regenerate expression via symbols?
    W = object_array(G.total_unique_symbols)
    for i in xrange(G.nv):
        v = G.V[i]

        # Find symbols of operands
        sops = []
        for j, vop in enumerate(v.operands()):
            if isinstance(vop, UtilityType):
                sops.append(()) # TODO: Not sure how to handle this
            else:
                oi = G.e2i[vop]
                on = G.V_sizes[oi]
                oo = G.V_offsets[oi]
                os = G.V_symbols[oo:oo+on]
                sops.append(os)

        # Find symbols of v
        vn = G.V_sizes[i]
        vo = G.V_offsets[i]
        vs = G.V_symbols[vo:vo+vn]

        # Store expressions for v symbols
        wops = [tuple(W[k] for k in s) for s in sops]
        w = rebuild_expression(v, i, G, wops)
        for j,k in enumerate(vs):
            W[k] = w[j]

    # Find symbols of final v
    i = G.nv-1
    v = G.V[i]
    vn = G.V_sizes[i]
    vo = G.V_offsets[i]
    vs = G.V_symbols[vo:vo+vn]

    w = [W[k] for k in vs]

    return w
