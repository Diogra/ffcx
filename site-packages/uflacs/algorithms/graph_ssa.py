
def build_ssa(G, DEBUG=False):
    V = G.V

    terminalish = (Terminal, Grad, Restricted)

    for i,v in enumerate(V):
        vsyms = [fixme]
        if isinstance(v, terminalish):
            for j,s in enumerate(vsyms):
                todo = """
                if s -> k exists: continue

                allocate ssa index k:
                k = next ssa index

                store reverse mapping:
                s -> k

                store scalar ufl expression:
                k -> ufl expression for terminal (if scalar) or terminal component j (if nonscalar)
                """
        else:
            for j,s in enumerate(vsyms):
                todo = """
                skip existing values:
                if s -> k exists: continue

                find operand indices:
                kops = [k_op for op in operands]

                compute representation of expression:
                rep = operator
                or
                rep = operator(scalar ufl expression for all k_ops)

                allocate ssa index k:
                k = next ssa index

                store reverse mapping:
                s -> k

                store representation of expression k:
                k -> rep

                store scalar ufl expression:
                k -> ufl expression for operator
                """

    pass 


def find_duplications(G): # FIXME
    vis = {}
    dup = {}
    for i,v in enumerate(G.V):
        for j,s in G.V_symbols:
            pass


def mark_used_symbols(symbols, max_symbol, arg_symbols, initially_used_symbols):
    """TASK: Cover this with tests.

    symbols - array of ints, each int representing a symbol
    max_symbol - an int, one larger than the largest symbol
    arg_symbols - mapping from symbol to symbols or arguments
    initially_used_symbols - sequence of symbols to be marked as used initially
    """

    # Initial state where nothing is marked as used
    used_symbols = int_array(max_symbol)
    num_used = 0

    # Seed with initially used symbols
    for s in initially_used_symbols:
        used_symbols[s] = 1 
        num_used += 1

    # Mark dependencies by looping backwards through symbols array
    for j in xrange(len(symbols)-1,-1,-1):
        s = symbols[j]
        if used_symbols[s]:
            for r in arg_symbols[s]:
                if not used_symbols[r]:
                    used_symbols[r] = 1
                    num_used += 1
                    
    # Return array marking which symbols are used and the number of positives
    return used_symbols, num_used

