
def build_ssa(G, DEBUG=False):
    V = G.V

    terminalish = (Terminal, Grad, Restricted)

    for i,v in enumerate(V):
        vsyms = [fixme]
        if isinstance(v, terminalish):
            for j,s in enumerate(vsyms):
                todo = """
                if s -> k exists: continue

                allocate ssa index k:
                k = next ssa index

                store reverse mapping:
                s -> k

                store scalar ufl expression:
                k -> ufl expression for terminal (if scalar) or terminal component j (if nonscalar)
                """
        else:
            for j,s in enumerate(vsyms):
                todo = """
                skip existing values:
                if s -> k exists: continue

                find operand indices:
                kops = [k_op for op in operands]

                compute representation of expression:
                rep = operator
                or
                rep = operator(scalar ufl expression for all k_ops)

                allocate ssa index k:
                k = next ssa index

                store reverse mapping:
                s -> k

                store representation of expression k:
                k -> rep

                store scalar ufl expression:
                k -> ufl expression for operator
                """

    pass 


# TODO: This is probably useless, and not tested:
def find_duplications(V, dependencies, active):
    """Assuming no terminal duplications, find duplications among operators."""
    visited = {}
    dup = {}
    for i,v in enumerate(V):
        if active[i]:
            key = (type(v), tuple(dependencies[i]))
            orig = visited.get(key)
            if orig is None:
                visited[key] = i
            else:
                dup[i] = orig
                active[i] = 0


def mark_active(max_symbol, dependencies, initially_active):
    """FIXME: Cover this with tests.

    Input:
    - max_symbol       - The number of symbols, assumed contiguous in [0,max_symbols).
    - dependencies     - CRS of ints, a mapping from symbol to symbols of arguments.
    - initially_active - Sequence of symbols to be marked as used initially.

    Output:
    - active   - Truth value for each symbol.
    - num_used - Number of true values in active array.
    """

    # Initial state where nothing is marked as used
    active = int_array(max_symbol)
    num_used = 0

    # Seed with initially used symbols
    for s in initially_active:
        active[s] = 1 
        num_used += 1

    # Mark dependencies by looping backwards through symbols array
    for s in xrange(max_symbol-1,-1,-1):
        if active[s]:
            for r in dependencies[s]:
                if not active[r]:
                    active[r] = 1
                    num_used += 1

    # Return array marking which symbols are used and the number of positives
    return active, num_used


def default_partition_seed(expr):
    modifiers = (Grad, Restricted, Indexed)
    if isinstance(expr, modifiers):
        return default_partition_seed(expr.operands()[0])
    elif isinstance(expr, Argument):
        return 3
    elif isinstance(expr, Coefficient):
        return 2
    elif isinstance(expr, GeometryQuantity):
        return 1
    else: # Must be a literal (TODO: Assert or check more narrowly)
        return 0

def mark_partitions(V, active, dependencies,
                    partition_seed=default_partition_seed,
                    partition_combiner=max):
    """FIXME: Cover this with tests.

    Input:
    - V            - Array of expressions.
    - active       - Boolish array.
    - dependencies - CRS with V dependencies.
    - partition_seed - Policy for determining the partition of a terminalish.
    - partition_combiner - Policy for determinging the partition of an operator.

    Output:
    - partitions   - Array of partition int ids.
    """
    n = len(V)
    assert len(active) == n
    assert len(dependencies) == n
    partitions = int_array(n)
    for i, v in enumerate(V):
        deps = dependencies[i]
        if active[i]:
            if deps:
                p = partition_combiner([partitions[d] for d in deps])
            else:
                p = partition_seed(v)
        else:
            p = -1
        partitions[i] = p
    return partitions


def compute_dependency_count(dependencies):
    """FIXME: Test"""
    n = len(dependencies)
    depcount = int_array(n)
    for i in xrange(n):
        for d in dependencies[i]:
            depcount[d] += 1
    return depcount

def invert_dependencies(dependencies, depcount):
    """FIXME: Test"""
    n = len(dependencies)
    m = sum(depcount)
    invdeps = [()]*n
    for i in xrange(n):
        for d in dependencies[i]:
            invdeps[d] = invdeps[d] + (i,)
    return rows_to_crs(invdeps, n, m, int)

def default_cache_score_policy(vtype, ndeps, ninvdeps, partition):
    # Start at 1 and then multiply with various heuristic factors
    s = 1

    # Is the type particularly expensive to compute?
    expensive = (MathFunction,)
    if vtype in expensive: # Could make a type-to-cost mapping, but this should do.
        s *= 20

    # More deps roughly correlates to more operations
    s *= ndeps

    # If it is reused several times let that count significantly
    s *= ninvdeps**3 # 1->1, 2->8, 3->27

    # Finally let partition count for something?
    # Or perhaps we need some more information, such as
    # when x from outer loop is used by y within inner loop.

    return s

def compute_cache_scores(V, active, dependencies, inverse_dependencies, partitions,
                         cache_score_policy=default_cache_score_policy):
    """FIXME: Cover with tests.

    TODO: Experiment with heuristics later when we have functional code generation.
    """
    n = len(V)
    score = int_array(n)
    for i,v in enumerate(V):
        if active[i]:
            deps = dependencies[i]
            ndeps = len(deps)
            invdeps = inverse_dependencies[i]
            ninvdeps = len(invdeps)
            p = partitions[i]
            s = cache_score_policy(type(v), ndeps, ninvdeps, p)
        else:
            s = -1
        score[i] = s
    return score

import heapq
def allocate_registers(active, partitions, scores, max_registers, score_threshold):
    """FIXME: Cover with tests.

    TODO: Allow reuse of registers, reducing memory usage.

    TODO: The ordering of register usage here is arbitrary,
          and may not be very cache friendly.
    """
    # Analyse scores
    n = len(scores)
    min_score = min(scores)
    max_score = max(scores)
    mean_score = sum(scores) // n

    # For now, just using an arbitrary heuristic algorithm to select m largest scores
    queue = [(-score[i], i) for i in xrange(n) if active[i]]
    heapq.heapify(queue)

    # Allocate one register each for max_registers largest symbols
    allocations = int_array(max_registers)
    for r in max_registers:
        s, i = heapq.heappop(queue)
        if -s < score_threshold:
            break
        allocations[i] = r

    # Possible data structures for improved register allocations
    #register_status = int_array(max_registers)

    # Stack/set of free registers (should wrap in stack abstraction):
    #free_registers = int_array(max_registers)
    #num_free_registers = max_registers
    #free_registers[:] = reversed(xrange(max_registers))

    return allocations
