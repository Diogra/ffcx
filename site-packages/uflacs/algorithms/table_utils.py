
import numpy as np

default_tolerance = 1e-14

def equal_tables(a, b, eps=default_tolerance):
    "Compare tables to be equal within a tolerance."
    a = np.asarray(a)
    b = np.asarray(b)
    if a.shape != b.shape:
        return False
    if len(a.shape) > 1:
        return all(equal_tables(a[i], b[i], eps) for i in range(a.shape[0]))
    def scalars_equal(x, y, eps):
        return abs(x-y) < eps
    return all(scalars_equal(a[i], b[i], eps) for i in range(a.shape[0]))

def strip_table_zeros(table, eps=default_tolerance):
    "Strip zero columns from table. Returns column range (begin,end) and the new compact table."
    # Get shape of table and number of columns, defined as the last axis
    table = np.asarray(table)
    sh = table.shape
    nc = sh[-1]

    # Find first nonzero column
    begin = nc
    for i in range(nc):
        if np.linalg.norm(table[...,i]) > eps:
            begin = i
            break

    # Find (one beyond) last nonzero column
    end = begin
    for i in range(nc-1,begin-1,-1):
        if np.linalg.norm(table[...,i]) > eps:
            end = i+1
            break

    # Make subtable by stripping first and last columns
    return begin, end, table[...,begin:end]

def build_unique_tables(tables):
    """Given an ordered list of tables, return a list of unique tables
    and a list of unique table indices for each input table."""
    unique = []
    mapping = [None]*len(tables)
    for j,t in enumerate(tables):
        found = -1
        for i,u in enumerate(unique):
            if equal_tables(u, t):
                found = i
                break
        if found == -1:
            i = len(unique)
            unique.append(t)
        mapping[j] = i
    return unique, mapping

def get_ffc_table_values(tables, entitytype, num_points, element, component, derivatives):
    """Extract values from ffc element table.

    Returns a 3D numpy array with axes
    (entity number, quadrature point number, dof number)
    """
    # Get quadrule/element subtable
    element_table = tables[num_points][element]

    # Figure out shape of final array by inspecting tables
    num_entities = len(element_table)
    num_dofs = len(element_table[list(element_table.keys())[0]][derivatives])

    # Make 3D array for final result
    shape = (num_entities, num_points, num_dofs)
    res = np.zeros(shape)

    # Loop over entities and fill table blockwise (each block = points x dofs)
    sh = element.value_shape()
    for entity in range(num_entities):
        # Access subtable
        entity_key = None if entitytype == "cell" else entity
        tbl = element_table[entity_key][derivatives]

        # Extract array for right component and order axes as (points, dofs)
        if sh == ():
            arr = np.transpose(tbl)
        else:
            arr = np.transpose(tbl[:,component,:])

        # Assign block of values for this entity
        res[entity, :, :] = arr
    return res


def _analyze(table):

    begin, end, table = strip_table_zeros(table)
    all_zeros = table.shape[-1] == 0
    all_ones = equal_tables(table, np.ones(table.shape))
