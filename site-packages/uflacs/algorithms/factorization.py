
from ufl.classes import Terminal, Indexed, Grad, Restricted, Argument, Product, Sum, Division

def strip_modified_terminal(v):
    "Extract core Terminal from a modified terminal or return None."
    while not isinstance(v, Terminal):
        if isinstance(v, (Indexed, Grad, Restricted)):
            v = v.operands()[0]
        else:
            return None
    return v

def build_argument_component_sets(SV):
    "Build mapping {argument_count: {vertex_number: modified_terminal}} with all argument vertices."
    arg_sets = {}
    for i,v in enumerate(SV):
        a = strip_modified_terminal(v)
        if not isinstance(a, Argument):
            continue
        c = a.count()
        s = arg_sets.get(c)
        if s is None:
            s = {}
            arg_sets[c] = s
        s[i] = v
    return arg_sets

def build_valid_argument_combinations(arg_sets):
    "Build all valid permuations of argument products combinations."
    if not arg_sets:
        return []
    counts = sorted(arg_sets.keys())
    arg_indices = set(arg_sets[counts[0]])
    arg_combos = [(i,) for i in sorted(arg_indices)]
    for c in counts[1:]:
        js = sorted(arg_sets[c])
        arg_indices.update(js)
        arg_combos = [comb + (j,) for comb in arg_combos for j in js]
    return arg_indices, arg_combos

def build_argument_dependencies(SV, dependencies, arg_indices):
    "Preliminary algorithm: build list of argument vertex indices each vertex (indirectly) depends on."
    A = [[] for i in range(len(SV))] # TODO: Use array
    for i,v in enumerate(SV):
        deps = dependencies[i]
        argdeps = []
        for j in deps:
            if j in arg_indices:
                argdeps.append(j)
            else:
                argdeps.extend(A[j])
        A[i] = sorted(argdeps)
    return A

def collect_argument_factors(SV, dependencies, arg_indices):
    "TODO:"
    # TODO: Instead of argdeps being a list of argument vertex indices v (indirectly) depends on,
    #       it should be a mapping { combo: factors } to handle e.g. (u + fu')(gv + v')

    A = [None]*len(SV) # TODO: Use array
    for i,v in enumerate(SV):
        deps = dependencies[i]

        if len(deps):
            if isinstance(v, Product):
                fac0 = A[deps[0]]
                fac1 = A[deps[1]]
                factors = {}
                # TODO: Concatenate tuples in both keys and values of fac0 and fac1 for all permutations of their items. That's about it? See Sum for complications...
                print "TODO: Product:", i, str(v)
                print fac0
                print fac1
                notimplemented
            elif isinstance(v, Sum):
                fac0 = A[deps[0]]
                fac1 = A[deps[1]]
                factors = {}
                # TODO: Merge items in fac0 and fac1, if they share keys we need to represent (a + b) in the values... Not sure how this will work out...
                print "TODO: Sum:", i, str(v)
                print fac0
                print fac1
                notimplemented
            elif isinstance(v, Division):
                # TODO: Handle v/f as v*(1/f)
                notimplemented
            else:
                # TODO: Check
                notimplemented
        else:
            if i in arg_indices:
                factors = { (i,): () }
            else:
                factors = {}

        print 'fac:', i, factors
        A[i] = factors

    return A

def compute_argument_factorization(SV, svs, dependencies):
    if 0: # Disable algorithm
        return None, None

    arg_sets = build_argument_component_sets(SV)

    arg_indices, valid_arg_combos = build_valid_argument_combinations(arg_sets)

    A = build_argument_dependencies(SV, dependencies, arg_indices)

    if 1:
        print 'SV:'
        print '\n'.join("%d: %s" % (i,v) for i,v in enumerate(SV))
        print 'svs:'
        print svs
        print 'dependencies:'
        print dependencies
        print 'arg_sets:'
        print '\n'.join(map(str,arg_sets.items()))
        print 'arg_indices:'
        print arg_indices
        print 'valid_arg_combos:'
        print valid_arg_combos
        print 'A:'
        print A

    F = collect_argument_factors(SV, dependencies, arg_indices)
    print 'F:'
    print F

    return F, arg_sets
