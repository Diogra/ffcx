
from itertools import izip
from ufl.common import product
from ufl.permutation import compute_indices

import ufl
from ufl import as_vector
from ufl.classes import (Terminal, FormArgument, Grad, Restricted,
                         Indexed, ComponentTensor, ListTensor, Transposed, Variable,
                         IndexSum, MultiIndex,
                         UtilityType, Label, Data)

from uflacs.utils.assertions import error
from uflacs.algorithms.datastructures import (int_array, object_array,
                                              CRS, rows_to_crs, rows_dict_to_crs)
#from uflacs.algorithms.indexing import *

def build_ssa(G, DEBUG=False):
    V = G.V

    terminalish = (Terminal, Grad, Restricted)

    for i,v in enumerate(V):
        vsyms = [fixme]
        if isinstance(v, terminalish):
            for j,s in enumerate(vsyms):
                todo = """
                if s -> k exists: continue

                allocate ssa index k:
                k = next ssa index

                store reverse mapping:
                s -> k

                store scalar ufl expression:
                k -> ufl expression for terminal (if scalar) or terminal component j (if nonscalar)
                """
        else:
            for j,s in enumerate(vsyms):
                todo = """
                skip existing values:
                if s -> k exists: continue

                find operand indices:
                kops = [k_op for op in operands]

                compute representation of expression:
                rep = operator
                or
                rep = operator(scalar ufl expression for all k_ops)

                allocate ssa index k:
                k = next ssa index

                store reverse mapping:
                s -> k

                store representation of expression k:
                k -> rep

                store scalar ufl expression:
                k -> ufl expression for operator
                """

    pass 


def find_duplications(G): # FIXME
    vis = {}
    dup = {}
    for i,v in enumerate(G.V):
        for j,s in G.V_symbols:
            pass


def mark_used_symbols(symbols, max_symbol, arg_symbols, initially_used_symbols):
    """TASK: Cover this with tests.

    symbols - array of ints, each int representing a symbol
    max_symbol - an int, one larger than the largest symbol
    arg_symbols - mapping from symbol to symbols or arguments
    initially_used_symbols - sequence of symbols to be marked as used initially
    """

    # Initial state where nothing is marked as used
    used_symbols = int_array(max_symbol)
    num_used = 0

    # Seed with initially used symbols
    for s in initially_used_symbols:
        used_symbols[s] = 1 
        num_used += 1

    # Mark dependencies by looping backwards through symbols array
    for j in xrange(len(symbols)-1,-1,-1):
        s = symbols[j]
        if used_symbols[s]:
            for r in arg_symbols[s]:
                if not used_symbols[r]:
                    used_symbols[r] = 1
                    num_used += 1
                    
    # Return array marking which symbols are used and the number of positives
    return used_symbols, num_used





def rebuild_expression(v, i, G, wops):
    if isinstance(v, Sum):
        return sum(wops)
    if isinstance(v, Product):
        return product(wops)
    if isinstance(v, Power):
        a,b = wops
        return a**b
    return [0 for k in compute_indices(G.V_shapes[i])]

def rebuild_expression_from_graph(G): # FIXME: Implement something like this
    # Regenerate expression via symbols?
    W = object_array(G.total_unique_symbols)
    terminalish = (Terminal, Grad, Restricted)
    for i,v in enumerate(G.V):
        # Find symbols of v
        vs = G.V_symbols[i]

        # Skip if there's nothing new here        
        if all(W[s] is None for s in vs):
            continue

        if isinstance(v, terminalish):
            # Store terminal expression component
            if v.shape() == ():
                j = 0
                s, = vs
                u = v
                W[s] = u
            else:
                for s,c in izip(vs,compute_indices(v.shape())):
                    u = v[c]
                    W[s] = u
        else:
            # Find symbols of operands
            sops = []
            for j, vop in enumerate(v.operands()):
                if isinstance(vop, UtilityType):
                    error("Not expected.")
                    sops.append(()) # TODO: Not sure how to handle this
                else:
                    os = G.V_symbols[G.e2i[vop]]
                    sops.append(os)

            # Store expressions for v symbols
            sh = v.shape()
            if sh == ():
                wops = [W[s[0]] for s in sops]
                w = v.reconstruct(*wops)
                k, = vs
                W[k] = w
            else:
                FIXME
                wops = [tuple(W[k] for k in s) for s in sops]
                w = rebuild_expression(v, i, G, wops)
                for j,k in enumerate(vs):
                    W[k] = w[j]

    # Find symbols of final v
    vs = G.V_symbols[G.nv-1]
    w = [W[k] for k in vs]
    return w


def rebuild_expression(v, i, G, wops):
    if isinstance(v, Sum):
        return sum(wops)
    if isinstance(v, Product):
        return product(wops)
    if isinstance(v, Power):
        a,b = wops
        return a**b
    return [0 for k in compute_indices(G.V_shapes[i])]

def reconstruct_scalar_subexpressions(v, uops): # FIXME FIXME FIXME!!! Implement this as a MultiFunction for all types.
    """
    v is a ufl expression
    uops is a list of expressions
    """
    sh = v.shape()
    if sh == ():
        if isinstance(v, ufl.classes.Sum):
            ops = [op[0] for op in uops]
            return [sum(ops)]
        elif isinstance(v, ufl.classes.Product):
            ops = [op[0] for op in uops]
            return [product(ops)]
        elif isinstance(v, (ufl.classes.Power, ufl.classes.Division)):
            a, b = uops[0][0], uops[1][0]
            return [v.reconstruct(a,b)]
        elif isinstance(v, ufl.classes.MathFunction):
            a = uops[0][0]
            return [v.reconstruct(a)]
        else:
            error("This type not implemented yet: %s." % type(v))
    else:
        error("Tensor valued expressions not implemented here yet!") # FIXME XXX
        return list(compute_indices(sh))

def rebuild_scalar_e2i(G):
    #G.e2i
    #G.V
    #G.V_symbols
    #G.total_unique_symbols

    # Data structures
    ne2i = {}
    NV = object_array(G.total_unique_symbols)
    W = object_array(G.total_unique_symbols)
    terminals = set()

    # Some type groups used below
    indexish = (Indexed, ComponentTensor, ListTensor, Transposed, Variable)
    unexpected = (MultiIndex, Data, Label) + indexish
    terminalish = (Terminal, Grad, Restricted)

    def emit_expression(s, u):
        # Allocate count for scalar expression and
        # store in all cross referenced data structures
        j = ne2i.get(u)
        if j is None:
            j = len(ne2i)
            ne2i[u] = j
            NV[j] = u
        W[s] = u
        print 'emitted', s, j, u

    handled_symbols = int_array(G.total_unique_symbols)
    for i,v in enumerate(G.V):
        # Find symbols of v components
        vs = G.V_symbols[i]

        print ';;;;;;;', i, v, vs

        # Skip if there's nothing new here (should be the case for indexing types)
        if all(handled_symbols[s] for s in vs):
            continue
        #if all(W[s] is not None for s in vs):
        #    continue
        if isinstance(v, unexpected):
            error("Not expecting a %s here!" % type(v))

        for s in vs:
            handled_symbols[s] = 1

        if isinstance(v, terminalish):
            terminals.add(v)
            sh = v.shape()
            if sh == ():
                # Store single terminal expression component
                assert len(vs) == 1
                s, u = vs[0], v
                emit_expression(s, u)
            else:
                # Store each terminal expression component
                for s, c in izip(vs, compute_indices(sh)):
                    u = v[c]
                    emit_expression(s, u)
        else:
            # Find symbols of operands
            sops = []
            for j, vop in enumerate(v.operands()):
                if isinstance(vop, MultiIndex):
                    assert isinstance(v, IndexSum)
                    error("FIXME: Currently not handling IndexSum in here.")
                so = G.V_symbols[G.e2i[vop]]
                sops.append(so)
            # Fetch reconstructed operand expressions
            wops = [tuple(W[k] for k in so) for so in sops]

            # Reconstruct scalar subexpressions of v
            w = reconstruct_scalar_subexpressions(v, wops)
            # Store all scalar subexpressions for v symbols
            for s,u in izip(vs,w):
                emit_expression(s, u)

    # Find symbols of final v
    vs = G.V_symbols[G.nv-1]
    assert all(handled_symbols[s] for s in vs)
    if 0: # DEBUGGING:
        nvs = []
        for s in vs:
            o = W[s]
            print '---', s, o
            nvs.append(ne2i[o])
    else:
        nvs = [ne2i[W[s]] for s in vs] # FIXME: test!

    return ne2i, NV, W, terminals, nvs # FIXME: Which returnees do we need?

def rebuild_expression_from_graph(G): # FIXME: Test me!
    ne2i, NV, W, terminals, nvs = rebuild_scalar_e2i(G)
    # Find expressions of final v
    w = [NV[k] for k in nvs]
    if len(w) == 1:
        return w[0]
    else:
        return as_vector(w) # TODO: Consider shape of initial v
