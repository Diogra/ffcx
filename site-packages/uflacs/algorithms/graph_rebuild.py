
from itertools import izip
from ufl.common import product
from ufl.permutation import compute_indices

import ufl
from ufl import as_vector
from ufl.classes import (Terminal, FormArgument, Grad, Restricted,
                         Indexed, ComponentTensor, ListTensor, Transposed, Variable,
                         IndexSum, MultiIndex,
                         UtilityType, Label, Data)
from ufl.algorithms import MultiFunction

from uflacs.utils.assertions import error
from uflacs.algorithms.datastructures import (int_array, object_array,
                                              CRS, rows_to_crs, rows_dict_to_crs)
#from uflacs.algorithms.indexing import *

class ReconstructScalarSubexpressions(MultiFunction):
    def __init__(self):
        super(ReconstructScalarSubexpressions, self).__init__()

    def expr(self, o, *args, **kwargs):
        error("No handler for type %s" % type(o))

    def terminal(self, o):
        error("Not expecting terminal expression in here, got %s." % type(o))

    def scalar_nary(self, o, ops):
        assert o.shape() == ()
        sops = [op[0] for op in ops]
        return [o.reconstruct(*sops)]

    # Unary scalar functions
    math_function = scalar_nary
    abs = scalar_nary
    # Binary scalar functions
    division = scalar_nary
    power = scalar_nary

    def element_wise(self, scalar_operator, o, ops):
        # Products of a scalar and a tensor are allowed
        n = max(len(op) for op in ops)
        assert all(len(op) in (1,n) for op in ops)
        # Compute each scalar value
        res = []
        for k in xrange(n):
            sops = []
            for op in ops:
                if len(op) == 1:
                    sops.append(op[0])
                else:
                    assert len(op) == n
                    sops.append(op[k])
            res.append(scalar_operator(sops))
        return res

    def sum(self, o, ops):
        return self.element_wise(sum, o, ops)

    def product(self, o, ops):
        return self.element_wise(product, o, ops)

    # TODO: To implement IndexSum, and eventually dot, inner, etc.,
    # we need to identify which index to do the contractions over

    def index_sum(self, o, ops):
        e, mi = ops
        sh = o.shape()
        if sh == ():
            return sum(e)
        else:
            error("Not implemented!")

def rebuild_scalar_e2i(G, DEBUG=False):
    #G.e2i
    #G.V
    #G.V_symbols
    #G.total_unique_symbols

    # Data structures
    ne2i = {}
    NV = object_array(G.total_unique_symbols)
    W = object_array(G.total_unique_symbols)
    terminals = set()

    # Some type groups used below
    indexish = (Indexed, ComponentTensor, ListTensor, Transposed, Variable)
    unexpected = (MultiIndex, Data, Label) + indexish
    terminalish = (Terminal, Grad, Restricted)

    def emit_expression(s, u):
        # Allocate count for scalar expression and
        # store in all cross referenced data structures
        j = ne2i.get(u)
        if j is None:
            j = len(ne2i)
            ne2i[u] = j
            NV[j] = u
        W[s] = u
        if DEBUG: print 'emitted s, j, u:', s, j, u

    reconstruct_scalar_subexpressions = ReconstructScalarSubexpressions()

    handled_symbols = int_array(G.total_unique_symbols)
    for i,v in enumerate(G.V):
        # Find symbols of v components
        vs = G.V_symbols[i]

        if DEBUG: print '\n\n:: i, v, vs ::', i, v, vs

        # Skip if there's nothing new here (should be the case for indexing types)
        if all(handled_symbols[s] for s in vs):
            continue
        #if all(W[s] is not None for s in vs):
        #    continue
        if isinstance(v, unexpected):
            error("Not expecting a %s here!" % type(v))

        for s in vs:
            handled_symbols[s] = 1

        if isinstance(v, terminalish):
            terminals.add(v)
            sh = v.shape()
            assert v.free_indices() == ()
            if sh == ():
                # Store single terminal expression component
                assert len(vs) == 1
                s, u = vs[0], v
                emit_expression(s, u)
            else:
                # Store each terminal expression component
                for s, c in izip(vs, compute_indices(sh)):
                    u = v[c]
                    emit_expression(s, u)
        else:
            # Find symbols of operands
            sops = []
            for j, vop in enumerate(v.operands()):
                if isinstance(vop, MultiIndex):
                    assert isinstance(v, IndexSum)
                    error("FIXME: Currently not handling IndexSum in here.")
                so = G.V_symbols[G.e2i[vop]]
                sops.append(so)

            # Fetch reconstructed operand expressions
            wops = [tuple(W[k] for k in so) for so in sops]

            # Reconstruct scalar subexpressions of v
            w = reconstruct_scalar_subexpressions(v, wops)

            # Store all scalar subexpressions for v symbols
            assert len(vs) == len(w)
            for s,u in izip(vs,w):
                emit_expression(s, u)

    # Find symbols of final v
    vs = G.V_symbols[G.nv-1]
    assert all(handled_symbols[s] for s in vs)
    nvs = [ne2i[W[s]] for s in vs]

    return ne2i, NV, W, terminals, nvs # FIXME: Which returnees do we need?

def rebuild_expression_from_graph(G, DEBUG=False): # FIXME: Test me!
    ne2i, NV, W, terminals, nvs = rebuild_scalar_e2i(G, DEBUG)
    # Find expressions of final v
    w = [NV[k] for k in nvs]
    if len(w) == 1:
        return w[0]
    else:
        return as_vector(w) # TODO: Consider shape of initial v
