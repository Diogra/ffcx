
from ufl.common import unique_post_traversal
from ufl.classes import Terminal, UtilityType
from ufl.algorithms.traversal import traverse_terminals

from uflacs.utils.assertions import error
from uflacs.algorithms.datastructures import (int_array, object_array,
                                              CRS, rows_to_crs, rows_dict_to_crs)
#from uflacs.algorithms.indexing import *


def count_nodes_with_unique_post_traversal(expr):
    """Yields o for each node o in expr, child before parent. Never visits a node twice."""
    stack = []
    stack.append((expr, list(expr.operands())))
    visited = {}
    while stack:
        expr, ops = stack[-1]
        for i, o in enumerate(ops):
            if o is not None and o not in visited:
                stack.append((o, list(o.operands())))
                ops[i] = None
                break
        else:
            if not isinstance(expr, UtilityType):
                count = len(visited)
                visited[expr] = count
            stack.pop()
    return visited

def build_node_counts(expr):
    return count_nodes_with_unique_post_traversal(expr)

def build_node_counts2(expr):
    "Build a dict mapping unique Expr node -> unique count."
    i = 0
    e2i = {}

    # Terminals first... (TODO: Not really necessary, but nice, or?)
    for e in traverse_terminals(expr):
        if isinstance(e, UtilityType):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1

    # ... then the rest
    missed = 0
    for e in unique_post_traversal(expr):
        if isinstance(e, Terminal):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1
        else:
            missed += 1
    print 'nodes:  ', i
    print 'misses: ', missed

    assert len(e2i) == i
    return e2i

def build_array_from_counts(e2i):
    nv = len(e2i)
    V = object_array(nv)
    for e,i in e2i.iteritems():
        V[i] = e
    return V

def build_graph_vertices(expr, DEBUG=False):
    # Count unique expression nodes
    e2i = build_node_counts(expr)

    # Make a list of the nodes by their ordering
    V = build_array_from_counts(e2i)

    return e2i, V
