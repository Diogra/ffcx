
from ufl.common import unique_post_traversal
from ufl.classes import (Terminal, UtilityType,
                         Grad, Restricted, Indexed)
from ufl.algorithms.traversal import traverse_terminals

from uflacs.utils.assertions import error
from uflacs.algorithms.datastructures import (int_array, object_array,
                                              CRS, rows_to_crs, rows_dict_to_crs)
#from uflacs.algorithms.indexing import *


def count_nodes_with_unique_post_traversal(expr, visited=None,
                                           skip_terminal_modifiers=False):
    """Yields o for each node o in expr, child before parent.
    Never visits a node twice."""

    if skip_terminal_modifiers:
        terminalish = (Terminal,Grad,Restricted,Indexed)
    else:
        terminalish = (Terminal,)

    def getops(e):
        if isinstance(e, terminalish):
            return []
        else:
            return list(e.operands())

    stack = []
    stack.append((expr, getops(expr)))
    visited = visited if visited is not None else {}
    while stack:
        expr, ops = stack[-1]
        for i, o in enumerate(ops):
            if o is not None and o not in visited:
                stack.append((o, getops(o)))
                ops[i] = None
                break
        else:
            if not isinstance(expr, UtilityType):
                count = len(visited)
                visited[expr] = count
            stack.pop()
    return visited

def build_node_counts(expr):
    return count_nodes_with_unique_post_traversal(expr)

def build_node_counts2(expr):
    "Build a dict mapping unique Expr node -> unique count."
    i = 0
    e2i = {}

    # Terminals first... (TODO: Not really necessary, but nice, or?)
    for e in traverse_terminals(expr):
        if isinstance(e, UtilityType):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1

    # ... then the rest
    missed = 0
    for e in unique_post_traversal(expr):
        if isinstance(e, Terminal):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1
        else:
            missed += 1
    print 'nodes:  ', i
    print 'misses: ', missed

    assert len(e2i) == i
    return e2i

def build_array_from_counts(e2i):
    nv = len(e2i)
    V = object_array(nv)
    for e,i in e2i.iteritems():
        V[i] = e
    return V

def build_graph_vertices(expr, DEBUG=False):
    # Count unique expression nodes
    e2i = build_node_counts(expr)

    # Make a list of the nodes by their ordering
    V = build_array_from_counts(e2i)

    return e2i, V

def build_scalar_graph_vertices(expressions):
    # Count unique expression nodes across multiple expressions
    visited = {}
    for expr in expressions:
        e2i = count_nodes_with_unique_post_traversal(expr, visited, True)
    assert e2i is visited

    # Make a list of the nodes by their ordering
    V = build_array_from_counts(e2i)

    # Get indices representing input expressions
    vs = [e2i[expr] for expr in expressions]

    return e2i, V, vs
