
from ufl.classes import Terminal, UtilityType, Grad,SpatialDerivative,Restricted
from ufl.algorithms import expand_derivatives, expand_compounds
from uflacs.codeutils.format_code_structure import format_code_structure
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules, CppDefaultFormatter
from uflacs.algorithms.graph import build_graph, int_array
from time import time

def compile_element(element, prefix):
    return "// TODO: Compile element %s" % str(element)

def compile_expression(expr, prefix):
    return "// TODO: Compile expression %s" % str(expr)

_ticdata = []
def tic(msg):
    print "Starting:", msg
    _ticdata.append((time(), msg))
def ticend():
    _ticdata.append((time(), "END"))
def ticprint():
    global _ticdata
    for i in range(len(_ticdata)-1):
        t1, msg = _ticdata[i]
        t2 = _ticdata[i+1][0]
        t = t2-t1
        print "%9.1e s   %s" % (t, msg)
    _ticdata = []

def compile_form(form, prefix):

    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    # First we preprocess the form
    tic('expand_compounds')
    form = expand_compounds(form)
    tic('expand_derivatives')
    form = expand_derivatives(form,
                              apply_expand_compounds_before=False,
                              apply_expand_compounds_after=False,
                              use_alternative_wrapper_algorithm=False)

    # Compute the signature
    tic('signature')
    signature = form.signature()

    # We'll place all code in a list while building the program
    code = []

    # Then we iterate over the integrals
    for iitg, itg in enumerate(form.integrals()):
        # Fetch the expression
        integrand = itg.integrand()

        # And build the computational graph of the expression
        tic('integral %d build_graph' % iitg)
        G = build_graph(integrand)

        def gen_code(cl, sops):
            #vcode = expr_formatter.visit(v)
            #vcode = cpp_formatter(...)
            vcode = "%s(%s)" % (cl.__name__, ', '.join(map(str,sops)))
            return vcode

        integral_code = []
        print "Now generating code for %d nodes" % G.nv
        tenpercent = (G.nv // 10) 
        generated = int_array(G.total_unique_symbols)
        for i, v in enumerate(G.V):
            if tenpercent and i % tenpercent == 0:
                print "Progress: %d0 %%" % (i // tenpercent)
                tic('integral %d progress %d0 %%' % (iitg, (i // tenpercent)))

            # Get properties of this node from graph
            vo = G.V_offsets[i]
            vn = G.V_sizes[i]
            vs = G.V_symbols[vo:vo+vn]

            if any(not generated[s] for s in vs):
                if isinstance(v, (Terminal,Grad,SpatialDerivative,Restricted)):
                    # Generate code for this node
                    for j, s in enumerate(vs):
                        if not generated[s]:
                            generated[s] = 1
                            vname = "s[%d]" % s
                            vcode = gen_code(v._uflclass, ())
                            integral_code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

                elif 0:
                    # Find properties of children from graph
                    iops = []
                    sops = []
                    for o in v.operands():
                        if isinstance(o, UtilityType):
                            iops.append(o)
                            sops.append(o)
                        else:
                            j = G.e2i[o]
                            jo = G.V_offsets[j]
                            jn = G.V_sizes[j]
                            js = G.V_symbols[jo:jo+jn]
                            iops.append(j)
                            sops.append(js)
    
                    # Generate code for this node
                    for j, s in enumerate(vs):
                        if not generated[s]:
                            generated[s] = 1
                            vname = "s[%d]" % s
                            vcode = gen_code(v._uflclass, sops)
                            integral_code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

        # Join code to what we have
        code.append(integral_code)
    tic('formatting')
    formatted = format_code_structure(code)
    ticend()
    ticprint()
    return formatted
