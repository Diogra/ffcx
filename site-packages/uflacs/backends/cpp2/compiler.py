
import ufl
from ufl.classes import (Terminal, UtilityType, FormArgument,
                         Grad, SpatialDerivative, Restricted, Indexed)
from ufl.algorithms import expand_derivatives, expand_compounds
from ufl.algorithms.ad import expand_derivatives1, expand_derivatives2

from uflacs.utils.assertions import error
from uflacs.codeutils.format_code_structure import format_code_structure
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules, CppDefaultFormatter
from uflacs.algorithms.datastructures import int_array, object_array
from uflacs.algorithms.graph import build_graph
from uflacs.algorithms.graph_rebuild import rebuild_scalar_e2i

from time import time

def compile_element(element, prefix): # Makes no sense in here really
    return "// TODO: Compile element %s" % str(element)


def compile_expression_lines2(uexpr):
    lines = []
    finals = []

    if isinstance(uexpr, ufl.classes.Terminal):

        if isinstance(uexpr, ufl.classes.IntValue):
            code =  "%d" % (uexpr.value(),)
            finals.append(code)

        elif isinstance(uexpr, ufl.classes.FloatValue):
            code =  "%g" % (uexpr.value(),)
            finals.append(code)

        elif isinstance(uexpr, ufl.classes.Zero):
            code =  "0"
            finals.append(code)

        elif isinstance(uexpr, ufl.classes.Circumradius):
            code =  "h"
            finals.append(code)

        else:
            error("%s not covered yet" % type(uexpr))

    else:
        if isinstance(uexpr, ufl.classes.Sum):
            code = "+"
            finals.append(code)

        else:
            error("%s not covered yet" % type(uexpr))

    return lines, finals


def compile_expression_lines(expr):
    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    # First we replace inner, dot, etc. with lower level representations
    expr = expand_compounds(expr)

    # Then we evaluate the derivatives up to unknown terminal derivatives
    expr = expand_derivatives2(expr,
                                apply_expand_compounds_before=False,
                                apply_expand_compounds_after=False,
                                use_alternative_wrapper_algorithm=True)

    # And build the computational graph of the expression
    G = build_graph(expr)

    # We'll place all code in a list while building the program
    code = []

    def gen_code(cl, sops):
        #vcode = expr_formatter.visit(v)
        #vcode = cpp_formatter(...)
        #vcode = "%s(%s)" % (cl.__name__, ', '.join(map(str,sops)))
        vcode = cpp_formatter(cl, *["s%d" % s for s in sops])
        return vcode

    print "Now generating code for %d nodes" % G.nv

    generated = int_array(G.total_unique_symbols)

    for i, v in enumerate(G.V):

        # Get properties of this node from graph
        vs = G.V_symbols[i]
        vn = len(vs)

        if any(not generated[s] for s in vs):
            if isinstance(v, (Terminal,Grad,SpatialDerivative,Restricted)):
                # Generate code for this node
                for j, s in enumerate(vs):
                    if not generated[s]:
                        generated[s] = 1
                        vname = "s[%d]" % s
                        vcode = gen_code(v, ())
                        if 1: code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

            elif 1:
                # Find properties of children from graph
                iops = []
                sops = []
                for o in v.operands():
                    if isinstance(o, UtilityType):
                        iops.append(o)
                        sops.append(o)
                    else:
                        j = G.e2i[o]
                        js = G.V_symbols[j]
                        iops.append(j)
                        sops.append(js)

                # Generate code for this node
                for j, s in enumerate(vs):
                    if not generated[s]:
                        generated[s] = 1
                        vname = "s[%d]" % s
                        vcode = gen_code(v, sops)
                        code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

    print '\n'.join(code)

    if 1:
        return compile_expression_lines2(expr)

    lines = []
    finals = []

    return lines, finals


def compile_expression(expr, prefix):
    return "// TODO: Compile expression %s" % str(expr)


_ticdata = []
def tic(msg):
    print "Starting:", msg
    _ticdata.append((time(), msg))
def ticend():
    _ticdata.append((time(), "END"))
def ticprint():
    global _ticdata
    for i in range(len(_ticdata)-1):
        t1, msg = _ticdata[i]
        t2 = _ticdata[i+1][0]
        t = t2-t1
        print "%9.1e s   %s" % (t, msg)
    _ticdata = []


def compile_form(form, prefix):

    # First we replace compound tensor expressions with index representations
    tic('expand_compounds')
    form = expand_compounds(form)

    # Then we apply the AD algorithm, after which Grad is only applied to functions
    tic('expand_derivatives2')
    form = expand_derivatives2(form,
                               apply_expand_compounds_before=False,
                               apply_expand_compounds_after=False,
                               use_alternative_wrapper_algorithm=False)

    # Compute the signature (don't need this yet, could possibly compute
    # it from some processed representation instead to speed it up later)
    if 0:
        tic('signature')
        signature = form.signature()

    # Done with preprocessing, print timing
    ticend()
    ticprint()

    # We'll place all code in a list while building the program
    code = []

    # Generate code for each integral
    for iitg, itg in enumerate(form.integrals()):
        integral_code = compile_integral_code(itg)
        code.append(integral_code)

    tic('format_code_structure')
    formatted = format_code_structure(code)
    ticend()
    ticprint()

    return formatted


def compile_integral_code(integral):

    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    variables = {}
    expr_formatter = ExprFormatter(cpp_formatter, variables)

    # Fetch the expression
    integrand = integral.integrand()

    # Build the initial coarse computational graph of the expression
    tic('build_graph')
    G = build_graph(integrand)

    # Build more fine grained computational graph of scalar subexpressions
    tic('rebuild_scalar_e2i')
    ne2i, NV, W, terminals, nvs = rebuild_scalar_e2i(G, DEBUG=False)
    assert len(nvs) == 1 # Scalar integrand, only one target symbol
    # Target expression is NV[nvs[0]].

    if 1:
        print
        print "|V|", len(G.V)
        print "tot_sym", G.total_unique_symbols
        print "|NV|", len(NV)
        print "|W|", len(W)

        nvstr = str(NV[nvs[0]])
        if len(nvstr) < 240:
            for nvline in [nvstr[i*60:(i+1)*60] for i in range((len(nvstr)+59)//60)]:
                print "    %s  ..." % nvline
        else:
            print "nvstr quite long, not printing"

        print

    def gen_code(cl, sops):
        #vcode = expr_formatter.visit(v)
        #vcode = cpp_formatter(...)
        vcode = "%s(%s)" % (cl.__name__, ', '.join(map(str,sops)))
        return vcode

    integral_code = []
    varname = object_array(len(NV))

    terminalish = (Terminal,Grad,Restricted,Indexed)

    tic('generating code')
    print "Now generating code for %d nodes" % len(NV)
    for i, v in enumerate(NV):
        # Get symbol and name for v
        vsym = ne2i[v]
        vname = "s[%d]" % vsym
        varname[vsym] = vname

        if isinstance(v, terminalish):
            # Generate terminal expression code
            vcode = str(v) # FIXME
        elif 1:
            vcode = expr_formatter.visit(v)
        else:
            # Get operand symbols
            if 1:
                print
                for o in v.operands():
                    print o
                    print ne2i.get(o)
                print
            vopsyms = [ne2i[o] for o in v.operands()]

            # Get names
            vopnames = [varname[sym] for sym in vopsyms]

            # Generate expression code
            vcode = gen_code(v._uflclass, vopnames) # FIXME

        # Generate assignment code
        assignment = "%s = %s;" % (vname, vcode)
        integral_code.append(assignment)
        variables[v] = vname

    # Print timing
    ticend()
    ticprint()

    return integral_code

typecounts = []
def old_compile_form(form, prefix):

    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    # First we preprocess the form
    tic('expand_compounds')
    form = expand_compounds(form)
    tic('expand_derivatives1')
    form1 = expand_derivatives1(form,
                              apply_expand_compounds_before=False,
                              apply_expand_compounds_after=False,
                              use_alternative_wrapper_algorithm=False)
    tic('expand_derivatives2')
    form2 = expand_derivatives2(form,
                              apply_expand_compounds_before=False,
                              apply_expand_compounds_after=False,
                              use_alternative_wrapper_algorithm=False)

    form = form2

    # Compute the signature
    if 0:
        tic('signature')
        signature = form.signature()

    # We'll place all code in a list while building the program
    code = []

    #typecounts = []

    # Then we iterate over the integrals
    for iitg, itg in enumerate(form.integrals()):
        # Fetch the expression
        integrand = itg.integrand()

        # And build the computational graph of the expression
        tic('integral %d build_graph' % iitg)
        G = build_graph(integrand)

        tic('integral %d rebuild_scalar_e2i' % iitg)
        ne2i, NV, W, terminals, nvs = rebuild_scalar_e2i(G, DEBUG=False)
        assert len(nvs) == 1 # Scalar integrand, only one target symbol
        if 1:
            print
            print "|V|", len(G.V)
            print "tot_sym", G.total_unique_symbols
            print "|NV|", len(NV)
            print "|W|", len(W)
            print

        def gen_code(cl, sops):
            #vcode = expr_formatter.visit(v)
            #vcode = cpp_formatter(...)
            vcode = "%s(%s)" % (cl.__name__, ', '.join(map(str,sops)))
            return vcode

        if 1:
            e2i, V, V_symbols, nv, total_unique_symbols = (\
                G.e2i, G.V, G.V_symbols, G.nv, G.total_unique_symbols)
        else:
            # FIXME: W is not V_symbols, figure out how to stitch these together
            e2i, V, V_symbols, nv, total_unique_symbols = (\
                ne2i, NV, W, len(NV), len(W))

            #V_symbols = list_to_crs(W)

        if 1:
            for i, v in enumerate(NV):
                ops = [e2i[o] for o in v.operands()]

            print
            print NV[nvs[0]]
            print

        integral_code = []
        print "Now generating code for %d nodes" % nv
        tenpercent = (nv // 10) 
        generated = int_array(total_unique_symbols)
        typecount = {}
        for i, v in enumerate(V):
            if tenpercent and i % tenpercent == 0:
                print "Progress: %d0 %%" % (i // tenpercent)
                tic('integral %d progress %d0 %%' % (iitg, (i // tenpercent)))

            # Get properties of this node from graph
            vs = V_symbols[i]
            vn = len(vs)

            typecount[v._uflclass] = typecount.get(v._uflclass,0) + 1

            if any(not generated[s] for s in vs):
                if isinstance(v, (Terminal,Grad,SpatialDerivative,Restricted)):
                    # Generate code for this node
                    for j, s in enumerate(vs):
                        if not generated[s]:
                            generated[s] = 1
                            vname = "s[%d]" % s
                            vcode = gen_code(v._uflclass, ())
                            if 1: integral_code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

                elif 1:
                    # Find properties of children from graph
                    iops = []
                    sops = []
                    for o in v.operands():
                        if isinstance(o, UtilityType):
                            iops.append(o)
                            sops.append(o)
                        else:
                            j = e2i[o]
                            js = V_symbols[j]
                            iops.append(j)
                            sops.append(js)

                    # Generate code for this node
                    for j, s in enumerate(vs):
                        if not generated[s]:
                            generated[s] = 1
                            vname = "s[%d]" % s
                            vcode = gen_code(v._uflclass, sops)
                            integral_code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

        typecounts.append(typecount)

        # Join code to what we have
        code.append(integral_code)

    tic('formatting')
    formatted = format_code_structure(code)
    ticend()
    ticprint()

    if 1:
        print "type counts:"
        keys = set()
        for tc in typecounts:
            keys.update(tc.keys())
        keys = sorted(keys, key=lambda k: sum(tc.get(k,0) for tc in typecounts))
        for k in keys:
            line = ""
            for tc in typecounts:
                v = tc.get(k,0)
                line += ("%10d \t" %  v)
            print line, k.__name__

    return formatted
