
import ufl
from ufl.classes import Terminal, UtilityType, Grad,SpatialDerivative,Restricted,FormArgument
from ufl.algorithms import expand_derivatives, expand_compounds
from ufl.algorithms.ad import expand_derivatives1, expand_derivatives2
from uflacs.utils.assertions import error
from uflacs.codeutils.format_code_structure import format_code_structure
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules, CppDefaultFormatter
from uflacs.algorithms.graph import build_graph, int_array
from time import time

def compile_element(element, prefix): # Makes no sense in here really
    return "// TODO: Compile element %s" % str(element)


def compile_expression_lines2(uexpr):
    lines = []
    finals = []

    if isinstance(uexpr, ufl.classes.Terminal):

        if isinstance(uexpr, ufl.classes.IntValue):
            code =  "%d" % (uexpr.value(),)
            finals.append(code)

        elif isinstance(uexpr, ufl.classes.FloatValue):
            code =  "%g" % (uexpr.value(),)
            finals.append(code)

        elif isinstance(uexpr, ufl.classes.Zero):
            code =  "0"
            finals.append(code)

        elif isinstance(uexpr, ufl.classes.Circumradius):
            code =  "h"
            finals.append(code)

        else:
            error("%s not covered yet" % type(uexpr))

    else:
        if isinstance(uexpr, ufl.classes.Sum):
            code = "+"
            finals.append(code)

        else:
            error("%s not covered yet" % type(uexpr))

    return lines, finals


def compile_expression_lines(expr):
    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    # First we replace inner, dot, etc. with lower level representations
    expr = expand_compounds(expr)

    # Then we evaluate the derivatives up to unknown terminal derivatives
    expr = expand_derivatives2(expr,
                                apply_expand_compounds_before=False,
                                apply_expand_compounds_after=False,
                                use_alternative_wrapper_algorithm=True)

    # And build the computational graph of the expression
    G = build_graph(expr)

    # We'll place all code in a list while building the program
    code = []

    def gen_code(cl, sops):
        #vcode = expr_formatter.visit(v)
        #vcode = cpp_formatter(...)
        #vcode = "%s(%s)" % (cl.__name__, ', '.join(map(str,sops)))
        vcode = cpp_formatter(cl, *["s%d" % s for s in sops])
        return vcode

    print "Now generating code for %d nodes" % G.nv

    generated = int_array(G.total_unique_symbols)

    for i, v in enumerate(G.V):

        # Get properties of this node from graph
        vs = G.V_symbols2[i]
        vn = len(vs)

        if any(not generated[s] for s in vs):
            if isinstance(v, (Terminal,Grad,SpatialDerivative,Restricted)):
                # Generate code for this node
                for j, s in enumerate(vs):
                    if not generated[s]:
                        generated[s] = 1
                        vname = "s[%d]" % s
                        vcode = gen_code(v, ())
                        if 1: code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

            elif 1:
                # Find properties of children from graph
                iops = []
                sops = []
                for o in v.operands():
                    if isinstance(o, UtilityType):
                        iops.append(o)
                        sops.append(o)
                    else:
                        j = G.e2i[o]
                        js = G.V_symbols2[j]
                        iops.append(j)
                        sops.append(js)

                # Generate code for this node
                for j, s in enumerate(vs):
                    if not generated[s]:
                        generated[s] = 1
                        vname = "s[%d]" % s
                        vcode = gen_code(v, sops)
                        code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

    print '\n'.join(code)

    if 1:
        return compile_expression_lines2(expr)

    lines = []
    finals = []

    return lines, finals


def compile_expression(expr, prefix):
    return "// TODO: Compile expression %s" % str(expr)


_ticdata = []
def tic(msg):
    print "Starting:", msg
    _ticdata.append((time(), msg))
def ticend():
    _ticdata.append((time(), "END"))
def ticprint():
    global _ticdata
    for i in range(len(_ticdata)-1):
        t1, msg = _ticdata[i]
        t2 = _ticdata[i+1][0]
        t = t2-t1
        print "%9.1e s   %s" % (t, msg)
    _ticdata = []

typecounts = []
def compile_form(form, prefix):

    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    # First we preprocess the form
    tic('expand_compounds')
    form = expand_compounds(form)
    tic('expand_derivatives1')
    form1 = expand_derivatives1(form,
                              apply_expand_compounds_before=False,
                              apply_expand_compounds_after=False,
                              use_alternative_wrapper_algorithm=False)
    tic('expand_derivatives2')
    form2 = expand_derivatives2(form,
                              apply_expand_compounds_before=False,
                              apply_expand_compounds_after=False,
                              use_alternative_wrapper_algorithm=False)

    form = form1

    # Compute the signature
    if 0:
        tic('signature')
        signature = form.signature()

    # We'll place all code in a list while building the program
    code = []

    #typecounts = []

    # Then we iterate over the integrals
    for iitg, itg in enumerate(form.integrals()):
        # Fetch the expression
        integrand = itg.integrand()

        # And build the computational graph of the expression
        tic('integral %d build_graph' % iitg)
        G = build_graph(integrand)

        def gen_code(cl, sops):
            #vcode = expr_formatter.visit(v)
            #vcode = cpp_formatter(...)
            vcode = "%s(%s)" % (cl.__name__, ', '.join(map(str,sops)))
            return vcode

        integral_code = []
        print "Now generating code for %d nodes" % G.nv
        tenpercent = (G.nv // 10) 
        generated = int_array(G.total_unique_symbols)
        typecount = {}
        for i, v in enumerate(G.V):
            if tenpercent and i % tenpercent == 0:
                print "Progress: %d0 %%" % (i // tenpercent)
                tic('integral %d progress %d0 %%' % (iitg, (i // tenpercent)))

            # Get properties of this node from graph
            vs = G.V_symbols2[i]
            vn = len(vs)

            typecount[v._uflclass] = typecount.get(v._uflclass,0) + 1

            if any(not generated[s] for s in vs):
                if isinstance(v, (Terminal,Grad,SpatialDerivative,Restricted)):
                    # Generate code for this node
                    for j, s in enumerate(vs):
                        if not generated[s]:
                            generated[s] = 1
                            vname = "s[%d]" % s
                            vcode = gen_code(v._uflclass, ())
                            if 1: integral_code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

                elif 1:
                    # Find properties of children from graph
                    iops = []
                    sops = []
                    for o in v.operands():
                        if isinstance(o, UtilityType):
                            iops.append(o)
                            sops.append(o)
                        else:
                            j = G.e2i[o]
                            js = G.V_symbols2[j]
                            iops.append(j)
                            sops.append(js)
    
                    # Generate code for this node
                    for j, s in enumerate(vs):
                        if not generated[s]:
                            generated[s] = 1
                            vname = "s[%d]" % s
                            vcode = gen_code(v._uflclass, sops)
                            integral_code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

        typecounts.append(typecount)

        # Join code to what we have
        code.append(integral_code)
    tic('formatting')
    formatted = format_code_structure(code)
    ticend()
    ticprint()

    if 1:
        print "type counts:"
        keys = set()
        for tc in typecounts:
            keys.update(tc.keys())
        keys = sorted(keys, key=lambda k: sum(tc.get(k,0) for tc in typecounts))
        for k in keys:
            line = ""
            for tc in typecounts:
                v = tc.get(k,0)
                line += ("%10d \t" %  v)
            print line, k.__name__

    return formatted
