
from ufl.classes import Terminal, UtilityType
from ufl.algorithms import expand_derivatives
from uflacs.codeutils.format_code import format_code
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules, CppDefaultFormatter
from uflacs.algorithms.graph import build_graph

def compile_element(element, prefix):
    return "// TODO: Compile element %s" % str(element)

def compile_expression(expr, prefix):
    return "// TODO: Compile expression %s" % str(expr)

def compile_form(form, prefix):

    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    # First we preprocess the form
    form = expand_derivatives(form)

    # We'll place all code in a list while building the program
    code = []

    # Then we iterate over the integrals
    for itg in form.integrals():
        # Fetch the expression
        integrand = itg.integrand()

        # And build the computational graph of the expression
        G = build_graph(integrand)

        def gen_code(cl, sops):
            #vcode = expr_formatter.visit(v)
            #vcode = cpp_formatter(...)
            vcode = "%s(%s)" % (cl.__name__, ', '.join(map(str,sops)))
            return vcode

        integral_code = []
        print "Now generating code for %d nodes" % G.nv
        tenpercent = (G.nv // 10)
        for i, v in enumerate(G.V):
            if i % tenpercent == 0:
                print "Progress: %d0 %%" % (i // tenpercent)

            # Get properties of this node from graph
            vo = G.V_offsets[i]
            vn = G.V_sizes[i]
            vs = G.V_symbols[vo:vo+vn]

            # Find properties of children from graph
            iops = []
            sops = []
            for o in v.operands():
                if isinstance(o, UtilityType):
                    iops.append(o)
                    sops.append(o)
                else:
                    j = G.e2i[o]
                    jo = G.V_offsets[j]
                    jn = G.V_sizes[j]
                    js = G.V_symbols[jo:jo+jn]
                    iops.append(j)
                    sops.append(js)

            # Generate code for this node
            for j, s in enumerate(vs):
                vname = "s[%d]" % s
                vcode = gen_code(v._uflclass, sops)
            integral_code.append("%s = %s;" % (vname, vcode))

        # Join code to what we have
        code.append(integral_code)

    return format_code(code)
