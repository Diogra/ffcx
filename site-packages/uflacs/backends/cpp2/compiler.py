
import ufl
from ufl.classes import (Terminal, UtilityType, FormArgument,
                         Grad, SpatialDerivative, Restricted, Indexed)
from ufl.algorithms import expand_derivatives, expand_compounds
from ufl.algorithms.ad import expand_derivatives1, expand_derivatives2

from uflacs.utils.assertions import error
from uflacs.codeutils.format_code_structure import format_code_structure
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules
from uflacs.codeutils.target_formatter import CppDefaultFormatter
from uflacs.algorithms.datastructures import int_array, object_array
from uflacs.algorithms.graph import build_graph
from uflacs.algorithms.graph_vertices import build_scalar_graph_vertices
from uflacs.algorithms.graph_rebuild import rebuild_scalar_e2i
from uflacs.algorithms.graph_ssa import (compute_dependencies,
                                         mark_active,
                                         mark_partitions,
                                         compute_dependency_count,
                                         invert_dependencies,
                                         default_cache_score_policy,
                                         compute_cache_scores,
                                         allocate_registers)

from time import time

_ticdata = []
def tic(msg):
    print "Starting:", msg
    _ticdata.append((time(), msg))
def ticend():
    _ticdata.append((time(), "END"))
def ticprint():
    global _ticdata
    for i in range(len(_ticdata)-1):
        t1, msg = _ticdata[i]
        t2 = _ticdata[i+1][0]
        t = t2-t1
        print "%9.1e s   %s" % (t, msg)
    _ticdata = []


def compile_element(element, prefix): # Makes no sense in here really
    return "// TODO: Compile element %s" % str(element)

def generate_code_from_ssa(SV, active, partitions, allocations,
                           gen_terminal_code, expr_formatter):
    terminalish = (Terminal,Grad,Restricted,Indexed)
    min_p = min(partitions)
    max_p = max(partitions)
    codes = []
    # Handle partitions one at a time, in order
    for p in range(min_p, max_p+1):
        code = []
        for i, v in enumerate(SV):
            if not active[i] or partitions[i] != p:
                continue

            # Get register number if any
            vreg = allocations[i]

            # Generate assignment code if this expression has an allocated register
            if vreg >= 0:

                # Format expression
                # FIXME: This can all be handled through the expr_formatter, can't it?
                if isinstance(v, terminalish):
                    vcode = gen_terminal_code(v)
                else:
                    vcode = expr_formatter.visit(v)

                # Emit an assignment of vcode to register vreg
                #emit_assignment(vreg, vcode)
                vname = "s[%d]" % (vreg,)
                assignment = "%s = %s;" % (vname, vcode)
                code.append(assignment)
                expr_formatter.variables[v] = vname

        codes.append(code)

    # FIXME: Temporary hack
    code = []
    for c in codes:
        code.extend(c)
    return code

def compile_expression_code(expression):
    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    variables = {}
    expr_formatter = ExprFormatter(cpp_formatter, variables)

    # Build the initial coarse computational graph of the expression
    tic('build_graph')
    G = build_graph(expression)

    # Build more fine grained computational graph of scalar subexpressions
    tic('rebuild_scalar_e2i')
    e2i, NV, W, terminals, nvs = rebuild_scalar_e2i(G, DEBUG=False)
    # Target expression is NV[nvs[:]].

    # Assuming a scalar expression, i.e. only one target symbol
    # TODO: This is good for integrands, but handle nonscalars for expressions!
    assert expression.shape() == ()
    assert expression.free_indices() == ()
    assert len(nvs) == 1

    # Straigthen out V to represent single operations
    tic('build_scalar_graph_vertices')
    se2i, SV, svs = build_scalar_graph_vertices([NV[s] for s in nvs])

    # Compute sparse dependency matrix
    tic('compute_dependencies')
    dependencies = compute_dependencies(se2i, SV)

    # Mark subexpressisons that are actually needed for final result
    tic('mark_active')
    max_symbol = len(SV)
    initially_active = svs
    active, num_active = mark_active(max_symbol, dependencies, initially_active)

    # Mark subexpressions with which loop they belong inside
    tic('mark_partitions')
    partitions = mark_partitions(SV, active, dependencies)

    # Count the number of dependencies every subexpr has
    tic('compute_dependency_count')
    depcount = compute_dependency_count(dependencies)

    # Build the 'inverse' of the sparse dependency matrix
    tic('invert_dependencies')
    inverse_dependencies = invert_dependencies(dependencies, depcount)

    # Use heuristics to mark the usefulness of storing every subexpr in a variable
    tic('compute_cache_scores')
    scores = compute_cache_scores(SV,
                                  active,
                                  dependencies,
                                  inverse_dependencies,
                                  partitions,
                                  cache_score_policy=default_cache_score_policy)

    # Allocate variables to store subexpressions in
    tic('allocate_registers')
    max_registers = 2*1024 # 16 KB
    score_threshold = 2
    allocations = allocate_registers(active, partitions, scores,
                                     max_registers, score_threshold)
    # FIXME: Make sure we allocate registers for final results, makes some things easier

    # Generate code listing
    tic('generating code')
    def gen_terminal_code(v):
        return str(v) # FIXME: Hook in backend-specific code generation instead of this!
    code = generate_code_from_ssa(SV, active, partitions, allocations,
                                  gen_terminal_code, expr_formatter)
    # FIXME: Get names of variables which now contain the actual results.

    # Print timing
    ticend()
    ticprint()

    return code


def compile_expression(expr, prefix):
    expr = expand_compounds(expr)
    expr = expand_derivatives2(expr,
                               apply_expand_compounds_before=False,
                               apply_expand_compounds_after=False,
                               use_alternative_wrapper_algorithm=False)
    code = compile_expression_code(expr)
    formatted = format_code_structure(code)
    return formatted


def compile_form(form, prefix):

    # First we replace compound tensor expressions with index representations
    tic('expand_compounds')
    form = expand_compounds(form)

    # Then we apply the AD algorithm, after which Grad is only applied to functions
    tic('expand_derivatives2')
    form = expand_derivatives2(form,
                               apply_expand_compounds_before=False,
                               apply_expand_compounds_after=False,
                               use_alternative_wrapper_algorithm=False)

    # Compute the signature (don't need this yet, could possibly compute
    # it from some processed representation instead to speed it up later)
    if 0:
        tic('signature')
        signature = form.signature()

    # Done with preprocessing, print timing
    ticend()
    ticprint()

    # We'll place all code in a list while building the program
    code = []

    # Generate code for each integral
    for itg in form.integrals():
        # TODO: Place this code into an integration context
        integral_code = compile_expression_code(itg.integrand())
        code.append(integral_code)

    tic('format_code_structure')
    formatted = format_code_structure(code)
    ticend()
    ticprint()

    return formatted

