
import ufl
from ufl.classes import (Terminal, UtilityType, FormArgument, Argument,
                         Grad, SpatialDerivative, Restricted, Indexed)
from ufl.algorithms import expand_derivatives, expand_compounds
from ufl.algorithms.ad import expand_derivatives1, expand_derivatives2

from uflacs.utils.assertions import error
from uflacs.codeutils.format_code_structure import format_code_structure, Block
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules
from uflacs.codeutils.target_formatter import CppDefaultFormatter
from uflacs.codeutils.element_tensor_formatter import (build_loops, format_assignments,
                                                       format_additions)

from uflacs.algorithms.datastructures import int_array, object_array
from uflacs.algorithms.graph import build_graph
from uflacs.algorithms.graph_vertices import build_scalar_graph_vertices
from uflacs.algorithms.graph_rebuild import rebuild_scalar_e2i
from uflacs.algorithms.graph_ssa import (compute_dependencies,
                                         mark_active,
                                         mark_partitions,
                                         compute_dependency_count,
                                         invert_dependencies,
                                         default_cache_score_policy,
                                         compute_cache_scores,
                                         allocate_registers)

from time import time

_ticdata = []
def tic(msg):
    print "Starting:", msg
    _ticdata.append((time(), msg))
def ticend():
    _ticdata.append((time(), "END"))
def ticprint():
    global _ticdata
    for i in range(len(_ticdata)-1):
        t1, msg = _ticdata[i]
        t2 = _ticdata[i+1][0]
        t = t2-t1
        print "%9.1e s   %s" % (t, msg)
    _ticdata = []


def compile_element(element, prefix): # Makes no sense in here really
    return "// TODO: Compile element %s" % str(element)

def generate_code_from_ssa(SV, active, partitions, allocations,
                           target_registers, expr_formatter):
    terminalish = (Terminal, Grad, Restricted, Indexed)
    min_p = min(partitions)
    max_p = max(partitions)

    # TODO: Move these to [target_]expr_formatter:
    def format_assignment_statement(lhs, rhs):
        return "%s = %s;" % (lhs, rhs)
    def format_register_variable(p, r):
        return "s[%d]" % (r,) # TODO: Maybe make it "s%d[%d]" % (p, r)

    # Handle partitions one at a time, in order
    partition_codes = []
    for p in range(min_p, max_p+1):
        code = []
        for i, v in enumerate(SV):
            vreg = allocations[i]
            # Generate assignment code if this expression
            # has an allocated register
            if active[i] and partitions[i] == p and vreg >= 0:
                vname = format_register_variable(p, vreg)
                vcode = expr_formatter.visit(v)
                assignment = format_assignment_statement(vname, vcode)
                code.append(assignment)
                expr_formatter.variables[v] = vname

        partition_codes.append((p,code))

    p = max_p # TODO: Add partitions to target_registers, or is this fine?
    final_variable_names = [format_register_variable(p, r) for r in target_registers]
    return partition_codes, final_variable_names

def compile_expression_partitions(expression, target_formatter):
    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)
    expr_formatter = ExprFormatter(cpp_formatter, {})

    # Build the initial coarse computational graph of the expression
    tic('build_graph')
    G = build_graph(expression)

    # Build more fine grained computational graph of scalar subexpressions
    tic('rebuild_scalar_e2i')
    e2i, NV, W, terminals, nvs = rebuild_scalar_e2i(G, DEBUG=False)
    # Target expression is NV[nvs[:]].

    # Communicate set of terminalish objects to target formatter
    target_formatter.update_terminals(terminals)

    # Assuming a scalar expression, i.e. only one target symbol
    # TODO: This is good for integrands, but handle nonscalars for expressions!
    if 0: # TODO: Not sure if we need this anymore?
        assert expression.shape() == ()
        assert expression.free_indices() == ()
        assert len(nvs) == 1

    # Straigthen out V to represent single operations
    tic('build_scalar_graph_vertices')
    se2i, SV, svs = build_scalar_graph_vertices([NV[s] for s in nvs])

    # Compute sparse dependency matrix
    tic('compute_dependencies')
    dependencies = compute_dependencies(se2i, SV)

    # Mark subexpressisons that are actually needed for final result
    tic('mark_active')
    max_symbol = len(SV)
    target_variables = svs
    active, num_active = mark_active(max_symbol, dependencies, target_variables)

    # Mark subexpressions with which loop they belong inside
    tic('mark_partitions')
    argument_mapping = target_formatter.form_argument_mapping.items()
    argument_mapping = dict((k,v) for (k,v) in argument_mapping
                            if isinstance(k, Argument))
    partitions = mark_partitions(SV, active, dependencies, argument_mapping)

    # Count the number of dependencies every subexpr has
    tic('compute_dependency_count')
    depcount = compute_dependency_count(dependencies)

    # Build the 'inverse' of the sparse dependency matrix
    tic('invert_dependencies')
    inverse_dependencies = invert_dependencies(dependencies, depcount)

    # Use heuristics to mark the usefulness of storing every subexpr in a variable
    tic('compute_cache_scores')
    scores = compute_cache_scores(SV,
                                  active,
                                  dependencies,
                                  inverse_dependencies,
                                  partitions,
                                  cache_score_policy=default_cache_score_policy)

    # Allocate variables to store subexpressions in
    tic('allocate_registers')
    max_registers = 2*1024 # 2K = 16 KB # TODO: Make this a parameter
    score_threshold = 3 # TODO: Make this a parameter
    allocations = allocate_registers(active, partitions, target_variables,
                                     scores, max_registers, score_threshold)
    target_registers = [allocations[r] for r in target_variables]
    num_registers = sum(1 if x >= 0 else 0 for x in allocations)
    # TODO: Could allocate registers for each partition

    # Generate code listing
    tic('generating code')
    partition_codes, final_variable_names = generate_code_from_ssa(SV,
        active, partitions, allocations, target_registers, expr_formatter)

    # Print timing
    ticend()
    ticprint()

    return partition_codes, final_variable_names, num_registers

def compile_expression_body(expr, target_formatter, integrate=False):

    # Shorten name, repeated a lot
    tfmt = target_formatter

    # Compile expression into partitioned code listings
    partition_codes, final_variable_names, num_registers = \
                     compile_expression_partitions(expr, tfmt)

    # Join partitions with target specific loops and declarations
    # NB! Both 'required' and 'terminals' are filled during partition compilation
    req = tfmt.required
    term = tfmt.terminals
    partition_codes = dict(partition_codes)

    # Build loop structure (intended for tabulate_tensor)
    loops = []
    definitions = []
    partitions = []

    def update_loops(loop, defs, p):
        loops.append(loop)
        definitions.append(defs)
        partitions.append(partition_codes.get(p,""))
        if p in partition_codes:
            del partition_codes[p]

    # TODO: This partition numbering is maybe too "magic"
    # --- Partition 0: independent of x and arguments.
    p = 0
    if 1:
        piecewise_defs = []
        if num_registers:
            piecewise_defs += tfmt.define_registers(num_registers)
        piecewise_defs += tfmt.define_piecewise_geometry()
        piecewise_defs += tfmt.define_piecewise_coefficients()
        update_loops(None, piecewise_defs, p)

    # --- Partition 1: x dependency
    p = 1
    if 1:
        x_dependent_defs = []
        if integrate:
            quadrature_for_loop = tfmt.define_quadrature_for_loop()
            x_dependent_defs += tfmt.define_quadrature_loop_vars()
        else:
            quadrature_for_loop = None
            x_dependent_defs += []
        x_dependent_defs += tfmt.define_x_dependent_geometry()

        update_loops(quadrature_for_loop, x_dependent_defs, p)

    # --- Partition 2: x and coefficient dependency
    p = 2
    if 1:
        w_dependent_defs = []
        w_dependent_defs += tfmt.define_x_dependent_coefficients()
        update_loops(None, w_dependent_defs, p)

    # --- Partitions 3...3+rank-1: argument function dependency
    rank = len(tfmt.arguments)
    for p in range(3,3+rank):
        ac = 2+rank-p # Magic formula for mapping partition to argument count
        update_loops(tfmt.define_argument_for_loop(ac),
                     tfmt.define_argument_loop_vars(ac),
                     p)

    # --- Final partition: final assignments
    p = 3 + rank
    if 1:
        assign_to_variables = tfmt.output_variable_names(len(final_variable_names))
        if integrate:
            final_statements = list(format_additions(zip(assign_to_variables,
                                                         final_variable_names)))
        else:
            final_statements = list(format_assignments(zip(assign_to_variables,
                                                           final_variable_names)))
        update_loops(None, final_statements, p)

    # --- Should be nothing left now
    if partition_codes:
        print '------------------- partition_codes:'
        print partition_codes
        print '-------------------'
    assert not partition_codes

    # Stitch it together
    code = build_loops(loops, definitions, partitions)

    return code

def compile_expression(expr, prefix):
    expr = expand_compounds(expr)
    expr = expand_derivatives2(expr,
                               apply_expand_compounds_before=False,
                               apply_expand_compounds_after=False,
                               use_alternative_wrapper_algorithm=False)

    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    code = compile_expression_body(expr, target_formatter, integrate=False)

    formatted = format_code_structure(Block(code))
    return formatted

def compile_form(form, prefix):

    # Preprocess form
    tic('preprocess')
    assert ufl.algorithms.ad.expand_derivatives == ufl.algorithms.ad.expand_derivatives2
    formdata = form.compute_form_data(replace_functions=False,
                                      skip_signature=True)

    # We'll place all code in a list while building the program
    code = []

    # Generate code for each integral
    k = 0
    for itg in formdata.preprocessed_form.integrals():
        tic('compile_expression_body for integral %d' % k); k += 1

        # Reconstructing default formatter for each integral to reset state
        target_formatter = CppDefaultFormatter()
        target_formatter.form_argument_mapping = formdata.function_replace_map

        # Use generic compiler routine to compile expression body
        integral_code = compile_expression_body(itg.integrand(),
                                                target_formatter,
                                                integrate=True)
        code.append(['',Block(integral_code),''])

    tic('format_code_structure')
    formatted = format_code_structure(code)
    ticend()
    ticprint()

    return formatted
