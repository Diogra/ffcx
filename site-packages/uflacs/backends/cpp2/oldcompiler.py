
import ufl
from ufl.classes import (Terminal, UtilityType, FormArgument,
                         Grad, Restricted, Indexed)
from ufl.algorithms import expand_derivatives, expand_compounds

from uflacs.utils.assertions import error
from uflacs.codeutils.format_code_structure import format_code_structure
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules
from uflacs.codeutils.target_formatter import CppDefaultFormatter
from uflacs.algorithms.datastructures import int_array, object_array
from uflacs.algorithms.graph import build_graph
from uflacs.algorithms.graph_rebuild import rebuild_scalar_e2i
from uflacs.algorithms.graph_ssa import (compute_dependencies,
                                         mark_active,
                                         mark_partitions,
                                         compute_dependency_count,
                                         invert_dependencies,
                                         default_cache_score_policy,
                                         compute_cache_scores,
                                         allocate_registers)

from time import time

def compile_element(element, prefix): # Makes no sense in here really
    return "// TODO: Compile element %s" % str(element)


def compile_expression_lines2(uexpr):
    lines = []
    finals = []

    if isinstance(uexpr, ufl.classes.Terminal):

        if isinstance(uexpr, ufl.classes.IntValue):
            code =  "%d" % (uexpr.value(),)
            finals.append(code)

        elif isinstance(uexpr, ufl.classes.FloatValue):
            code =  "%g" % (uexpr.value(),)
            finals.append(code)

        elif isinstance(uexpr, ufl.classes.Zero):
            code =  "0"
            finals.append(code)

        elif isinstance(uexpr, ufl.classes.Circumradius):
            code =  "h"
            finals.append(code)

        else:
            error("%s not covered yet" % type(uexpr))

    else:
        if isinstance(uexpr, ufl.classes.Sum):
            code = "+"
            finals.append(code)

        else:
            error("%s not covered yet" % type(uexpr))

    return lines, finals


def compile_expression_lines(expr):
    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    # First we replace inner, dot, etc. with lower level representations
    expr = expand_compounds(expr)

    # Then we evaluate the derivatives up to unknown terminal derivatives
    expr = expand_derivatives(expr,
                              apply_expand_compounds_before=False,
                              apply_expand_compounds_after=False,
                              use_alternative_wrapper_algorithm=True)

    # And build the computational graph of the expression
    G = build_graph(expr)

    # We'll place all code in a list while building the program
    code = []

    def gen_code(cl, sops):
        #vcode = expr_formatter.visit(v)
        #vcode = cpp_formatter(...)
        #vcode = "%s(%s)" % (cl.__name__, ', '.join(map(str,sops)))
        vcode = cpp_formatter(cl, *["s%d" % s for s in sops])
        return vcode

    print "Now generating code for %d nodes" % G.nv

    generated = int_array(G.total_unique_symbols)

    for i, v in enumerate(G.V):

        # Get properties of this node from graph
        vs = G.V_symbols[i]
        vn = len(vs)

        if any(not generated[s] for s in vs):
            if isinstance(v, (Terminal,Grad,Restricted)):
                # Generate code for this node
                for j, s in enumerate(vs):
                    if not generated[s]:
                        generated[s] = 1
                        vname = "s[%d]" % s
                        vcode = gen_code(v, ())
                        if 1: code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

            elif 1:
                # Find properties of children from graph
                iops = []
                sops = []
                for o in v.operands():
                    if isinstance(o, UtilityType):
                        iops.append(o)
                        sops.append(o)
                    else:
                        j = G.e2i[o]
                        js = G.V_symbols[j]
                        iops.append(j)
                        sops.append(js)

                # Generate code for this node
                for j, s in enumerate(vs):
                    if not generated[s]:
                        generated[s] = 1
                        vname = "s[%d]" % s
                        vcode = gen_code(v, sops)
                        code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

    print '\n'.join(code)

    if 1:
        return compile_expression_lines2(expr)

    lines = []
    finals = []

    return lines, finals


def compile_expression(expr, prefix):
    return "// TODO: Compile expression %s" % str(expr)


_ticdata = []
def tic(msg):
    print "Starting:", msg
    _ticdata.append((time(), msg))
def ticend():
    _ticdata.append((time(), "END"))
def ticprint():
    global _ticdata
    for i in range(len(_ticdata)-1):
        t1, msg = _ticdata[i]
        t2 = _ticdata[i+1][0]
        t = t2-t1
        print "%9.1e s   %s" % (t, msg)
    _ticdata = []


def compile_form(form, prefix):

    # First we replace compound tensor expressions with index representations
    tic('expand_compounds')
    form = expand_compounds(form)

    # Then we apply the AD algorithm, after which Grad is only applied to functions
    tic('expand_derivatives')
    form = expand_derivatives(form,
                              apply_expand_compounds_before=False,
                              apply_expand_compounds_after=False,
                              use_alternative_wrapper_algorithm=False)

    # Compute the signature (don't need this yet, could possibly compute
    # it from some processed representation instead to speed it up later)
    if 0:
        tic('signature')
        signature = form.signature()

    # Done with preprocessing, print timing
    ticend()
    ticprint()

    # We'll place all code in a list while building the program
    code = []

    # Generate code for each integral
    for iitg, itg in enumerate(form.integrals()):
        integral_code = compile_integral_code(itg)
        code.append(integral_code)

    tic('format_code_structure')
    formatted = format_code_structure(code)
    ticend()
    ticprint()

    return formatted


def generate_code_from_ssa(NV, active, allocations, gen_terminal_code, expr_formatter):

    terminalish = (Terminal,Grad,Restricted,Indexed)
    code = []

    print "Now generating code for %d nodes" % len(NV)
    for i, v in enumerate(NV):
        if not active[i]:
            continue

        # Get register number and name for v
        vreg = allocations[i]

        if isinstance(v, terminalish):
            # Generate terminal expression code
            vcode = gen_terminal_code(v)
        else:
            # Format expression
            vcode = expr_formatter.visit(v)

        # Generate assignment code if this expression has an allocated register
        if vreg >= 0:
            vname = "s[%d]" % (vreg,)
            assignment = "%s = %s;" % (vname, vcode)
            code.append(assignment)
            expr_formatter.variables[v] = vname

    return code

def compile_integral_code(integral):
    return compile_expression_code(integral.integrand())

def compile_expression_code(expression):
    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    variables = {}
    expr_formatter = ExprFormatter(cpp_formatter, variables)

    # Build the initial coarse computational graph of the expression
    tic('build_graph')
    G = build_graph(expression)

    # Build more fine grained computational graph of scalar subexpressions
    tic('rebuild_scalar_e2i')
    ne2i, NV, W, terminals, nvs = rebuild_scalar_e2i(G, DEBUG=False)
    # Target expression is NV[nvs[:]].


    # Assuming a scalar expression, i.e. only one target symbol
    # TODO: This is good for integrands, but handle nonscalars for expressions!
    assert expression.shape() == ()
    assert expression.free_indices() == ()
    assert len(nvs) == 1


    # Compute sparse dependency matrix
    tic('compute_dependencies')
    dependencies = compute_dependencies(ne2i, NV)

    # Mark subexpressisons that are actually needed for final result
    tic('mark_active')
    max_symbol = len(NV)
    initially_active = nvs
    active, num_active = mark_active(max_symbol, dependencies, initially_active)

    # Mark subexpressions with which loop they belong inside
    tic('mark_partitions')
    partitions = mark_partitions(V, active, dependencies)

    # Count the number of dependencies every subexpr has
    tic('compute_dependency_count')
    depcount = compute_dependency_count(dependencies)

    # Build the 'inverse' of the sparse dependency matrix
    tic('invert_dependencies')
    inverse_dependencies = invert_dependencies(dependencies, depcount)

    # Use heuristics to mark the usefulness of storing every subexpr in a variable
    tic('compute_cache_scores')
    scores = compute_cache_scores(V,
                                  active,
                                  dependencies,
                                  inverse_dependencies,
                                  partitions,
                                  cache_score_policy=default_cache_score_policy)

    # Allocate variables to store subexpressions in
    tic('allocate_registers')
    max_registers = 128
    score_threshold = 2
    allocations = allocate_registers(active, partitions, scores,
                                     max_registers, score_threshold)


    # Some debug prints
    if 1:
        print
        print "|V|", len(G.V)
        print "tot_sym", G.total_unique_symbols
        print "|NV|", len(NV)
        print "|W|", len(W)

        nvstr = str(NV[nvs[0]])
        if len(nvstr) < 240:
            for nvline in [nvstr[i*60:(i+1)*60] for i in range((len(nvstr)+59)//60)]:
                print "    %s  ..." % nvline
        else:
            print "nvstr quite long, not printing"


    def gen_terminal_code(v):
        return str(v) # FIXME: Hook in backend-specific code generation instead of this!

    tic('generating code')
    code = generate_code_from_ssa(NV, active, allocations,
                                  gen_terminal_code, expr_formatter)

    # Print timing
    ticend()
    ticprint()

    return code

typecounts = []
def old_compile_form(form, prefix):

    # This formatter is a multifunction implementing target
    # specific formatting rules, here using the default rules.
    target_formatter = CppDefaultFormatter()

    # This formatter is a multifunction with single operator
    # formatting rules for generic C++ formatting
    cpp_formatter = CppFormatterRules(target_formatter)

    # First we preprocess the form
    tic('expand_compounds')
    form = expand_compounds(form)
    tic('expand_derivatives')
    form = expand_derivatives(form,
                              apply_expand_compounds_before=False,
                              apply_expand_compounds_after=False,
                              use_alternative_wrapper_algorithm=False)

    # Compute the signature
    if 0:
        tic('signature')
        signature = form.signature()

    # We'll place all code in a list while building the program
    code = []

    #typecounts = []

    # Then we iterate over the integrals
    for iitg, itg in enumerate(form.integrals()):
        # Fetch the expression
        integrand = itg.integrand()

        # And build the computational graph of the expression
        tic('integral %d build_graph' % iitg)
        G = build_graph(integrand)

        tic('integral %d rebuild_scalar_e2i' % iitg)
        ne2i, NV, W, terminals, nvs = rebuild_scalar_e2i(G, DEBUG=False)
        assert len(nvs) == 1 # Scalar integrand, only one target symbol
        if 1:
            print
            print "|V|", len(G.V)
            print "tot_sym", G.total_unique_symbols
            print "|NV|", len(NV)
            print "|W|", len(W)
            print

        def gen_code(cl, sops):
            #vcode = expr_formatter.visit(v)
            #vcode = cpp_formatter(...)
            vcode = "%s(%s)" % (cl.__name__, ', '.join(map(str,sops)))
            return vcode

        if 1:
            e2i, V, V_symbols, nv, total_unique_symbols = (\
                G.e2i, G.V, G.V_symbols, G.nv, G.total_unique_symbols)
        else:
            # FIXME: W is not V_symbols, figure out how to stitch these together
            e2i, V, V_symbols, nv, total_unique_symbols = (\
                ne2i, NV, W, len(NV), len(W))

            #V_symbols = list_to_crs(W)

        if 1:
            for i, v in enumerate(NV):
                ops = [e2i[o] for o in v.operands()]

            print
            print NV[nvs[0]]
            print

        integral_code = []
        print "Now generating code for %d nodes" % nv
        tenpercent = (nv // 10)
        generated = int_array(total_unique_symbols)
        typecount = {}
        for i, v in enumerate(V):
            if tenpercent and i % tenpercent == 0:
                print "Progress: %d0 %%" % (i // tenpercent)
                tic('integral %d progress %d0 %%' % (iitg, (i // tenpercent)))

            # Get properties of this node from graph
            vs = V_symbols[i]
            vn = len(vs)

            typecount[v._uflclass] = typecount.get(v._uflclass,0) + 1

            if any(not generated[s] for s in vs):
                if isinstance(v, (Terminal,Grad,Restricted)):
                    # Generate code for this node
                    for j, s in enumerate(vs):
                        if not generated[s]:
                            generated[s] = 1
                            vname = "s[%d]" % s
                            vcode = gen_code(v._uflclass, ())
                            if 1: integral_code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

                elif 1:
                    # Find properties of children from graph
                    iops = []
                    sops = []
                    for o in v.operands():
                        if isinstance(o, UtilityType):
                            iops.append(o)
                            sops.append(o)
                        else:
                            j = e2i[o]
                            js = V_symbols[j]
                            iops.append(j)
                            sops.append(js)

                    # Generate code for this node
                    for j, s in enumerate(vs):
                        if not generated[s]:
                            generated[s] = 1
                            vname = "s[%d]" % s
                            vcode = gen_code(v._uflclass, sops)
                            integral_code.append("%s = %s; // subsymbol %d/%d" % (vname, vcode, j, vn))

        typecounts.append(typecount)

        # Join code to what we have
        code.append(integral_code)

    tic('formatting')
    formatted = format_code_structure(code)
    ticend()
    ticprint()

    if 1:
        print "type counts:"
        keys = set()
        for tc in typecounts:
            keys.update(tc.keys())
        keys = sorted(keys, key=lambda k: sum(tc.get(k,0) for tc in typecounts))
        for k in keys:
            line = ""
            for tc in typecounts:
                v = tc.get(k,0)
                line += ("%10d \t" %  v)
            print line, k.__name__

    return formatted
