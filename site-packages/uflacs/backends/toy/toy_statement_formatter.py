
from ufl.classes import GeometricQuantity
from ufl.common import component_to_index
from ufl.permutation import build_component_numbering

from uflacs.utils.assertions import uflacs_assert
from uflacs.utils.log import warning, error

from uflacs.geometry.generate_geometry_snippets import (
    generate_jacobian_snippets,
    generate_jacobian_inverse_snippets,
    generate_x_from_xi_snippets,
    generate_xi_from_x_snippets)

from uflacs.codeutils.dependency_handler import DependencyHandler

class ToyCppStatementFormatter(object):
    """Class containing functions for generating definitions of registers,
    argument loops, and output variable names."""
    def __init__(self, dependency_handler, ir):
        self._dependency_handler = dependency_handler
        self._cell = dependency_handler.cell

        # FIXME: Make parameters:
        self._enable_accumulation = True
        self._enable_coord_loop = True # False for vertex point integral
        self._points_are_local = True # False for multiple point integral
        self._num_points_name = "num_points"
        self._points_name = "points"
        self._weights_name = "weights"

    def define_registers(self, num_registers, partition=None): # Partition is not yet used by compiler
        code = ["// Declaring variables for intermediate computations:"]

        name = "s" if partition is None else ("s%d" % partition)
        code += ["double %s[%d];" % (name, num_registers)]

        code.append("")
        return code

    def define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # TODO: Build this from terminal data and dependency dict
        needed = {
            "J": ("",),
            "detJ": ("",),
            "K": ("",),
            }

        # Generate code in fixed ordering
        for r in needed.get("J", ()):
            code.extend(generate_jacobian_snippets(self._cell, r))
        # TODO: Separate detJ computation
        for r in needed.get("K", ()):
            code.extend(generate_jacobian_inverse_snippets(self._cell, r))

        # TODO: Add all cell geometry stuff here, cell volume etc.
        #for r in needed.get("volume", ()):
        #    code.extend(generate_volume_snippets(self._cell, r))
        #for r in needed.get("circumradius", ()):
        #    code.extend(generate_circumradius_snippets(self._cell, r))

        code.append("")
        return code

    def _define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # A dependency graph like this might be a way to
        # automatically figure out which quantities to generate?
        dependencies = {
            "J": ("vertex_coordinates",),
            "detJ": ("J",),
            "K": ("J","detJ"),
            "x": ("xi", "J", "vertex_coordinates"),
            "xi": ("x", "K", "vertex_coordinates"),
            }
        geometric_quantity_name = str

        # Get the set of all geometry we need
        needed = set()
        for (t, ngrads, r) in self._dependency_handler.terminal_data:
            if isinstance(t, GeometricQuantity):
                uflacs_assert(ngrads == 0, "Derivatives of geometry not supported.")
                needed.add((geometric_quantity_name(t), r))

        # Make an intermediate stable but arbitrary sorting
        workstack = sorted(needed)

        # Make a set of already known quantities
        done = set()
        done.add("vertex_coordinates")

        # Make a set of quantities to postphone
        skip = set(item for item in workstack if item[0] in ("x","xi"))
        # ... but keep these in workstack to build dependencies properly!

        # Build list of geometry including dependencies
        ordered = []
        while workstack:
            # Get next item to do
            item = workstack.pop(0)
            # Drop it if already done
            if item in done:
                continue
            # Get dependencies of item that are not done
            deps = [(d, r) for d in dependencies[item[0]]
                    if (d, r) not in done]
            if deps:
                # If we have any dependencies, put them first on the stack
                workstack = deps + [item] + workstack
            else:
                # If we have no dependencies, do this item next,
                # unless it's postphoned
                if item not in skip:
                    ordered.append(item)

        # Finally we can generate some code
        for name, restriction in ordered:
            code.append("// TODO: Compute %s%s here" % (name, restriction))

        code.append("")
        return code

    def old_define_piecewise_geometry(self):
        code = ["// Compute piecewise constant geometry:"]

        # FIXME: Delegate this computation to cellcg!
        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        for expr, req in self._dependency_handler.required.iteritems():
            #key = (tuple(component), tuple(derivatives), restriction)
            if isinstance(expr, GeometricQuantity) and expr.is_cellwise_constant():
                for (c,d,r), code in req.iteritems():
                    impl = ["// TODO: Implement %s" % code]
                    code += impl

        code.append("")
        return code

    def define_coord_loop(self):
        if self._enable_coord_loop:
            code = ["",
                    "// Loop over coordinates",
                    "for (int iq=0; iq<%s; ++iq)" % self._num_points_name]
            return code
        else:
            return None

    def define_coord_vars(self):
        code = ["// Computing coordinates in necessary coordinate systems:"]

        # TODO: Parameter to pick behaviour here:
        # For dx, we need xi -> x
        # For ds, we need xi_facet -> xi -> x
        # For dS, we need xi_facet -> xi0,xi1 -> x0,x1
        # For dP(points), we need x -> xi
        # For dP(vertex), we need
        #   x = &vertex_coordinates[vertex*gd]; # TODO: Assumption on ordering of vertices?
        #   xi = &reference_vertex_coordinates[vertex*gd]

        if self._points_are_local:
            # cell integral
            code += ["const double *xi = &%s[%d*iq];" % (
                self._points_name, self._cell.topological_dimension())]
            # TODO: Restrictions
            code.extend(generate_x_from_xi_snippets(self._cell, ""))
        else:
            # multiple point evaluation
            code += ["const double *x = &%s[%d*iq];" % (
                self._points_name, self._cell.geometric_dimension())]
            # TODO: Restrictions
            code.extend(generate_xi_from_x_snippets(self._cell, ""))

        # Define weights
        if self._enable_accumulation:
            code += ["", "// Compute accumulation weight:"]
            code += ["const double qw = %s[iq];" % (self._weights_name,)]
            # TODO: Use correct name for 'det', depending on integral type?
            code += ["const double D = qw * std::abs(detJ);"] # TODO: Store absolute value?

        code += [""]
        return code

    def define_coord_dependent_geometry(self):
        code = ["// Compute x dependent geometry"]

        # FIXME: Delegate this computation to cellcg!
        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        for expr, req in self._dependency_handler.required.iteritems():
            if isinstance(expr, GeometricQuantity) and not expr.is_cellwise_constant():
                for (c,d,r), expr_code in req.iteritems():
                    impl = ["// TODO: Implement %s" % expr_code]
                    code += impl

        code += [""]
        return code

    def accumulation_scaling_factor(self):
        if self._enable_accumulation:
            return "D"
        else:
            return None

    def define_piecewise_coefficients(self):
        dh = self._dependency_handler
        code = ["// %s = w[%d][:]" % (dh.coefficient_names[c], i)
                for i, c in enumerate(dh.coefficients)
                if c.is_cellwise_constant()]
        if code:
            return ["// These constant coefficients are fetched directly from dof array w[][]:"] + code + [""]
        else:
            return []

    def define_coord_dependent_coefficients(self):
        return ["// Compute x dependent coefficients and evt. their derivatives"]

    def define_argument_for_loop(self, argument_count):
        iname = "i%d" % (argument_count,)
        isize = "n%d" % (argument_count,)
        return "for (int %s = 0; %s < %s; ++%s)" % (iname, iname, isize, iname)

    def define_argument_loop_vars(self, argument_count):
        return ["// Compute argument %d and evt. its derivatives" % (argument_count,)]

    def output_variable_names(self, num_variables):
        return ["A[%d]" % (i,) for i in xrange(num_variables)]
