import ufl
from ufl.classes import Argument
from ufl.algorithms import expand_derivatives, expand_compounds

from uflacs.utils.tictoc import TicToc
from uflacs.utils.assertions import error

from uflacs.codeutils.dependency_handler import DependencyHandler
from uflacs.codeutils.format_code_structure import Block, format_code_structure

from uflacs.algorithms.compiler import (compile_expression_partitions,
                                        generate_code_from_ssa,
                                        generate_expression_body)

from uflacs.backends.toy.toy_language_formatter import ToyCppLanguageFormatter
from uflacs.backends.toy.toy_statement_formatter import ToyCppStatementFormatter

# TODO: Is this generic enough to promote to a fully reusable compiler component?
def generate_expression_code(expr, cell, form_argument_mapping, object_names,
                             create_language_formatter, create_statement_formatter):
    "Core of toy expression compiler."

    # Extract just the arguments from the form argument mapping
    argument_mapping = dict((k,v) for (k,v) in form_argument_mapping.items()
                            if isinstance(k, Argument))

    # Compile expression into intermediate representation of partitions in ssa form
    ir = compile_expression_partitions(expr, argument_mapping)

    # Create an object to track dependencies across other components
    dependency_handler = DependencyHandler(ir["terminals"], form_argument_mapping, object_names)

    # This formatter is a multifunction implementing target specific formatting rules
    language_formatter = create_language_formatter(dependency_handler)

    # Generate code partitions from ir
    partition_codes, final_variable_names = generate_code_from_ssa(ir, language_formatter)

    # TODO: Also needs to know about (lack of) integration context:
    statement_formatter = create_statement_formatter(dependency_handler)

    # Generate full code from snippets
    code = generate_expression_body(statement_formatter,
                                    partition_codes,
                                    final_variable_names,
                                    ir["num_registers"])

    # Leave final formatting to the caller
    return code

def compile_expression(expr, prefix=""):
    "Toy compiler, translating an expression to a block of code that is not quite compilable."

    # Preprocess expression
    # TODO: Use ufl ExprData preprocessing, unify expr data with form data:
    expr = expand_compounds(expr)
    expr = expand_derivatives(expr,
                              apply_expand_compounds_before=False,
                              apply_expand_compounds_after=False,
                              use_alternative_wrapper_algorithm=False)
    cell = expr.cell()
    object_names = {}
    form_argument_mapping = {}

    # Build code representation
    code = generate_expression_code(expr, cell, form_argument_mapping, object_names,
                                    ToyCppLanguageFormatter, ToyCppStatementFormatter)

    # Wrap in a block for readability
    code = Block(code)

    # Format code representation into a single string
    formatted = format_code_structure(code)
    return formatted

def compile_form(form, prefix=""):
    "Toy compiler, translating a Form to a block of code that is not quite compilable."

    # Preprocess form
    form_data = form.compute_form_data()

    # We'll place all code in a list while building the program
    code = []

    # Generate code for each integral
    k = 0
    for ida in form_data.integral_data:
        for integral in ida.integrals:
            integrand = integral.integrand()

            # TODO: Unify this code with compile_expression:
            expr = integrand
            cell = form_data.cell
            object_names = form_data.object_names
            form_argument_mapping = form_data.function_replace_map
            argument_mapping = dict((k,v) for (k,v) in form_argument_mapping.items() if isinstance(k, Argument))

            # Build code representation
            integral_code = generate_expression_code(expr, cell, form_argument_mapping, object_names,
                                                     ToyCppLanguageFormatter, ToyCppStatementFormatter)

            # Wrap in a block for readability
            code.append(['',Block(integral_code),''])

    # Format code representation into a single string
    formatted = format_code_structure(code)
    return formatted

def compile_element(element, prefix=""):
    return "// Toy compiler has no element support. Element repr: %r" % (element,)
