
# TODO: Attach form_data.cell to target_formatter for geometry generation?
# TODO: Attach data from ffc to target_formatter for element generation?
# TODO: Move integrate to be a target_formatter property?

from ufl.classes import Argument
from uflacs.backends.cpp2.compiler import compute_expression_body_ir

def compute_tabulate_tensor_ir(ffc_data,
                               itg_data,
                               form_data,
                               parameters):
    # TODO: Just keep it simple now, and adjust the default
    #       formatter to match what we need for ffc

    #domain_type = itg_data.domain_type # TODO: Use this
    #cell = form_data.cell # TODO: Use this

    assert len(itg_data.integrals) == 1
    integrand = itg_data.integrals[0].integrand()

    argument_mapping = dict((k,v) for (k,v) in
                            form_data.function_replace_map.items()
                            if isinstance(k, Argument))
    assert len(argument_mapping) == form_data.rank

    uir = compute_expression_body_ir(integrand,
                                     argument_mapping)

    uir["function_replace_map"] = form_data.function_replace_map
    uir["object_names"] = {} #form_data.object_names # TODO
    uir["cell"] = form_data.cell

    # These are inserted by ffc representation code:
    #uir["domain_type"] = itg_data.domain_type
    #uir["quadrature_weights"] = { num_points: (w, (x,y)) }
    return uir


def optimize_tabulate_tensor_ir(ir, parameters):
    # TODO: Implement some optimization here!
    oir = ir
    return oir


from uflacs.codeutils.target_formatter import DependencyHandler
from uflacs.backends.ffc.ffc_target_formatter import FFCLanguageFormatter, FFCStatementFormatter
from uflacs.backends.cpp2.compiler import generate_expression_body_code
from uflacs.codeutils.format_code_structure import format_code_structure, Indented

def generate_tabulate_tensor_code(ir, parameters):
    # Create backend specific plugin objects
    dependency_handler = DependencyHandler(ir["object_names"], ir["function_replace_map"])
    language_formatter = FFCLanguageFormatter(dependency_handler, ir)
    statement_formatter = FFCStatementFormatter(dependency_handler, ir)

    # Use generic compiler routine to compile expression body
    code = generate_expression_body_code(ir, language_formatter, statement_formatter)

    # Format uflacs specific code structure into a single string
    code = format_code_structure(Indented(code))
    return code

def compile_tabulate_tensor_code(form, optimize=True):
    "Compile_code is a joining of compute_ir, optimize_ir, and generate_ir, for testing."
    from ffc.cpp import set_float_formatting
    from ffc.uflacsrepr import compute_integral_ir, optimize_integral_ir, generate_integral_code

    # Fake the initialization necessary to get this running through
    set_float_formatting(8)
    parameters = { "optimize": optimize }
    prefix = "uflacs_testing"
    form_id = 0

    # Apply ufl preprocessing
    form_data = form.compute_form_data()

    tt_codes = []
    for itg_data in form_data.integral_data:
        # Just make a fixed choice of cubic default quadrature rule
        itg_data.metadata["quadrature_degree"] = itg_data.metadata.get("quadrature_degree", 3)
        itg_data.metadata["quadrature_rule"] = itg_data.metadata.get("quadrature_rule", "default")

        # Call uflacs representation functions from ffc, which again calls the matching uflacs functions
        ir = compute_integral_ir(itg_data, form_data, form_id, parameters)
        if optimize:
            ir = optimize_integral_ir(ir, parameters)
        code = generate_integral_code(ir, prefix, parameters)

        # Store just the tabulate tensor part generated by uflacs
        tt_codes.append(code["tabulate_tensor"])

    # Just joint the tabulate tensor bodies and return
    code = ('\n' + '/'*60 + '\n').join(tt_codes)
    return code
