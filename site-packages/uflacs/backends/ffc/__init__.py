
def compute_uflacs_integral_ir(ffc_data,
                               itg_data,
                               form_data,
                               parameters):
    # TODO: Fill in uflacs specific intermediate representation data
    # For now just storing form data to use directly in generate_tabulate_tensor_code below.
    uir = {
        'ffc_data': ffc_data,
        'itg_data': itg_data,
        'form_data': form_data,
        }
    return uir

def optimize_integral_ir(ir, parameters):
    # TODO: Implement some optimization here!
    oir = ir
    return oir

def generate_tabulate_tensor_code(ir, parameters):

    ffc_data = ir['ffc_data']
    itg_data = ir['itg_data']
    form_data = ir['form_data']

    domain_type = itg_data.domain_type
    integrand = itg_data.integral.integrand()

    # TODO: Just keep it simple now, and adjust the default formatter to match what we need for ffc
    from uflacs.codeutils.target_formatter import CppDefaultFormatter
    target_formatter = CppDefaultFormatter()
    target_formatter.form_argument_mapping = form_data.function_replace_map

    # TODO: Attach form_data.cell to target_formatter for geometry generation?

    # TODO: Attach data from ffc to target_formatter for element generation?

    # TODO: Move part of this into ir stage
    # Use generic compiler routine to compile expression body
    from uflacs.backends.cpp2.compiler import compile_expression_body
    code = compile_expression_body(integrand,
                                   target_formatter,
                                   integrate=True)

    # Format uflacs specific code structure into a single string
    code = format_code_structure(code)
    return code
