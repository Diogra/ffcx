import numpy
from uflacs.utils.assertions import uflacs_assert
from uflacs.utils.log import warning, error

from ufl.classes import (Terminal, Indexed, Grad,
                         Restricted, PositiveRestricted, NegativeRestricted,
                         Coefficient, Argument,
                         GeometricQuantity, SpatialCoordinate,
                         FacetNormal, FacetArea,
                         CellVolume, CellSurfaceArea, FacetArea, Circumradius)

from ufl.algorithms import MultiFunction
from uflacs.codeutils.cpp_format import CppFormatterRulesCollection
from uflacs.codeutils.format_code_structure import ForRange

from uflacs.geometry.generate_geometry_snippets import (
    generate_jacobian_snippets,
    generate_jacobian_inverse_snippets,
    generate_x_from_xi_snippets,
    generate_xi_from_x_snippets)

from uflacs.codeutils.target_formatter import analyse_terminalish, DependencyHandler

from ufl.common import component_to_index
from ufl.permutation import build_component_numbering

from ffc.cpp import _generate_psi_name

# TODO: Use standardized formatting utils for cleaner code formatting, including declarations
#fmt_assign = "%s = %s;"
fmt_accum = "%s += %s;"
#fmt_mult = "%s *= %s;"
fmt_prod = "%s * %s"
fmt_access = "%s[%s]"
fmt_access2 = "%s[%s][%s]"

class Names:
    def __init__(self):
        # Geometry names
        self.xi = "xi"
        self.x = "x"
        self.detJ = "detJ"

        # Tabulate tensor argument names
        self.A = "A"
        self.w = "w"

        # (Base)name for intermediate registers
        self.s = "s"

        # Basenames for function components
        self.wbase = "w"
        self.vbase = "v"
        self.dwbase = "dw"
        self.dvbase = "dv"

        # Loop indices
        self.iq = "iq"
        self.ic = "ic"
        self.ia = "ia"
        self.ild = "ild"

        # Quadrature rule
        self.points = "points"
        self.weights = "weights"

        # Quadrature temps
        self.qw = "qw"
        self.D = "D"

names = Names()

def derivatives_counting_to_listing(derivs, gdim):
    derivatives = []
    for i, d in enumerate(derivs):
        derivatives.extend((i,)*d)
    return derivatives

def derivatives_listing_to_counting(derivatives, gdim):
    derivs = [0]*gdim
    for d in derivatives:
        derivs[d] += 1
    return derivs

def get_element_table_data(ir, num_points, element, component, derivatives, restriction):
    # FIXME: This works for cell only, need to work around fixed table name per entity to avoid duplicate code for each facet!
    entity = None
    # Can make tables like this to hack easy access:
    #const double * const E%(entity_dim)d[%(num_entities)d] = { phi%(entity_dim)s0, phi%(entity_dim)s1, phi%(entity_dim)s2 };

    # Change format of derivatives tuple, counting instead of enumerating
    gdim = element.cell().geometric_dimension()
    derivs = derivatives_listing_to_counting(derivatives, gdim)

    # Get ffc table name for element values
    element_number = ir["element_map"][num_points][element]
    element_table_name = _generate_psi_name(element_number, ir["entitytype"], entity, component, derivs)
    if element_table_name not in ir["name_map"]:
        print
        print ir["name_map"].keys()
        print
    unique_table_name, non_zeros, zeros, ones = ir["name_map"][element_table_name]

    # Get ffc table shape
    unique_table = ir["unique_tables"][unique_table_name]
    sh = numpy.shape(unique_table)
    num_dofs = sh[1]
    assert num_points == sh[0]

    # TODO: Use non_zeros, zeros, ones for optimization
    # TODO: Record used reference to table somewhere for code generation stage

    return unique_table_name, non_zeros, zeros, ones

def element_table_access(ir, num_points, component, derivatives, restriction, element, idof):
    unique_table_name, non_zeros, zeros, ones = \
        get_element_table_data(ir, num_points, element, component, derivatives, restriction)

    # Format direct access to table values
    code = fmt_access2 % (unique_table_name, names.iq, idof)

    return code

class FFCStatementFormatter(object):
    """Class containing functions for generating definitions of registers,
    argument loops, and output variable names."""
    def __init__(self, dependency_handler, ir):
        self._dependency_handler = dependency_handler
        self._domain_type = ir["domain_type"]
        self._cell = ir["cell"]
        self._argument_space_dimensions = ir["prim_idims"]

        self._ir = ir

        # TODO: Make parameters:
        self._enable_coord_loop   = True # False for vertex point integral
        self._points_are_local    = True # False for multiple point integral
        self._enable_accumulation = True # False for point integral

        # TODO: Support multiple quadrature loops, affects several places...
        quadrature_rules = ir["quadrature_weights"]
        if quadrature_rules:
            uflacs_assert(len(quadrature_rules) == 1, "Multiple quadrature rules not implemented.")
            self._num_points = quadrature_rules.keys()[0]
            self._weights, self._points = quadrature_rules[self._num_points]
        else:
            self._num_points = 0
            self._weights = ()
            self._points = ()

    def define_registers(self, num_registers, partition=None): # Partition is not yet used by compiler
        code = ["// Declaring variables for intermediate computations:"]

        name = names.s if partition is None else ("%s%d" % (names.s,partition))
        code += ["double %s[%d];" % (name, num_registers)]

        code.append("")
        return code

    def define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # TODO: Build this from terminal data and dependency dict
        needed = {
            "J": ("",),
            "detJ": ("",),
            "K": ("",),
            }

        # Generate code in fixed ordering
        for r in needed.get("J", ()):
            code.extend(generate_jacobian_snippets(self._cell, r))
        # TODO: Separate detJ computation
        for r in needed.get("K", ()):
            code.extend(generate_jacobian_inverse_snippets(self._cell, r))

        # TODO: Add all cell geometry stuff here, cell volume etc.
        #for r in needed.get("volume", ()):
        #    code.extend(generate_volume_snippets(self._cell, r))
        #for r in needed.get("circumradius", ()):
        #    code.extend(generate_circumradius_snippets(self._cell, r))

        if self._num_points > 0:
            # Define quadrature rules
            fmt_float = lambda f: "%g" % f # TODO: Use utility for float formatting precision
            fmt_floats = lambda fs: ', '.join(map(fmt_float, fs))
            weights = fmt_floats(self._weights)
            points = fmt_floats(x for p in self._points for x in p)
            pdim = len(self._points[0])
            code.extend(["", "// Quadrature weights and points",
                "static const double %s[%d] = { %s };" % (names.weights, self._num_points, weights),
                "static const double %s[%d] = { %s };" % (names.points, self._num_points*pdim, points),
                ])

        code.append("")
        return code

    def _define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # A dependency graph like this might be a way to
        # automatically figure out which quantities to generate?
        dependencies = {
            "J": ("vertex_coordinates",),
            "detJ": ("J",),
            "K": ("J","detJ"),
            "x": ("xi", "J", "vertex_coordinates"),
            "xi": ("x", "K", "vertex_coordinates"),
            }
        geometric_quantity_name = str

        # Get the set of all geometry we need
        needed = set()
        for (t, ngrads, r) in self._dependency_handler.terminal_data:
            if isinstance(t, GeometricQuantity):
                uflacs_assert(ngrads == 0, "Derivatives of geometry not supported.")
                needed.add((geometric_quantity_name(t), r))

        # Make an intermediate stable but arbitrary sorting
        workstack = sorted(needed)

        # Make a set of already known quantities
        done = set()
        done.add("vertex_coordinates")

        # Make a set of quantities to postphone
        skip = set(item for item in workstack if item[0] in ("x","xi"))
        # ... but keep these in workstack to build dependencies properly!

        # Build list of geometry including dependencies
        ordered = []
        while workstack:
            # Get next item to do
            item = workstack.pop(0)
            # Drop it if already done
            if item in done:
                continue
            # Get dependencies of item that are not done
            deps = [(d, r) for d in dependencies[item[0]]
                    if (d, r) not in done]
            if deps:
                # If we have any dependencies, put them first on the stack
                workstack = deps + [item] + workstack
            else:
                # If we have no dependencies, do this item next,
                # unless it's postphoned
                if item not in skip:
                    ordered.append(item)

        # Finally we can generate some code
        for name, restriction in ordered:
            code.append("// TODO: Compute %s%s here" % (name, restriction))

        code.append("")
        return code

    def define_coord_loop(self):
        if self._enable_coord_loop:
            code = ["",
                    "// Loop over coordinates",
                    "for (int %s = 0; %s < %d; ++%s)" % (names.iq, names.iq,
                                                         self._num_points, names.iq)]
            return code
        else:
            return None

    def define_coord_vars(self):
        code = ["// Computing coordinates in necessary coordinate systems:"]

        # TODO: Parameter to pick behaviour here:
        # For dx, we need xi -> x
        # For ds, we need xi_facet -> xi -> x
        # For dS, we need xi_facet -> xi0,xi1 -> x0,x1
        # For dP(points), we need x -> xi
        # For dP(vertex), we need
        #   x = &vertex_coordinates[vertex*gd]; # TODO: Assumption on ordering of vertices?
        #   xi = &reference_vertex_coordinates[vertex*gd]

        if self._points_are_local:
            # cell integral
            code += ["const double *%s = &%s[%d*iq];" % (
                names.xi, names.points, self._cell.topological_dimension())]
            # TODO: Restrictions
            code.extend(generate_x_from_xi_snippets(self._cell, ""))
        else:
            # multiple point evaluation
            code += ["const double *%s = &%s[%d * %s];" % (
                names.x, names.points, self._cell.geometric_dimension(), names.iq)]
            # TODO: Restrictions
            code.extend(generate_xi_from_x_snippets(self._cell, ""))

        # Define weights
        if self._enable_accumulation:
            code += ["", "// Compute accumulation weight:"]
            code += ["const double %s = %s;" % (names.qw, fmt_access % (names.weights, names.iq))]
            # TODO: Use correct name for 'det', depending on integral type?
            code += ["const double %s = %s * std::abs(%s);" % (names.D, names.qw, names.detJ)] # TODO: Store absolute value?

        code += [""]
        return code

    def define_coord_dependent_geometry(self):
        # No such thing yet, place e.g. non-affine jacobi here if needed
        return []

    def accumulation_scaling_factor(self):
        if self._enable_accumulation:
            return "D"
        else:
            return None

    def define_piecewise_coefficients(self):
        dh = self._dependency_handler
        code = ["// %s = %s[%d][0:%d]" % (dh.coefficient_names[c], names.w, i,
                                          self._ir["coeff_idims"][i])
                for i, c in enumerate(dh.coefficients)
                if c.is_cellwise_constant()]
        if code:
            comment = "// Constants are fetched directly from dof array %s[][]:" % (names.w,)
            code = [comment] + code + [""]
        return code

    def _define_coord_dependent_coefficient(self, w, reqdata):
        "Define a single coordinate dependent coefficient."
        code = []

        # Get some properties of w
        wc = w.count()
        element = w.element()
        wsh = w.shape()
        if wsh:
            vi2si, dummy = build_component_numbering(wsh, element.symmetry())
        else:
            # Need scalar component to be () for table naming
            vi2si = {():()}

        # Offset by element space dimension in case of negative restriction.
        #import ffc
        #ffc_element = ffc.fiatinterface.create_element(element)
        #fe_dim = ffc_element.space_dimension()
        fe_dim = self._ir["coeff_idims"][wc] # TODO: Nicer way to get ndofs?

        r_offsets = {"+": 0, "-": fe_dim, None: 0}

        tdim = self._cell.topological_dimension()
        gdim = self._cell.geometric_dimension()

        # Render code for all referenced components in a canonical ordering
        done = {}
        keys = sorted(reqdata.keys())
        for key in keys:
            (c,d,r) = key
            wname = reqdata[key]

            # Map component to flat index, including symmetry mapping
            c = vi2si[c]

            # Keep record of variable names already handled, and
            # check that equal variable names represent equal values
            if wname not in done:
                done[wname] = (c,d,r)
            else:
                uflacs_assert(done[wname] == (c,d,r),
                              "Variable '%s' already defined differently." % wname)
                # Skip symmetric tensor components
                continue

            if d:
                # TODO: Higher order derivatives?

                # FIXME:
                ldwname = "ld_" + wname
                code.append("double %s[%d] = { %s };" % (ldwname, tdim, ", ".join(["0.0"]*tdim)))
                body = []

                # For each local derivative direction FIXME: Avoid repeating
                for ld in range(tdim):
                    # Get element derivative value table data
                    (unique_table_name, non_zeros, zeros, ones) = \
                      get_element_table_data(self._ir, self._num_points, element, c, (ld,), r)

                    # Get bounds on dof index loop
                    if non_zeros:
                        lower, upper = min(non_zeros[1]), max(non_zeros[1])+1
                    else:
                        lower, upper = 0, fe_dim

                    # Add restriction offset and lower dof index bound
                    offset = lower + r_offsets[r]
                    num_dofs = upper - lower

                    # FIXME: Take inner products with dofs

                    # Format loop accumulating product of dofs and table values
                    wexpr = fmt_access2 % (names.w, wc, "%s + %s" % (names.ic, offset))
                    feexpr = fmt_access2 % (unique_table_name, names.iq, names.ic)
                    w_fe = fmt_prod % (wexpr, feexpr) # FIXME
                    body.append(fmt_accum % (fmt_access % (ldwname, ld), w_fe)) # FIXME

                code.append(ForRange(names.ic, 0, num_dofs, body=body)) # FIXME

                # FIXME: Map derivatives with K (or J^T) to get the global derivative direction d

            else:
                # Get element value table data
                (unique_table_name, non_zeros, zeros, ones) = \
                    get_element_table_data(self._ir, self._num_points, element, c, d, r)

                # Get bounds on dof index loop
                if non_zeros:
                    lower, upper = min(non_zeros[1]), max(non_zeros[1])+1
                else:
                    lower, upper = 0, fe_dim

                # Add restriction offset and lower dof index bound
                offset = lower + r_offsets[r]
                num_dofs = upper - lower

                # Format loop accumulating product of dofs and table values
                wexpr = fmt_access2 % (names.w, wc, "%s + %s" % (names.ic, offset))
                feexpr = fmt_access2 % (unique_table_name, names.iq, names.ic)
                w_fe = fmt_prod % (wexpr, feexpr)
                body = fmt_accum % (wname, w_fe)

                code.append("double %s = 0.0;" % (wname,))
                code.append(ForRange(names.ic, 0, num_dofs, body=body))

        return code

    def define_coord_dependent_coefficients(self):
        "Define all coordinate dependent coefficients."
        dh = self._dependency_handler
        code = []

        # Compute non-constant coefficients and their derivatives
        for _w in dh.coefficients: # FIXME: Shouldn't this be the mapped coefficients?
            name = dh.coefficient_names[_w]
            w = dh.form_argument_mapping[_w]

            # Constants are handled by direct reference to dof array
            if w.is_cellwise_constant():
                continue

            # Only compute coefficient components that have been referenced
            reqdata = dh.required.get(w)
            if reqdata is None:
                print
                print "In define_coord_dependent_coefficients: req is None:"
                print 'repr(w):', repr(w)
                print 'str(w): ', str(w)
                print 'required set:'
                print dh.required
                print
                continue

            code.append("// Compute coefficient %s" % name)
            code.append(self._define_coord_dependent_coefficient(w, reqdata))

        if code:
            comment = "// Compute coordinate dependent coefficients and their derivatives"
            code = [comment, code, ""]
        return code

    def define_argument_for_loop(self, argument_count):
        iname = "%s%d" % (names.ia, argument_count) # FIXME: Make reusable function
        isize = self._argument_space_dimensions[argument_count]
        return "for (int %s = 0; %s < %d; ++%s)" % (iname, iname, isize, iname)

    def define_argument_loop_vars(self, argument_count):
        code = []

        # FIXME: Compute mapped derivatives of arguments

        if code:
            comment = "// Compute derivatives of argument %d mapped to " % (argument_count,)
            code = [comment] + code + [""]
        return code

    def output_variable_names(self, num_variables):
        return [fmt_access % (names.A, i) for i in xrange(num_variables)]


class FFCLanguageFormatter(MultiFunction, CppFormatterRulesCollection):
    """FFC specific cpp formatter class."""
    def __init__(self, dependency_handler, ir):
        MultiFunction.__init__(self)
        CppFormatterRulesCollection.__init__(self)

        # An object used to track who depends on what
        self._dependency_handler = dependency_handler

        # The rest of the FFC representation dict, flexible way to work for now,
        # maybe replace with whatever we need more specifically later
        self._ir = ir

        self._cell = ir["cell"]

        # HACK! FIXME: Handle different quadrature rules!
        self._num_points, = ir["quadrature_weights"].keys()

    def geometric_quantity(self, o, component=(), derivatives=(), restriction=None):
        "Generic rendering of variable names for all piecewise constant geometric quantities."
        uflacs_assert(not derivatives,
                      "Compiler should be able to simplify derivatives of geometry.")

        # Simply using the UFL str to define the name in the generated code, ensures consistency
        name = str(o)
        if restriction:
            name = name + restriction

        # Indexing if there is a shape
        sh = o.shape()
        if sh:
            uflacs_assert(component, "Missing component for nonscalar %r." % o)
            code = fmt_access % (name, component_to_index(component, sh))
        else:
            uflacs_assert(component == (), "Component specified for scalar %r." % o)
            code = name

        # Make a record of dependency
        self._dependency_handler.require(o, component, derivatives, restriction, code)

        return code

    def facet_area(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(restriction is None, "Assuming facet_area is not restricted.")
        return self.geometric_quantity(o, component, derivatives, restriction)

    def _piecewise_constant_coefficient(self, o, component, derivatives, restriction):
        uflacs_assert(not derivatives,
                      "Not expecting derivatives of constant coefficients!")

        # Map component to flat index
        vi2si, si2vi = build_component_numbering(o.shape(), o.element().symmetry())
        comp = vi2si[component]
        size = len(si2vi)

        # Offset index if on second cell in interior facet integral
        if restriction == "-":
            comp += size

        # Return direct reference to dof array
        return fmt_access2 % (names.w, o.count(), comp)

    def _computed_form_argument_name(self, o, component, derivatives, restriction, basename):
        # Format base coefficient (derivative) name
        code = "%s%d" % (basename, o.count())
        if derivatives:
            gdim = self._cell.geometric_dimension()
            # Change format of derivatives tuple, counting instead of enumerating
            derivs = derivatives_listing_to_counting(derivatives, gdim)
            code += "_d%s" % ''.join(map(str,derivs))

        if o.shape():
            # Map component to flat index
            vi2si, si2vi = build_component_numbering(o.shape(), o.element().symmetry())
            comp = vi2si[component]

            # Offset index if on second cell in interior facet integral
            if restriction == "-":
                comp += len(si2vi)

            code += "_c%d" % comp

        return code

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        dh = self._dependency_handler

        o = dh.form_argument_mapping.get(o, o)
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        if o.is_cellwise_constant():
            return self._piecewise_constant_coefficient(o, component, derivatives, restriction)
        else:
            # FIXME: Generate code to compute this in statement formatter!
            code = self._computed_form_argument_name(o, component, derivatives, restriction, names.wbase)
            dh.require(o, component, derivatives, restriction, code)
            return code

    def _element_table_access(self, component, derivatives, restriction, element, idof):
        # FIXME: Record that we need this table
        return element_table_access(self._ir, self._num_points, component, derivatives, restriction, element, idof)

    def argument(self, o, component=(), derivatives=(), restriction=None):
        dh = self._dependency_handler

        o = dh.form_argument_mapping[o]
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        if derivatives:
            # FIXME: Generate code to compute this in statement formatter!
            code = self._computed_form_argument_name(o, component, derivatives, restriction, names.vbase)
        else:
            iname = "i%d" % o.count() # FIXME: Make reusable functions for formatting names
            # No need to store basis function value in its own variable, just get table value directly
            code = self._element_table_access(component, derivatives, restriction, o.element(), iname)

        dh.require(o, component, derivatives, restriction, code)
        return code
