from uflacs.utils.assertions import uflacs_assert
from uflacs.utils.log import warning, error

from ufl.classes import (Terminal, Indexed, Grad,
                         Restricted, PositiveRestricted, NegativeRestricted,
                         Coefficient, Argument,
                         GeometricQuantity, SpatialCoordinate,
                         FacetNormal, FacetArea,
                         CellVolume, CellSurfaceArea, FacetArea, Circumradius)

from ufl.algorithms import MultiFunction
from uflacs.codeutils.cpp_format import CppFormatterRulesCollection

from uflacs.geometry.generate_geometry_snippets import (
    generate_jacobian_snippets,
    generate_jacobian_inverse_snippets,
    generate_x_from_xi_snippets,
    generate_xi_from_x_snippets)

from uflacs.codeutils.target_formatter import analyse_terminalish, DependencyHandler

# FIXME: Replace these with ufl component utilities:
from uflacs.codeutils.target_formatter import flatten_component, component_value_size

from ffc.cpp import _generate_psi_name

def element_table_access(ir, num_points, component, derivatives, restriction, element, idof):
    # FIXME: Make reusable functions for formatting names
    iqname = "iq"

    # FIXME: This works for cell only, need to work around fixed table name per entity to avoid duplicate code for each facet!
    entity = None

    # Change format of derivatives tuple, counting instead of enumerating
    gdim = element.cell().geometric_dimension()
    derivs = [0]*gdim
    for d in derivatives: # TODO: Utility function?
        derivs[d] += 1

    # Get ffc table name for element values
    element_number = ir["element_map"][num_points][element]
    element_table_name = _generate_psi_name(element_number, ir["entitytype"], entity, component, derivs)
    unique_table_name, non_zeros, zeros, ones = ir["name_map"][element_table_name]

    # TODO: Use non_zeros, zeros, ones for optimization
    # TODO: Record used reference to table somewhere for code generation stage

    # Format direct access to table values
    code = "%s[%s][%s]" % (unique_table_name, iqname, idof)

    return code

class FFCStatementFormatter(object):
    """Class containing functions for generating definitions of registers,
    argument loops, and output variable names."""
    def __init__(self, dependency_handler, ir):
        self._dependency_handler = dependency_handler
        self._domain_type = ir["domain_type"]
        self._cell = ir["cell"]
        self._argument_space_dimensions = ir["prim_idims"]

        self._ir = ir

        # TODO: Make parameters:
        self._enable_coord_loop   = True # False for vertex point integral
        self._points_are_local    = True # False for multiple point integral
        self._enable_accumulation = True # False for point integral

        self._num_points_name = "num_points"
        self._points_name = "points"
        self._weights_name = "weights"

        # TODO: Support multiple quadrature loops, affects several places...
        quadrature_rules = ir["quadrature_weights"]
        if quadrature_rules:
            uflacs_assert(len(quadrature_rules) == 1, "Multiple quadrature rules not implemented.")
            self._num_points = quadrature_rules.keys()[0]
            self._weights, self._points = quadrature_rules[self._num_points]
        else:
            self._num_points = 0
            self._weights = ()
            self._points = ()

    def define_registers(self, num_registers, partition=None): # Partition is not yet used by compiler
        code = ["// Declaring variables for intermediate computations:"]

        name = "s" if partition is None else ("s%d" % partition)
        code += ["double %s[%d];" % (name, num_registers)]

        code.append("")
        return code

    def define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # TODO: Build this from terminal data and dependency dict
        needed = {
            "J": ("",),
            "detJ": ("",),
            "K": ("",),
            }

        # Generate code in fixed ordering
        for r in needed.get("J", ()):
            code.extend(generate_jacobian_snippets(self._cell, r))
        # TODO: Separate detJ computation
        for r in needed.get("K", ()):
            code.extend(generate_jacobian_inverse_snippets(self._cell, r))

        # TODO: Add all cell geometry stuff here, cell volume etc.
        #for r in needed.get("volume", ()):
        #    code.extend(generate_volume_snippets(self._cell, r))
        #for r in needed.get("circumradius", ()):
        #    code.extend(generate_circumradius_snippets(self._cell, r))

        if self._num_points > 0:
            # Define quadrature rules
            fmt_float = lambda f: "%g" % f # TODO: Use utility for float formatting precision
            fmt_floats = lambda fs: ', '.join(map(fmt_float, fs))
            weights = fmt_floats(self._weights)
            points = fmt_floats(x for p in self._points for x in p)
            pdim = len(self._points[0])
            code.extend(["", "// Quadrature weights and points",
                "static const double %s[%d] = { %s };" % (self._weights_name, self._num_points, weights),
                "static const double %s[%d] = { %s };" % (self._points_name, self._num_points*pdim, points),
                ])

        code.append("")
        return code

    def _define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # A dependency graph like this might be a way to
        # automatically figure out which quantities to generate?
        dependencies = {
            "J": ("vertex_coordinates",),
            "detJ": ("J",),
            "K": ("J","detJ"),
            "x": ("xi", "J", "vertex_coordinates"),
            "xi": ("x", "K", "vertex_coordinates"),
            }
        geometric_quantity_name = str

        # Get the set of all geometry we need
        needed = set()
        for (t, ngrads, r) in self._dependency_handler.terminal_data:
            if isinstance(t, GeometricQuantity):
                uflacs_assert(ngrads == 0, "Derivatives of geometry not supported.")
                needed.add((geometric_quantity_name(t), r))

        # Make an intermediate stable but arbitrary sorting
        workstack = sorted(needed)

        # Make a set of already known quantities
        done = set()
        done.add("vertex_coordinates")

        # Make a set of quantities to postphone
        skip = set(item for item in workstack if item[0] in ("x","xi"))
        # ... but keep these in workstack to build dependencies properly!

        # Build list of geometry including dependencies
        ordered = []
        while workstack:
            # Get next item to do
            item = workstack.pop(0)
            # Drop it if already done
            if item in done:
                continue
            # Get dependencies of item that are not done
            deps = [(d, r) for d in dependencies[item[0]]
                    if (d, r) not in done]
            if deps:
                # If we have any dependencies, put them first on the stack
                workstack = deps + [item] + workstack
            else:
                # If we have no dependencies, do this item next,
                # unless it's postphoned
                if item not in skip:
                    ordered.append(item)

        # Finally we can generate some code
        for name, restriction in ordered:
            code.append("// TODO: Compute %s%s here" % (name, restriction))

        code.append("")
        return code

    def define_coord_loop(self):
        if self._enable_coord_loop:
            code = ["",
                    "// Loop over coordinates",
                    "for (int iq=0; iq<%d; ++iq)" % self._num_points]
            return code
        else:
            return None

    def define_coord_vars(self):
        code = ["// Computing coordinates in necessary coordinate systems:"]

        # TODO: Parameter to pick behaviour here:
        # For dx, we need xi -> x
        # For ds, we need xi_facet -> xi -> x
        # For dS, we need xi_facet -> xi0,xi1 -> x0,x1
        # For dP(points), we need x -> xi
        # For dP(vertex), we need
        #   x = &vertex_coordinates[vertex*gd]; # TODO: Assumption on ordering of vertices?
        #   xi = &reference_vertex_coordinates[vertex*gd]

        if self._points_are_local:
            # cell integral
            code += ["const double *xi = &%s[%d*iq];" % (
                self._points_name, self._cell.topological_dimension())]
            # TODO: Restrictions
            code.extend(generate_x_from_xi_snippets(self._cell, ""))
        else:
            # multiple point evaluation
            code += ["const double *x = &%s[%d*iq];" % (
                self._points_name, self._cell.geometric_dimension())]
            # TODO: Restrictions
            code.extend(generate_xi_from_x_snippets(self._cell, ""))

        # Define weights
        if self._enable_accumulation:
            code += ["", "// Compute accumulation weight:"]
            code += ["const double qw = %s[iq];" % (self._weights_name,)]
            # TODO: Use correct name for 'det', depending on integral type?
            code += ["const double D = qw * std::abs(detJ);"] # TODO: Store absolute value?

        code += [""]
        return code

    def define_coord_dependent_geometry(self):
        # No such thing yet, place e.g. non-affine jacobi here if needed
        return []

    def accumulation_scaling_factor(self):
        if self._enable_accumulation:
            return "D"
        else:
            return None

    def define_piecewise_coefficients(self):
        dh = self._dependency_handler
        code = ["// %s = w[%d][:]" % (dh.coefficient_names[c], i)
                for i, c in enumerate(dh.coefficients)
                if c.is_cellwise_constant()]
        if code:
            comment = "// These constant coefficients are fetched directly from dof array w[][]:"
            code = [comment] + code + [""]
        return code

    def _define_coord_dependent_coefficient(self, w, reqdata):
        "Define a single coordinate dependent coefficient."
        code = []

        wc = w.count()
        we = w.element()

        # FIXME: Do things like this to get the right dof range:
        # Offset by element space dimension in case of negative restriction.
        #ffc_element = ffc.create_element(ufl_element)
        #fe_dim = ffc_element.space_dimension()
        #dofs_offset = {"+": "", "-": str(fe_dim), None: ""}[self.restriction]
        #num_dofs = shape(self.unique_tables[psi_name])[1]

        # Get list of dofs for this component
        # FIXME: Ignoring component, this is not valid for mixed elements!
        ndofs = self._ir["coeff_idims"][wc] # TODO: Nicer way to get ndofs?
        dofs = range(ndofs)

        # Format dof access
        dof_fmt = "w[%d][%%d]" % wc
        dofs = [dof_fmt % i for i in dofs]

        # Render code for all referenced components
        for (c,d,r), wname in reqdata.iteritems():

            if d:
                # FIXME: Get element derivative value tables for each local derivative direction
                dbftable = [[element_table_access(self._ir, self._num_points, c, ld, r, we, i)
                             for i in range(ndofs)]
                             for ld in range(tdim)]
                # FIXME: Take inner products with dofs
                wcode = " + ".join("%s * %s" % (dofs[i], bftable[i]) for i in range(ndofs)) # TODO: Skip bftable zeros
                # FIXME: Map derivatives with K (or J^T) to get the global derivative direction d
                code.append("const double %s = %s;" % (wname, wcode))
            else:
                bftable = [element_table_access(self._ir, self._num_points, c, d, r, we, i)
                           for i in range(ndofs)]
                wcode = " + ".join("%s * %s" % (dofs[i], bftable[i]) for i in range(ndofs)) # TODO: Skip bftable zeros
                code.append("const double %s = %s;" % (wname, wcode))

        return code

    def define_coord_dependent_coefficients(self):
        "Define all coordinate dependent coefficients."
        dh = self._dependency_handler
        code = []

        # Compute non-constant coefficients and their derivatives
        for _w in dh.coefficients: # FIXME: Shouldn't this be the mapped coefficients?
            name = dh.coefficient_names[_w]
            w = dh.form_argument_mapping[_w]

            # Constants are handled by direct reference to dof array
            if w.is_cellwise_constant():
                continue

            # Only compute coefficient components that have been referenced
            reqdata = dh.required.get(w)
            if reqdata is None:
                print
                print "In define_coord_dependent_coefficients: req is None:"
                print 'repr(w):', repr(w)
                print 'str(w): ', str(w)
                print 'required set:'
                print dh.required
                print
                continue

            code.append("// Compute coefficient %s" % name)
            code.append(self._define_coord_dependent_coefficient(w, reqdata))

        if code:
            comment = "// Compute coordinate dependent coefficients and their derivatives"
            code = [comment, code, ""]
        return code

    def define_argument_for_loop(self, argument_count):
        iname = "i%d" % (argument_count,) # FIXME: Make reusable function
        isize = self._argument_space_dimensions[argument_count]
        return "for (int %s = 0; %s < %d; ++%s)" % (iname, iname, isize, iname)

    def define_argument_loop_vars(self, argument_count):
        code = []

        # FIXME: Compute mapped derivatives of arguments

        if code:
            comment = "// Compute derivatives of argument %d mapped to " % (argument_count,)
            code = [comment] + code + [""]
        return code

    def output_variable_names(self, num_variables):
        return ["A[%d]" % (i,) for i in xrange(num_variables)]


class FFCLanguageFormatter(MultiFunction, CppFormatterRulesCollection):
    """FFC specific cpp formatter class."""
    def __init__(self, dependency_handler, ir):
        MultiFunction.__init__(self)
        CppFormatterRulesCollection.__init__(self)

        # An object used to track who depends on what
        self._dependency_handler = dependency_handler

        # The rest of the FFC representation dict, flexible way to work for now,
        # maybe replace with whatever we need more specifically later
        self._ir = ir

        self._cell = ir["cell"]

        # HACK! FIXME: Handle different quadrature rules!
        self._num_points, = ir["quadrature_weights"].keys()

    def geometric_quantity(self, o, component=(), derivatives=(), restriction=None):
        "Generic rendering of variable names for all piecewise constant geometric quantities."
        uflacs_assert(not derivatives,
                      "Compiler should be able to simplify derivatives of geometry.")

        # Simply using the UFL str to define the name in the generated code, ensures consistency
        name = str(o)
        if restriction:
            name = name + restriction

        # Indexing if there is a shape
        sh = o.shape()
        if sh:
            uflacs_assert(component, "Missing component for nonscalar %r." % o)
            code = "%s[%d]" % (name, flatten_component(component, sh, None))
        else:
            uflacs_assert(component == (), "Component specified for scalar %r." % o)
            code = name

        # Make a record of dependency
        self._dependency_handler.require(o, component, derivatives, restriction, code)

        return code

    def facet_area(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(restriction is None, "Assuming facet_area is not restricted.")
        return self.geometric_quantity(o, component, derivatives, restriction)

    def _piecewise_constant_coefficient(self, o, component, derivatives, restriction):
        uflacs_assert(not derivatives,
                      "Not expecting derivatives of constant coefficients!")
        # Map component to flat index
        comp = flatten_component(component, o.shape(), o.element().symmetry())
        # Offset index if on second cell in interior facet integral
        if restriction == "+":
            comp += component_value_size(o.shape(), o.element().symmetry())
        # Return direct reference to dof array
        return "w[%d][%d]" % (o.count(), comp)

    def _computed_form_argument_name(self, o, component, derivatives, restriction, basename):
        # Change format of derivatives tuple, counting instead of enumerating
        gdim = self._cell.geometric_dimension()
        derivs = [0]*gdim
        for d in derivatives: # TODO: Utility function?
            derivs[d] += 1
        #derivatives = derivatives_counting_to_listing(derivs)
        #derivs = derivatives_listing_to_counting(derivatives)

        # Format base coefficient (derivative) name
        code = "%s%d" % (basename, o.count())
        if derivatives:
            code += "_d%s" % ''.join(map(str,derivs))

        if o.shape():
            # Map component to flat index
            comp = flatten_component(component, o.shape(), o.element().symmetry())
            # Offset index if on second cell in interior facet integral
            if restriction == "+":
                comp += component_value_size(o.shape(), o.element().symmetry())

            code += "_c%d" % comp

        return code

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        dh = self._dependency_handler

        o = dh.form_argument_mapping.get(o, o)
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        if o.is_cellwise_constant():
            return self._piecewise_constant_coefficient(o, component, derivatives, restriction)
        else:
            # FIXME: Generate code to compute this in statement formatter!
            code = self._computed_form_argument_name(o, component, derivatives, restriction, "w")
            dh.require(o, component, derivatives, restriction, code)
            return code

    def _element_table_access(self, component, derivatives, restriction, element, idof):
        # FIXME: Record that we need this table
        return element_table_access(self._ir, self._num_points, component, derivatives, restriction, element, idof)

    def argument(self, o, component=(), derivatives=(), restriction=None):
        dh = self._dependency_handler

        o = dh.form_argument_mapping[o]
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        if derivatives:
            # FIXME: Generate code to compute this in statement formatter!
            code = self._computed_form_argument_name(o, component, derivatives, restriction, "v")
        else:
            iname = "i%d" % o.count() # FIXME: Make reusable functions for formatting names
            # No need to store basis function value in its own variable, just get table value directly
            code = self._element_table_access(component, derivatives, restriction, o.element(), iname)

        dh.require(o, component, derivatives, restriction, code)
        return code
