from uflacs.utils.assertions import uflacs_assert
from uflacs.utils.log import warning, error

from ufl.classes import (Terminal, Indexed, Grad,
                         Restricted, PositiveRestricted, NegativeRestricted,
                         Coefficient, Argument,
                         GeometricQuantity, SpatialCoordinate,
                         FacetNormal, FacetArea,
                         CellVolume, CellSurfaceArea, FacetArea, Circumradius)

from ufl.algorithms import MultiFunction
from uflacs.codeutils.cpp_format import CppFormatterRulesCollection

from uflacs.geometry.generate_geometry_snippets import (
    generate_jacobian_snippets,
    generate_jacobian_inverse_snippets,
    generate_x_from_xi_snippets,
    generate_xi_from_x_snippets)

from uflacs.codeutils.target_formatter import flatten_component, component_value_size, analyse_terminalish, DependencyHandler

from ffc.cpp import _generate_psi_name

class FFCStatementFormatter(object):
    """Class containing functions for generating definitions of registers,
    argument loops, and output variable names."""
    def __init__(self, dependency_handler, domain_type, cell, quadrature_rules, argument_space_dimensions, ir):
        self._dependency_handler = dependency_handler
        self._domain_type = domain_type
        self._cell = cell
        self._argument_space_dimensions = argument_space_dimensions

        self._ir = ir

        # TODO: Make parameters:
        self._enable_coord_loop   = True # False for vertex point integral
        self._points_are_local    = True # False for multiple point integral
        self._enable_accumulation = True # False for point integral

        self._num_points_name = "num_points"
        self._points_name = "points"
        self._weights_name = "weights"

        # TODO: Support multiple quadrature loops, affects several places...
        if quadrature_rules:
            uflacs_assert(len(quadrature_rules) == 1, "Multiple quadrature rules not implemented.")
            self._num_points = quadrature_rules.keys()[0]
            self._weights, self._points = quadrature_rules[self._num_points]
        else:
            self._num_points = 0
            self._weights = ()
            self._points = ()

    def define_registers(self, num_registers, partition=None): # Partition is not yet used by compiler
        code = ["// Declaring variables for intermediate computations:"]

        name = "s" if partition is None else ("s%d" % partition)
        code += ["double %s[%d];" % (name, num_registers)]

        code.append("")
        return code

    def define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # TODO: Build this from terminal data and dependency dict
        needed = {
            "J": ("",),
            "detJ": ("",),
            "K": ("",),
            }

        # Generate code in fixed ordering
        for r in needed.get("J", ()):
            code.extend(generate_jacobian_snippets(self._cell, r))
        # TODO: Separate detJ computation
        for r in needed.get("K", ()):
            code.extend(generate_jacobian_inverse_snippets(self._cell, r))

        # TODO: Add all cell geometry stuff here, cell volume etc.
        #for r in needed.get("volume", ()):
        #    code.extend(generate_volume_snippets(self._cell, r))
        #for r in needed.get("circumradius", ()):
        #    code.extend(generate_circumradius_snippets(self._cell, r))

        if self._num_points > 0:
            # Define quadrature rules
            fmt_float = lambda f: "%g" % f # TODO: Use utility for float formatting precision
            fmt_floats = lambda fs: ', '.join(map(fmt_float, fs))
            weights = fmt_floats(self._weights)
            points = fmt_floats(x for p in self._points for x in p)
            pdim = len(self._points[0])
            code.extend(["", "// Quadrature weights and points",
                "static const double %s[%d] = { %s };" % (self._weights_name, self._num_points, weights),
                "static const double %s[%d] = { %s };" % (self._points_name, self._num_points*pdim, points),
                ])

        code.append("")
        return code

    def _define_piecewise_geometry(self):
        code = ["// Computing piecewise constant geometry:"]

        # A dependency graph like this might be a way to
        # automatically figure out which quantities to generate?
        dependencies = {
            "J": ("vertex_coordinates",),
            "detJ": ("J",),
            "K": ("J","detJ"),
            "x": ("xi", "J", "vertex_coordinates"),
            "xi": ("x", "K", "vertex_coordinates"),
            }
        geometric_quantity_name = str

        # Get the set of all geometry we need
        needed = set()
        for (t, ngrads, r) in self._dependency_handler.terminal_data:
            if isinstance(t, GeometricQuantity):
                uflacs_assert(ngrads == 0, "Derivatives of geometry not supported.")
                needed.add((geometric_quantity_name(t), r))

        # Make an intermediate stable but arbitrary sorting
        workstack = sorted(needed)

        # Make a set of already known quantities
        done = set()
        done.add("vertex_coordinates")

        # Make a set of quantities to postphone
        skip = set(item for item in workstack if item[0] in ("x","xi"))
        # ... but keep these in workstack to build dependencies properly!

        # Build list of geometry including dependencies
        ordered = []
        while workstack:
            # Get next item to do
            item = workstack.pop(0)
            # Drop it if already done
            if item in done:
                continue
            # Get dependencies of item that are not done
            deps = [(d, r) for d in dependencies[item[0]]
                    if (d, r) not in done]
            if deps:
                # If we have any dependencies, put them first on the stack
                workstack = deps + [item] + workstack
            else:
                # If we have no dependencies, do this item next,
                # unless it's postphoned
                if item not in skip:
                    ordered.append(item)

        # Finally we can generate some code
        for name, restriction in ordered:
            code.append("// TODO: Compute %s%s here" % (name, restriction))

        code.append("")
        return code

    def old_define_piecewise_geometry(self):
        code = ["// Compute piecewise constant geometry:"]

        # FIXME: Delegate this computation to cellcg!
        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        for expr, req in self._dependency_handler.required.iteritems():
            #key = (tuple(component), tuple(derivatives), restriction)
            if isinstance(expr, GeometricQuantity) and expr.is_cellwise_constant():
                for (c,d,r), code in req.iteritems():
                    impl = ["// TODO: Implement %s" % code]
                    code += impl

        code.append("")
        return code

    def define_coord_loop(self):
        if self._enable_coord_loop:
            code = ["",
                    "// Loop over coordinates",
                    "for (int iq=0; iq<%d; ++iq)" % self._num_points]
            return code
        else:
            return None

    def define_coord_vars(self):
        code = ["// Computing coordinates in necessary coordinate systems:"]

        # TODO: Parameter to pick behaviour here:
        # For dx, we need xi -> x
        # For ds, we need xi_facet -> xi -> x
        # For dS, we need xi_facet -> xi0,xi1 -> x0,x1
        # For dP(points), we need x -> xi
        # For dP(vertex), we need
        #   x = &vertex_coordinates[vertex*gd]; # TODO: Assumption on ordering of vertices?
        #   xi = &reference_vertex_coordinates[vertex*gd]

        if self._points_are_local:
            # cell integral
            code += ["const double *xi = &%s[%d*iq];" % (
                self._points_name, self._cell.topological_dimension())]
            # TODO: Restrictions
            code.extend(generate_x_from_xi_snippets(self._cell, ""))
        else:
            # multiple point evaluation
            code += ["const double *x = &%s[%d*iq];" % (
                self._points_name, self._cell.geometric_dimension())]
            # TODO: Restrictions
            code.extend(generate_xi_from_x_snippets(self._cell, ""))

        # Define weights
        if self._enable_accumulation:
            code += ["", "// Compute accumulation weight:"]
            code += ["const double qw = %s[iq];" % (self._weights_name,)]
            # TODO: Use correct name for 'det', depending on integral type?
            code += ["const double D = qw * std::abs(detJ);"] # TODO: Store absolute value?

        code += [""]
        return code

    def define_coord_dependent_geometry(self):
        code = ["// Compute x dependent geometry"]

        # FIXME: Delegate this computation to cellcg!
        # A mapping { expr: {(c,d,r): code} } used to store visited dependencies
        for expr, req in self._dependency_handler.required.iteritems():
            if isinstance(expr, GeometricQuantity) and not expr.is_cellwise_constant():
                for (c,d,r), expr_code in req.iteritems():
                    impl = ["// TODO: Implement %s" % expr_code]
                    code += impl

        code += [""]
        return code

    def accumulation_scaling_factor(self):
        if self._enable_accumulation:
            return "D"
        else:
            return None

    def define_piecewise_coefficients(self):
        dh = self._dependency_handler
        code = ["// %s = w[%d][:]" % (dh.coefficient_names[c], i)
                for i, c in enumerate(dh.coefficients)
                if c.is_cellwise_constant()]
        if code:
            return ["// These constant coefficients are fetched directly from dof array w[][]:"] + code + [""]
        else:
            return []

    def define_coord_dependent_coefficients(self):
        return ["// Compute x dependent coefficients and evt. their derivatives"]

    def define_argument_for_loop(self, argument_count):
        iname = "i%d" % (argument_count,) # FIXME: Make reusable function
        isize = self._argument_space_dimensions[argument_count]
        return "for (int %s = 0; %s < %d; ++%s)" % (iname, iname, isize, iname)

    def define_argument_loop_vars(self, argument_count):
        return ["// Compute argument %d and evt. its derivatives" % (argument_count,)]

    def output_variable_names(self, num_variables):
        return ["A[%d]" % (i,) for i in xrange(num_variables)]


class FFCLanguageFormatter(MultiFunction, CppFormatterRulesCollection):
    """FFC specific cpp formatter class."""
    def __init__(self, dependency_handler, form_argument_mapping, ir, num_points, cell):
        MultiFunction.__init__(self)
        CppFormatterRulesCollection.__init__(self)

        # An object used to track who depends on what
        self._dependency_handler = dependency_handler

        # A FormArgument:FormArgument mapping to override
        # counts and elements of functions without rebuilding integrand
        self._form_argument_mapping = form_argument_mapping

        # The rest of the FFC representation dict, flexible way to work for now,
        # maybe replace with whatever we need more specifically later
        self._ir = ir

        self._cell = cell

        # FIXME: Handle different quadrature rules!
        self._num_points = num_points

    def geometric_quantity(self, o, component=(), derivatives=(), restriction=None):
        "Generic rendering of variable names for all piecewise constant geometric quantities."
        uflacs_assert(not derivatives,
                      "Compiler should be able to simplify derivatives of geometry.")

        # Simply using the UFL str to define the name in the generated code, ensures consistency
        name = str(o)
        if restriction:
            name = name + restriction

        # Indexing if there is a shape
        sh = o.shape()
        if sh:
            uflacs_assert(component, "Missing component for nonscalar %r." % o)
            code = "%s[%d]" % (name, flatten_component(component, sh, None))
        else:
            uflacs_assert(component == (), "Component specified for scalar %r." % o)
            code = name

        # Make a record of dependency
        self._dependency_handler.require(o, component, derivatives, restriction, code)

        return code

    def facet_area(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(restriction is None, "Assuming facet_area is not restricted.")
        return self.geometric_quantity(o, component, derivatives, restriction)

    def _piecewise_constant_coefficient(self, o, component, derivatives, restriction):
        uflacs_assert(not derivatives,
                      "Not expecting derivatives of constant coefficients!")
        # Map component to flat index
        comp = flatten_component(component, o.shape(), o.element().symmetry())
        # Offset index if on second cell in interior facet integral
        if restriction == "+":
            comp += component_value_size(o.shape(), o.element().symmetry())
        # Return direct reference to dof array
        return "w[%d][%d]" % (o.count(), comp)

    def _computed_form_argument_name(self, o, component, derivatives, restriction, basename):
        # Change format of derivatives tuple, counting instead of enumerating
        gdim = self._cell.geometric_dimension()
        derivs = [0]*gdim
        for d in derivatives: # TODO: Utility function?
            derivs[d] += 1

        # Format base coefficient (derivative) name
        code = "%s%d" % (basename, o.count())
        if derivatives:
            code += "_d%s" % ''.join(map(str,derivs))

        if o.shape():
            # Map component to flat index
            comp = flatten_component(component, o.shape(), o.element().symmetry())
            # Offset index if on second cell in interior facet integral
            if restriction == "+":
                comp += component_value_size(o.shape(), o.element().symmetry())

            code += "_c%d" % comp

        return code

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        o = self._form_argument_mapping.get(o, o)
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        if o.is_cellwise_constant():
            return self._piecewise_constant_coefficient(o, component, derivatives, restriction)
        else:
            # FIXME: Generate code to compute this in statement formatter!
            code = self._computed_form_argument_name(o, component, derivatives, restriction, "w")
            self._dependency_handler.require(o, component, derivatives, restriction, code)
            return code

    def _element_table_access(self, component, derivatives, restriction, element, idof):
        # FIXME: Make reusable functions for formatting names
        iqname = "iq"

        # FIXME: This works for cell only, need to work around fixed table name per entity to avoid duplicate code for each facet!
        entity = None

        # Change format of derivatives tuple, counting instead of enumerating
        gdim = self._cell.geometric_dimension()
        derivs = [0]*gdim
        for d in derivatives: # TODO: Utility function?
            derivs[d] += 1

        # Get ffc table name for element values
        ir = self._ir
        element_number = ir["element_map"][self._num_points][element]
        element_table_name = _generate_psi_name(element_number, ir["entitytype"], entity, component, derivs)
        unique_table_name = ir["name_map"][element_table_name][0] # TODO: Right?

        # Format direct access to table values
        code = "%s[%s][%s]" % (unique_table_name, iqname, idof)
        return code

    def argument(self, o, component=(), derivatives=(), restriction=None):
        o = self._form_argument_mapping.get(o, o)
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        if derivatives:
            # FIXME: Generate code to compute this in statement formatter!
            code = self._computed_form_argument_name(o, component, derivatives, restriction, "v")
        else:
            iname = "i%d" % o.count() # FIXME: Make reusable functions for formatting names
            # No need to store basis function value in its own variable, just get table value directly
            code = self._element_table_access(component, derivatives, restriction, o.element(), iname)

        self._dependency_handler.require(o, component, derivatives, restriction, code)
        return code
