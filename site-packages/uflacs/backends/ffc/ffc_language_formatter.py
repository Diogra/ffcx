import numpy

from ufl.common import component_to_index
from ufl.permutation import build_component_numbering
from ufl.algorithms import MultiFunction

from uflacs.utils.assertions import uflacs_assert
from uflacs.utils.log import warning, error

from uflacs.codeutils.cpp_format import CppFormatterRulesCollection

from uflacs.codeutils.dependency_handler import DependencyHandler

# TODO: These should probably be in some utility collection instead
from .ffc_statement_formatter import get_element_table_data, derivatives_listing_to_counting, names, fmt_access, fmt_access2


class FFCLanguageFormatter(MultiFunction, CppFormatterRulesCollection):
    """FFC specific cpp formatter class."""
    def __init__(self, dependency_handler, ir):
        MultiFunction.__init__(self)
        CppFormatterRulesCollection.__init__(self)

        # An object used to track who depends on what
        self._dependency_handler = dependency_handler

        # The rest of the FFC representation dict, flexible way to work for now,
        # maybe replace with whatever we need more specifically later
        self._ir = ir

        self._cell = ir["cell"]

        # HACK! FIXME: Handle different quadrature rules!
        self._num_points, = ir["quadrature_weights"].keys()

        self._using_names = set()
        self._includes = set(("#include <cstring>",
                              "#include <cmath>"))

    def add_using(self, name):
        self._using_names.add(name)

    def add_include(self, name):
        self._includes.add(name)

    def get_using_statements(self):
        return ["using %s;" % name for name in sorted(self._using_names)]

    def get_includes(self):
        return sorted(self._includes)

    def geometric_quantity(self, o, component=(), derivatives=(), restriction=None):
        "Generic rendering of variable names for all piecewise constant geometric quantities."
        uflacs_assert(not derivatives,
                      "Compiler should be able to simplify derivatives of geometry.")

        # Simply using the UFL str to define the name in the generated code, ensures consistency
        name = str(o)
        if restriction:
            name = name + restriction

        # Indexing if there is a shape
        sh = o.shape()
        if sh:
            uflacs_assert(component, "Missing component for nonscalar %r." % o)
            code = fmt_access % (name, component_to_index(component, sh))
        else:
            uflacs_assert(component == (), "Component specified for scalar %r." % o)
            code = name

        # Make a record of dependency
        self._dependency_handler.require(o, component, derivatives, restriction, code)

        return code

    def facet_area(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(restriction is None, "Assuming facet_area is not restricted.")
        return self.geometric_quantity(o, component, derivatives, restriction)

    def _piecewise_constant_coefficient(self, o, component, derivatives, restriction):
        uflacs_assert(not derivatives,
                      "Not expecting derivatives of constant coefficients!")

        # Map component to flat index
        vi2si, si2vi = build_component_numbering(o.shape(), o.element().symmetry())
        comp = vi2si[component]
        size = len(si2vi)

        # Offset index if on second cell in interior facet integral
        if restriction == "-":
            comp += size

        # Return direct reference to dof array
        return fmt_access2 % (names.w, o.count(), comp)

    def _computed_form_argument_name(self, o, component, derivatives, restriction, basename):
        # Format base coefficient (derivative) name
        code = "%s%d" % (basename, o.count())
        if derivatives:
            # Change format of derivatives tuple, counting instead of enumerating
            gdim = self._cell.geometric_dimension()
            derivs = derivatives_listing_to_counting(derivatives, gdim)
            # Add derivatives to name
            code += "_d%s" % ''.join(map(str,derivs))

        if o.shape():
            # Map component to flat index
            vi2si, si2vi = build_component_numbering(o.shape(), o.element().symmetry())
            comp = vi2si[component]

            # Add component to name
            code += "_c%d" % comp

        # Add restriction to name
        code += names.restriction_postfix[restriction]

        return code

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        dh = self._dependency_handler

        o = dh.form_argument_mapping.get(o, o)
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        if o.is_cellwise_constant():
            return self._piecewise_constant_coefficient(o, component, derivatives, restriction)
        else:
            code = self._computed_form_argument_name(o, component, derivatives, restriction, names.wbase)
            dh.require(o, component, derivatives, restriction, code)
            return code

    def argument(self, o, component=(), derivatives=(), restriction=None):
        dh = self._dependency_handler

        o = dh.form_argument_mapping[o]
        uflacs_assert(o.count() >= 0,
            "Expecting positive count, provide a renumbered form argument mapping.")

        entity = None # FIXME ENTITY

        if derivatives:
            code = self._computed_form_argument_name(o, component, derivatives, restriction, names.vbase)
            dh.require(o, component, derivatives, restriction, code)
        else:
            element = o.element()

            # Flatten component
            sh = o.shape()
            if sh:
                # Map component to flat index
                vi2si, si2vi = build_component_numbering(sh, element.symmetry())
                comp = vi2si[component]
            else:
                comp = component

            # No need to store basis function value in its own variable, just get table value directly
            unique_table_name, non_zeros, zeros, ones = \
              get_element_table_data(self._ir, self._num_points, element, entity,
                                     comp, derivatives)

            # Format direct access to table values
            idof = "%s%d" % (names.ia, o.count()) # FIXME: Make reusable function
            code = fmt_access2 % (unique_table_name, names.iq, idof)

        return code
