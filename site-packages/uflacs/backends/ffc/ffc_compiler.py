
# TODO: Attach form_data.cell to target_formatter for geometry generation?
# TODO: Attach data from ffc to target_formatter for element generation?
# TODO: Move integrate to be a target_formatter property?

from ufl.common import product
from ufl.classes import Argument, FormArgument
from ufl.algorithms import extract_elements

from uflacs.utils.assertions import uflacs_assert

from uflacs.codeutils.dependency_handler import DependencyHandler

from uflacs.algorithms.compiler import (compile_expression_partitions,
                                        generate_code_from_ssa,
                                        generate_expression_body)
from uflacs.backends.toy.toy_compiler import generate_expression_code

from uflacs.algorithms.table_utils import (generate_psi_table_name, get_ffc_table_values,
                                           strip_table_zeros, build_unique_tables)
from uflacs.codeutils.format_code_structure import format_code_structure, Indented, ArrayDecl

from uflacs.backends.ffc.ffc_language_formatter import FFCLanguageFormatter
from uflacs.backends.ffc.ffc_statement_formatter import FFCStatementFormatter

from uflacs.algorithms.table_utils import derivative_listing_to_counts, flatten_component

def compute_tabulate_tensor_ir(ir,
                               integrals_dict,
                               form_data,
                               parameters):
    # These are already inserted by ffc representation code:
    #ir["domain_type"]
    #ir["quadrature_weights"] = { num_points: (w, (x,y)) }

    ir["function_replace_map"] = form_data.function_replace_map
    ir["object_names"] = {} #form_data.object_names # TODO
    ir["cell"] = form_data.cell

    # TODO: Handle multiple integration rules everywhere
    all_num_points = sorted(integrals_dict)
    uflacs_assert(len(all_num_points) == 1,
                  "Assuming a single quadrature rule per integral domain for now.")
    ir["all_num_points"] = all_num_points # Temporary

    # Loop over integrals for each integration rule
    #ir["body_ir"] = {}
    for num_points in all_num_points:
        integrand = integrals_dict[num_points].integrand()
        body_ir = compile_expression_partitions(integrand, ir["function_replace_map"])
        #ir["body_ir"][num_points] = body_ir # TODO: Like this?
        ir.update(body_ir) # For now, single rule only

    # FIXME: Build num_points/element to counter mapping
    element_counter_map = {}
    for num_points in all_num_points:
        element_counter_map[num_points] = {}
        ecm = element_counter_map[num_points]

        integrand = integrals_dict[num_points].integrand()
        elements = extract_elements(integrand)

        for element in elements:
            if element not in ecm:
                ecm[element] = len(ecm)
    ir["element_map"] = element_counter_map

    return ir


def optimize_tabulate_tensor_ir(ir, parameters):
    # TODO: Implement some optimization here!
    oir = ir
    return oir


def generate_tabulate_tensor_code(ir, parameters):
    # Create an object to track dependencies across other components
    dependency_handler = DependencyHandler(ir["terminals"], ir["cell"], ir["function_replace_map"], ir["object_names"])

    # ----------------------------------------
    # ... FIXME: Extract table generation into function:

    # Analyse the psi_tables that are required by functions etc.
    psi_tables = ir["psi_tables"]
    entitytype = ir["entitytype"]
    element_counter_map = ir["element_map"]
    num_points, = ir["all_num_points"] # Assuming a single num_points value
    tables = {}
    for t, c, d, r in dependency_handler.terminal_data:
        if isinstance(t, FormArgument):
            element = t.element()
            element_counter = element_counter_map[num_points][element]

            # Change derivatives format for table lookup
            gdim = element.cell().geometric_dimension()
            derivatives = tuple(derivative_listing_to_counts(d, gdim))

            # Flatten component
            flat_component = flatten_component(c, t.shape(), element.symmetry())

            # Get name and values for this particular table
            name = generate_psi_table_name(element_counter, flat_component,
                                         derivatives, entitytype)
            table = get_ffc_table_values(psi_tables, entitytype, num_points,
                                         element, flat_component, derivatives)
            tables[name] = table

    # Apply zero stripping to all tables
    stripped_tables = {}
    table_ranges = {}
    for name, table in tables.iteritems():
        begin, end, table = strip_table_zeros(table)
        stripped_tables[name] = table
        table_ranges[name] = (begin, end)

    # Build unique table mapping
    def unique_table_name(i):
        return "table%d" % i # FIXME: Unique table naming?
    unique_tables, table_mapping = build_unique_tables(stripped_tables)

    table_ranges2 = {}
    for name in sorted(table_mapping.keys()):
        ui = table_mapping[name]
        uname = unique_table_name(ui)
        b, e = table_ranges[name]
        table_ranges2[name] = (uname, b, e)
    ir["table_ranges"] = table_ranges2

    # Format unique tables into code
    tables_code = [ArrayDecl("static const double", unique_table_name(i),
                             table.shape, table)
                   for i, table in enumerate(unique_tables)
                   if product(table.shape) > 0]

    # ----------------------------------------
    #tables_code,  =

    # Create backend specific plugin objects
    language_formatter = FFCLanguageFormatter(dependency_handler, ir)
    statement_formatter = FFCStatementFormatter(dependency_handler, ir)

    # Generate code partitions from ir
    body_ir = ir # For now, may get one of these for each num_points?
    partition_codes, final_variable_names = generate_code_from_ssa(body_ir, language_formatter)

    # Generate full code from snippets
    expression_body = generate_expression_body(statement_formatter,
                                               partition_codes,
                                               final_variable_names,
                                               ir["num_registers"])

    # Format uflacs specific code structures into a single
    # string and place in dict before returning to ffc
    body = format_code_structure(Indented([language_formatter.get_using_statements(),
                                           tables_code, expression_body]))
    code = {
        "tabulate_tensor": body,
        "additional_includes_set": language_formatter.get_includes(),
        }
    return code

def compile_tabulate_tensor_code(form, optimize=True):
    "Compile_code is a joining of compute_ir, optimize_ir, and generate_ir, for testing."
    from ffc.cpp import set_float_formatting
    from ffc.uflacsrepr import compute_integral_ir, optimize_integral_ir, generate_integral_code

    # Fake the initialization necessary to get this running through
    set_float_formatting(8)
    parameters = { "optimize": optimize }
    prefix = "uflacs_testing"
    form_id = 0

    # Apply ufl preprocessing
    form_data = form.compute_form_data()

    tt_codes = []
    for itg_data in form_data.integral_data:
        # Just make a fixed choice of cubic default quadrature rule
        itg_data.metadata["quadrature_degree"] = itg_data.metadata.get("quadrature_degree", 3)
        itg_data.metadata["quadrature_rule"] = itg_data.metadata.get("quadrature_rule", "default")

        # Call uflacs representation functions from ffc, which again calls the matching uflacs functions
        ir = compute_integral_ir(itg_data, form_data, form_id, parameters)
        if optimize:
            ir = optimize_integral_ir(ir, parameters)
        code = generate_integral_code(ir, prefix, parameters)

        # Store just the tabulate tensor part generated by uflacs
        tt_codes.append(code["tabulate_tensor"])

    # Just joint the tabulate tensor bodies and return
    code = ('\n' + '/'*60 + '\n').join(tt_codes)
    return code
