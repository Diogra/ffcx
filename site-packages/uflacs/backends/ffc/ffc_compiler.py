
# TODO: Attach form_data.cell to target_formatter for geometry generation?
# TODO: Attach data from ffc to target_formatter for element generation?
# TODO: Move integrate to be a target_formatter property?

from ufl.classes import Argument, FormArgument
from ufl.algorithms import extract_elements

from uflacs.utils.assertions import uflacs_assert

from uflacs.codeutils.dependency_handler import DependencyHandler

from uflacs.algorithms.compiler import compute_expression_body_ir
from uflacs.algorithms.compiler import generate_expression_body_code

from uflacs.algorithms.table_utils import (generate_psi_table_name, get_ffc_table_values,
                                           strip_table_zeros, build_unique_tables)
from uflacs.codeutils.format_code_structure import format_code_structure, Indented, ArrayDecl

from uflacs.backends.ffc.ffc_language_formatter import FFCLanguageFormatter
from uflacs.backends.ffc.ffc_statement_formatter import FFCStatementFormatter

def compute_tabulate_tensor_ir(ir,
                               integrals_dict,
                               form_data,
                               parameters):
    # These are already inserted by ffc representation code:
    #ir["domain_type"]
    #ir["quadrature_weights"] = { num_points: (w, (x,y)) }

    # Build mapping for just arguments
    argument_mapping = dict((k,v) for (k,v) in
                            form_data.function_replace_map.items()
                            if isinstance(k, Argument))
    assert len(argument_mapping) == form_data.rank

    ir["function_replace_map"] = form_data.function_replace_map
    ir["object_names"] = {} #form_data.object_names # TODO
    ir["cell"] = form_data.cell

    # TODO: Handle multiple integration rules everywhere
    all_num_points = sorted(integrals_dict)
    uflacs_assert(len(all_num_points) == 1,
                  "Assuming a single quadrature rule per integral domain for now.")

    # Loop over integrals for each integration rule
    #ir["body_ir"] = {}
    for num_points in all_num_points:
        integrand = integrals_dict[num_points].integrand()
        body_ir = compute_expression_body_ir(integrand, argument_mapping)
        #ir["body_ir"][num_points] = body_ir # TODO: Like this?
        ir.update(body_ir) # For now, single rule only

    # FIXME: Build num_points/element to counter mapping
    element_counter_map = {}
    for num_points in all_num_points:
        element_counter_map[num_points] = {}
        ecm = element_counter_map[num_points]

        integrand = integrals_dict[num_points].integrand()
        elements = extract_elements(integrand)

        for element in elements:
            if element not in ecm:
                ecm[element] = len(ecm)
    ir["element_map"] = element_counter_map

    return ir


def optimize_tabulate_tensor_ir(ir, parameters):
    # TODO: Implement some optimization here!
    oir = ir
    return oir


def generate_tabulate_tensor_code(ir, parameters):
    dependency_handler = DependencyHandler(ir["object_names"], ir["function_replace_map"])
    # Pass set of needed terminal expressions to the dependency handler
    dependency_handler.update_terminals(ir["terminals"]) # FIXME: Pass to init?

    # Create backend specific plugin objects
    language_formatter = FFCLanguageFormatter(dependency_handler, ir)
    statement_formatter = FFCStatementFormatter(dependency_handler, ir)

    # FIXME: Must build required set before generating tables,
    #        which must happen before generating expression body code,
    #        in other words we need to build the required set in the ir phase!
    #        OR build required set without considering components first,
    #        and only generate the tables we actually used at the end.

    # Analyse the psi_tables that are required by functions etc.
    psi_tables = ir["psi_tables"]
    entitytype = ir["entitytype"]
    element_counter_map = ir["element_map"]
    tables = {}
    for t, reqdata in dependency_handler.required.iteritems():
        if isinstance(t, FormArgument):
            element = t.element()
            element_counter = element_counter_map[num_points][element]

            for (component, derivatives, restriction) in sorted(reqdata):
                name = generate_psi_table_name(element_counter, component,
                                             derivatives, entitytype)
                table = get_ffc_table_values(psi_tables, entitytype, num_points,
                                             element, component, derivatives)
                tables[name] = table

    # Apply zero stripping to all tables
    tables2 = {}
    for name, table in tables.iteritems():
        begin, end, table = strip_table_zeros(table)
        tables2[name] = (table, begin, end)

    # Build unique table mapping
    def unique_table_name(i):
        return "table%d" % i # FIXME: Unique table naming?
    unique_tables, table_mapping = build_unique_tables(tables2)
    ir["name_map"] = dict((k, unique_table_name(table_mapping[k]))
                          for k in table_mapping)

    # Format unique tables into code
    tables_code = [ArrayDecl("static const double", unique_table_name(i),
                             table.shape, table)
                   for i, table in enumerate(unique_tables)]

    # Use generic compiler routine to compile expression body
    expression_body = generate_expression_body_code(ir, language_formatter,
                                                    statement_formatter)

    # Format uflacs specific code structures into a single
    # string and place in dict before returning to ffc
    body = format_code_structure(Indented([language_formatter.get_using_statements(),
                                           tables_code, expression_body]))
    code = {
        "tabulate_tensor": body,
        "additional_includes_set": language_formatter.get_includes(),
        }
    return code

def compile_tabulate_tensor_code(form, optimize=True):
    "Compile_code is a joining of compute_ir, optimize_ir, and generate_ir, for testing."
    from ffc.cpp import set_float_formatting
    from ffc.uflacsrepr import compute_integral_ir, optimize_integral_ir, generate_integral_code

    # Fake the initialization necessary to get this running through
    set_float_formatting(8)
    parameters = { "optimize": optimize }
    prefix = "uflacs_testing"
    form_id = 0

    # Apply ufl preprocessing
    form_data = form.compute_form_data()

    tt_codes = []
    for itg_data in form_data.integral_data:
        # Just make a fixed choice of cubic default quadrature rule
        itg_data.metadata["quadrature_degree"] = itg_data.metadata.get("quadrature_degree", 3)
        itg_data.metadata["quadrature_rule"] = itg_data.metadata.get("quadrature_rule", "default")

        # Call uflacs representation functions from ffc, which again calls the matching uflacs functions
        ir = compute_integral_ir(itg_data, form_data, form_id, parameters)
        if optimize:
            ir = optimize_integral_ir(ir, parameters)
        code = generate_integral_code(ir, prefix, parameters)

        # Store just the tabulate tensor part generated by uflacs
        tt_codes.append(code["tabulate_tensor"])

    # Just joint the tabulate tensor bodies and return
    code = ('\n' + '/'*60 + '\n').join(tt_codes)
    return code
