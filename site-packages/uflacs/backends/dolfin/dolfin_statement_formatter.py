
from ufl.common import product
from ufl.common import component_to_index
from ufl.permutation import build_component_numbering
from ufl.classes import (Coefficient, SpatialCoordinate,
                         FacetNormal, FacetArea,
                         CellVolume, CellSurfaceArea, Circumradius)

from uflacs.utils.assertions import uflacs_assert

from uflacs.codeutils.dependency_handler import DependencyHandler, analyse_terminalish # FIXME

class DolfinExpressionStatementFormatter(object):
    def __init__(self, dependency_handler, cell):
        self._dependency_handler = dependency_handler
        self._cell = cell

        # Configuration options for statement formatting
        self._output_basename = "values"

    def define_registers(self, num_registers):
        return ['double s[%d];' % num_registers]

    def define_piecewise_geometry(self):
        # FIXME: Compute piecewise constant geometry and coeffs in DG0 and R.
        code = []
        for o in self._dependency_handler.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, (FacetNormal, FacetArea)):
                code += ["// Facet unknown in Expression eval: %s" % repr(t)]
            elif isinstance(t, (CellVolume, CellSurfaceArea, FacetArea, Circumradius)):
                code += ["// Cell unknown in Expression eval: %s" % repr(t)]
        return code

    def define_piecewise_coefficients(self):
        # FIXME: Compute coeffs in DG0 and R.
        code = []
        for o in self._dependency_handler.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient) and t.is_cellwise_constant():
                uflacs_assert(not ngrads,
                              "grad(constant) should be removed at "\
                              "earlier stage by compiler.")
                uflacs_assert(r == "", "Restrictions not supported.")

                basename = self._dependency_handler.coefficient_names[t]
                der = "d%d_" % ngrads if ngrads else "v_"
                name = "%s%s%s" % (der, basename, r)
                n = product(o.shape())
                tdecl = "Array<double> %s(%d);" % (name, n)
                teval = "%s->eval(%s, x);" % (basename, name)

                code += [tdecl, teval]
        return code

    def define_coord_loop(self):
        # When evaluating expressions in a point, there is no coordinate loop
        return None

    def define_coord_vars(self):
        # Since x is an input argument to Expression, nothing to do here.
        return []

    def define_coord_dependent_geometry(self):
        # No coordinate dependent geometry supported here.
        return []

    def define_coord_dependent_coefficients(self):
        # FIXME: Compute x dependent coefficients.
        code = []
        for o in self._dependency_handler.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient) and not t.is_cellwise_constant():
                uflacs_assert(r == "", "Restrictions not supported.")

                basename = self._dependency_handler.coefficient_names[t]
                der = "d%d_" % ngrads if ngrads else "v_"
                name = "%s%s%s" % (der, basename, r)
                n = product(o.shape())
                tdecl = "Array<double> %s(%d);" % (name, n)

                if ngrads == 0:
                    teval = "%s->eval(%s, x);" % (basename, name)
                elif ngrads == 1:
                    teval = "%s->eval_derivatives(%s, x);" % (basename, name)
                else:
                    error("Higher order derivatives not supported.")

                code += [tdecl, teval]
        return code

    def define_argument_for_loop(self, argument_count):
        return None

    def define_argument_loop_vars(self, argument_count):
        return []

    def accumulation_scaling_factor(self):
        return None

    def define_output_variables_reset(self):
        return []

    def output_variable_names(self, num_variables):
        return ['%s[%d]' % (self._output_basename, i,) for i in xrange(num_variables)]

