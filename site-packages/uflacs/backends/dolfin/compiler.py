
from ufl.classes import Terminal, Indexed, SpatialDerivative
from ufl.algorithms import Graph, preprocess_expression
from uflacs.codeutils.cpp_format import CppFormatterRules
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.format_code_structure import (format_code_structure,
                                                    Block, Indented, Namespace, Class)
from uflacs.codeutils.element_tensor_formatter import (build_loops, format_assignments,
                                                       format_additions)
from uflacs.backends.dolfin.dolfin_target_formatter import DolfinExpressionFormatter
from uflacs.backends.dolfin.expression import format_dolfin_expression
from uflacs.backends.cpp2.compiler import compile_expression_partitions

def compile_expression_lines(expr, target_formatter):
    # FIXME: Implement this, dolfin-independent! Adapt cpp2 compiler code.
    return []

def compile_dolfin_expression_body(expr, object_names=None):
    if object_names is None:
        object_names = {}

    integrate = False

    # Construct a dolfin C++ expression formatter
    target_formatter = DolfinExpressionFormatter(object_names) # DOLFIN SPECIFIC

    # Compile expression into partitioned code listings
    partition_codes, final_variable_names, num_registers = \
                     compile_expression_partitions(expr, target_formatter)

    # Join partitions with target specific loops and declarations
    req = target_formatter.required
    term = target_formatter.terminals
    partition_codes = dict(partition_codes)

    # Build loop structure (this is not really necessary
    # for expression, but intended for tabulate_tensor)
    loops = []
    definitions = []
    partitions = []

    # TODO: This partition numbering is maybe too "magic"
    # --- Partition 0: independent of x and arguments.
    p = 0
    piecewise_defs = []
    if num_registers:
        piecewise_defs += ['double s[%d];' % (num_registers,)]
    piecewise_defs += target_formatter.piecewise_geometry_definitions()
    piecewise_defs += target_formatter.piecewise_coefficient_definitions()

    loops += [None]
    definitions += [piecewise_defs]
    partitions += [partition_codes.get(p,"")]
    if p in partition_codes: del partition_codes[p]

    # --- Partition 1: x dependency
    p = 1
    x_dependent_defs = []
    if integrate:
        quadrature_for_loop = "for (int iq=0; iq<num_quadrature_points; ++iq)"
        x_dependent_defs += ["double x[3] = { quadpoints[iq][0], ... };"]
    else:
        quadrature_for_loop = None
        x_dependent_defs += []
    x_dependent_defs += target_formatter.x_dependent_geometry_definitions()

    loops += [quadrature_for_loop]
    definitions += [x_dependent_defs]
    partitions += [partition_codes.get(p,"")]
    if p in partition_codes: del partition_codes[p]

    # --- Partition 2: x and coefficient dependency
    p = 2
    w_dependent_defs = []
    w_dependent_defs += target_formatter.x_dependent_coefficient_definitions()

    loops += [None]
    definitions += [w_dependent_defs]
    partitions += [partition_codes.get(p,"")]
    if p in partition_codes: del partition_codes[p]

    # --- Partition 3: trial function dependency
    # TODO: Add loops and definitions and code here
    # --- Partition 4: test function dependency (or the other way around)
    # TODO: Add loops and definitions and code here
    # TODO: In default_partition_seed, there is no distinction between test/trial.

    # --- Final partition: final assignments
    p = 5
    assign_to_variables = ['values[%d]' % (i,)\
                           for i in xrange(len(final_variable_names))] # DOLFIN SPECIFIC
    # TODO: Use format_additions instead for tabulate_tensor!
    assignments = list(format_assignments(zip(assign_to_variables,
                                              final_variable_names)))

    loops += [None]
    definitions += [assignments]
    partitions += [""]

    # Should be nothing left now
    if partition_codes:
        print '------------------- partition_codes:'
        print partition_codes
        print '-------------------'
    assert not partition_codes

    # Stitch it together
    code = build_loops(loops, definitions, partitions)

    # Get member function names TODO: Distinguish types of functions?
    member_names = dict(constants=[],
                        mesh_functions=[],
                        generic_functions=list(target_formatter.coefficient_names.values()),
                        functions=[],
                        )

    return code, member_names

def compile_dolfin_expression_class(expr, name, object_names):
    classname = 'UflacsExpression_%s' % name
    shape = expr.shape()

    eval_body, member_names = compile_dolfin_expression_body(expr, object_names)

    # Stitch together the full class
    code = format_dolfin_expression(classname=classname,
                                    shape=shape,
                                    eval_body=eval_body,
                                    **member_names)
    return code, classname

def format_uflacs_header(prefix, file_code):
    # Includes we're likely to need, no check for when they're not needed
    includes = ['#include <iostream>',
                '#include <cmath>',
                '#include <boost/shared_ptr.h>',
                '#include <dolfin.h>']

    # File guards
    define = 'UFLACS_' + prefix + '_INCLUDED'
    preguard = [('#ifndef ', define),
                ('#define ', define)]
    postguard = '#endif'

    # Stitch it together
    code = [preguard, '',
            includes, '',
            Namespace(prefix, file_code), '',
            postguard]
    return format_code_structure(code)

def compile_dolfin_expressions_header(expressions, object_names, prefix):
    # Generate code for each expression
    file_code = []
    classnames = []
    for k, expr in enumerate(expressions):
        name = object_names.get(id(expr), 'e%d' % k)
        code, classname = compile_dolfin_expression_class(expr, name, object_names)
        file_code.append(code)
        classnames.append(classname)

    # Wrap code from each file in its own namespace
    return format_uflacs_header(prefix, file_code)
