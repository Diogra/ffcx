
from ufl.common import product
from ufl.common import component_to_index
from ufl.permutation import build_component_numbering
from ufl.algorithms import MultiFunction

from uflacs.utils.assertions import uflacs_assert

from uflacs.codeutils.dependency_handler import DependencyHandler
from uflacs.codeutils.cpp_format import CppFormatterRulesCollection

class DolfinExpressionLanguageFormatter(MultiFunction, CppFormatterRulesCollection):
    def __init__(self, dependency_handler, form_argument_mapping):
        MultiFunction.__init__(self)
        CppFormatterRulesCollection.__init__(self)

        # An object used to track who depends on what
        self._dependency_handler = dependency_handler

        # A FormArgument:FormArgument mapping to override
        # counts and elements of functions without rebuilding integrand
        self._form_argument_mapping = form_argument_mapping

    def geometric_quantity(self, o, component=(), derivatives=(), restriction=None):
        "Generic rendering of variable names for all piecewise constant geometric quantities."
        uflacs_assert(not derivatives,
                      "Compiler should be able to simplify derivatives of geometry.")

        # Simply using the UFL str to define the name in the generated code, ensures consistency
        name = str(o)
        if restriction:
            name = name + restriction

        # Indexing if there is a shape
        sh = o.shape()
        if sh:
            uflacs_assert(component, "Missing component for nonscalar %r." % o)
            code = "%s[%d]" % (name, component_to_index(component, sh))
        else:
            uflacs_assert(component == (), "Component specified for scalar %r." % o)
            code = name

        # Make a record of dependency
        self._dependency_handler.require(o, component, derivatives, restriction, code)

        return code

    def facet_area(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(restriction is None, "Assuming facet_area is not restricted.")
        return self.geometric_quantity(o, component, derivatives, restriction)

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        return self.form_argument(o, component, derivatives, restriction,
                                  self._dependency_handler.coefficient_names[o])

    def argument(self, o, component=(), derivatives=(), restriction=None):
        #return self.form_argument(o, component, derivatives, restriction, self._dependency_handler.argument_names[o])
        raise NotImplementedError("Not expecting an Argument in dolfin expression formatter.")

    def form_argument(self, o, component, derivatives, restriction, base_name):
        o = self._form_argument_mapping.get(o, o)

        # FIXME: This probably needs some work, revisit when implementing
        #        actual generation of declarations of these quantities

        # FIXME: I think we need to flatten and combine component and derivatives.

        def indstring(indices):
            # FIXME: Indexing flat or nested in C++?
            if 1:
                return "".join("[%s]" % i for i in indices)
            else:
                return ("[%s]" % (", ".join(map(str,indices))))

        rcode = {None:"", "+": "_p", "-": "_m"}[restriction]

        if derivatives:
            dcodepre  = 'd%d_' % (len(derivatives),)
            dcodepost = indstring(derivatives)
        else:
            dcodepre = "v_"
            dcodepost = ""

        icode = indstring(component) if component else "[0]"

        code = dcodepre + base_name + rcode + icode + dcodepost

        self._dependency_handler.require(o, component, derivatives, restriction, code)
        return code
