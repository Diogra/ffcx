
from ufl.classes import (Terminal, Indexed, Grad, Restricted,
                         Coefficient, Argument,
                         SpatialCoordinate,
                         FacetNormal, FacetArea,
                         CellVolume, CellSurfaceArea, FacetArea, Circumradius)
from ufl.common import product
from uflacs.utils.assertions import uflacs_assert
from uflacs.codeutils.target_formatter import CppDefaultFormatter

def analyse_terminalish(o):
    t = o
    ngrads = 0
    r = ""
    while not isinstance(t, Terminal):
        if isinstance(t, Grad):
            t, = t.operands()
            ngrads += 1
        elif isinstance(t, PositiveRestricted):
            t, = t.operands()
            assert r == ""
            r = "+"
        elif isinstance(t, NegativeRestricted):
            t, = t.operands()
            assert r == ""
            r = "-"
        else:
            error("Unexpected %s." % t)
    return (t, ngrads, r)

def coefficient_is_piecewise_constant(t):
    assert isinstance(t, Coefficient)
    e = t.element()
    return (e.family() == "Real" or
            (e.family() == "Discontinuous Galerkin" and e.degree() == 0))

class DolfinExpressionFormatter(CppDefaultFormatter):
    """C++ formatter class for dolfin::Expression generation."""

    def __init__(self, object_names):
        CppDefaultFormatter.__init__(self)
        self.object_names = object_names
        self.argument_names = {}
        self.coefficient_names = {}

    def update_terminals(self, terminals):
        # Store terminals
        self.terminals = list(terminals)

        # Extract functions
        coefficients = set()
        arguments = set()
        for o in terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient):
                coefficients.add(t)
            elif isinstance(t, Argument):
                arguments.add(t)

        # Number and name functions:
        for i,c in enumerate(sorted(coefficients, key=lambda x: x.count())):
            self.coefficient_names[c] = self.object_names.get(id(c), "w%d"%i)
        for i,c in enumerate(sorted(arguments, key=lambda x: x.count())):
            self.argument_names[c] = self.object_names.get(id(c), "v%d"%i)

    # --- Functions for generating definitions code

    def piecewise_geometry_definitions(self):
        # FIXME: Compute piecewise constant geometry and coeffs in DG0 and R.
        code = []
        for o in self.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, (FacetNormal, FacetArea)):
                code += ["// Not implemented (facet unknown): %s" % repr(t)]
            elif isinstance(t, (CellVolume, CellSurfaceArea, FacetArea, Circumradius)):
                code += ["// Not implemented (cell unknown): %s" % repr(t)]
        return code

    def piecewise_coefficient_definitions(self):
        # FIXME: Compute coeffs in DG0 and R.
        code = []
        for o in self.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient) and coefficient_is_piecewise_constant(t):
                uflacs_assert(not ngrads,
                              "grad(constant) should be removed at "\
                              "earlier stage by compiler.")
                uflacs_assert(r == "", "Restrictions not supported.")

                basename = self.coefficient_names[t]
                der = "d%d_" % ngrads if ngrads else "v_"
                name = "%s%s%s" % (der, basename, r)
                n = product(o.shape())
                tdecl = "Array<double> %s(%d);" % (name, n)
                teval = "%s->eval(%s, x);" % (basename, name)

                code += [tdecl, teval]
        return code

    def x_dependent_geometry_definitions(self):
        # Compute x dependent geometry, if any.
        # Since x is an input argument to Expression, nothing to do here.
        # In tabulate_tensor, fetch x from quadrature point set.
        code = []
        #for o in self.terminals:
        #    (t, ngrads, r) = analyse_terminalish(o)
        #    if isinstance(t, SpatialCoordinate):
        #        pass
        return code

    def x_dependent_coefficient_definitions(self):
        # FIXME: Compute x dependent coefficients.
        code = []
        for o in self.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient) and not coefficient_is_piecewise_constant(t):
                uflacs_assert(r == "", "Restrictions not supported.")

                basename = self.coefficient_names[t]
                der = "d%d_" % ngrads if ngrads else "v_"
                name = "%s%s%s" % (der, basename, r)
                n = product(o.shape())
                tdecl = "Array<double> %s(%d);" % (name, n)

                if ngrads == 0:
                    teval = "%s->eval(%s, x);" % (basename, name)
                elif ngrads == 1:
                    teval = "%s->eval_derivatives(%s, x);" % (basename, name)
                else:
                    error("Higher order derivatives not supported.")

                code += [tdecl, teval]
        return code

    # --- Explicitly selecting rules for geometry here just for clarity:

    # x[0] etc.
    spatial_coordinate = CppDefaultFormatter.spatial_coordinate

    # n[0] etc.
    facet_normal = CppDefaultFormatter.facet_normal

    # K_vol
    cell_volume = CppDefaultFormatter.cell_volume

    # K_rad
    circumradius = CppDefaultFormatter.circumradius

    # K_surf
    cell_surface_area = CppDefaultFormatter.cell_surface_area

    # F_area
    facet_area = CppDefaultFormatter.facet_area

    # --- Rules for coefficients and arguments:

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        basename = self.coefficient_names.get(o, "w%d"%o.count())
        return self.form_argument(o, component, derivatives, restriction, basename)

    def argument(self, o, component=(), derivatives=(), restriction=None):
        basename = self.argument_names.get(o, "v%d"%o.count())
        return self.form_argument(o, component, derivatives, restriction, basename)

    def form_argument(self, o, component, derivatives, restriction, base_name):
        # FIXME: This probably needs some work, revisit when implementing
        #        actual generation of declarations of these quantities

        # FIXME: I think we need to flatten and combine component and derivatives.

        rcode = {None:"", "+": "_p", "-": "_m"}[restriction]

        def indstring(indices):
            # FIXME: Indexing flat or nested in C++?
            if 1:
                return "".join("[%s]" % i for i in indices)
            else:
                return ("[%s]" % (", ".join(map(str,indices))))

        if derivatives:
            dcodepre  = 'd%d_' % (len(derivatives),)
            dcodepost = indstring(derivatives)
        else:
            dcodepre = "v_"
            dcodepost = ""

        icode = indstring(component) if component else "[0]"

        code = dcodepre + base_name + rcode + icode + dcodepost

        self.require(o, component, derivatives, restriction, code)
        return code
