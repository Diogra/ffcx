
from ufl.classes import (Terminal, Indexed, Grad, Restricted,
                         Coefficient, Argument,
                         SpatialCoordinate,
                         FacetNormal, FacetArea,
                         CellVolume, CellSurfaceArea, FacetArea, Circumradius)
from ufl.common import product
from uflacs.utils.assertions import uflacs_assert
from uflacs.codeutils.target_formatter import (CppDefaultFormatter,
                                               analyse_terminalish,
                                               coefficient_is_piecewise_constant)

class DolfinExpressionFormatter(CppDefaultFormatter):
    """C++ formatter class for dolfin::Expression generation."""

    def __init__(self, object_names):
        CppDefaultFormatter.__init__(self, object_names)

        # Configuration options for statement formatting
        self._output_basename = "values"

    def update_terminals(self, terminals):
        CppDefaultFormatter.update_terminals(self, terminals)

    # --- Functions for generating definitions and other statements

    def define_registers(self, num_registers):
        return ['double s[%d];' % num_registers]

    def define_piecewise_geometry(self):
        # FIXME: Compute piecewise constant geometry and coeffs in DG0 and R.
        code = []
        for o in self.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, (FacetNormal, FacetArea)):
                code += ["// Facet unknown in Expression eval: %s" % repr(t)]
            elif isinstance(t, (CellVolume, CellSurfaceArea, FacetArea, Circumradius)):
                code += ["// Cell unknown in Expression eval" % repr(t)]
        return code

    def define_piecewise_coefficients(self):
        # FIXME: Compute coeffs in DG0 and R.
        code = []
        for o in self.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient) and coefficient_is_piecewise_constant(t):
                uflacs_assert(not ngrads,
                              "grad(constant) should be removed at "\
                              "earlier stage by compiler.")
                uflacs_assert(r == "", "Restrictions not supported.")

                basename = self.coefficient_names[t]
                der = "d%d_" % ngrads if ngrads else "v_"
                name = "%s%s%s" % (der, basename, r)
                n = product(o.shape())
                tdecl = "Array<double> %s(%d);" % (name, n)
                teval = "%s->eval(%s, x);" % (basename, name)

                code += [tdecl, teval]
        return code

    def define_quadrature_for_loop(self):
        # FIXME
        return "for (int iq=0; iq<num_quadrature_points; ++iq)"

    def define_quadrature_loop_vars(self):
        # FIXME
        return ["double x[3] = { quadpoints[iq][0], ... };"]

    def define_x_dependent_geometry(self):
        # Compute x dependent geometry, if any.
        # Since x is an input argument to Expression, nothing to do here.
        # In tabulate_tensor, fetch x from quadrature point set.
        code = []
        #for o in self.terminals:
        #    (t, ngrads, r) = analyse_terminalish(o)
        #    if isinstance(t, SpatialCoordinate):
        #        pass
        return code

    def define_x_dependent_coefficients(self):
        # FIXME: Compute x dependent coefficients.
        code = []
        for o in self.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient) and not coefficient_is_piecewise_constant(t):
                uflacs_assert(r == "", "Restrictions not supported.")

                basename = self.coefficient_names[t]
                der = "d%d_" % ngrads if ngrads else "v_"
                name = "%s%s%s" % (der, basename, r)
                n = product(o.shape())
                tdecl = "Array<double> %s(%d);" % (name, n)

                if ngrads == 0:
                    teval = "%s->eval(%s, x);" % (basename, name)
                elif ngrads == 1:
                    teval = "%s->eval_derivatives(%s, x);" % (basename, name)
                else:
                    error("Higher order derivatives not supported.")

                code += [tdecl, teval]
        return code

    def output_variable_names(self, num_variables):
        return ['%s[%d]' % (self._output_basename, i,) for i in xrange(num_variables)]

    # --- Explicitly selecting rules for geometry here just for clarity:

    # x[0] etc.
    spatial_coordinate = CppDefaultFormatter.spatial_coordinate

    # n[0] etc.
    facet_normal = CppDefaultFormatter.facet_normal

    # K_vol
    cell_volume = CppDefaultFormatter.cell_volume

    # K_rad
    circumradius = CppDefaultFormatter.circumradius

    # K_surf
    cell_surface_area = CppDefaultFormatter.cell_surface_area

    # F_area
    facet_area = CppDefaultFormatter.facet_area

    # --- Rules for coefficients and arguments:

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        return self.form_argument(o, component, derivatives, restriction,
                                  self.coefficient_names[o])

    def argument(self, o, component=(), derivatives=(), restriction=None):
        return self.form_argument(o, component, derivatives, restriction,
                                  self.argument_names[o])

    def form_argument(self, o, component, derivatives, restriction, base_name):
        # FIXME: This probably needs some work, revisit when implementing
        #        actual generation of declarations of these quantities

        # FIXME: I think we need to flatten and combine component and derivatives.

        rcode = {None:"", "+": "_p", "-": "_m"}[restriction]

        def indstring(indices):
            # FIXME: Indexing flat or nested in C++?
            if 1:
                return "".join("[%s]" % i for i in indices)
            else:
                return ("[%s]" % (", ".join(map(str,indices))))

        if derivatives:
            dcodepre  = 'd%d_' % (len(derivatives),)
            dcodepost = indstring(derivatives)
        else:
            dcodepre = "v_"
            dcodepost = ""

        icode = indstring(component) if component else "[0]"

        code = dcodepre + base_name + rcode + icode + dcodepost

        self.require(o, component, derivatives, restriction, code)
        return code
