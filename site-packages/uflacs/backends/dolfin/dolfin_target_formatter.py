
from ufl.classes import Terminal, Indexed, Grad, Restricted, Coefficient, Argument

from uflacs.codeutils.target_formatter import CppDefaultFormatter

class DolfinExpressionFormatter(CppDefaultFormatter):
    """C++ formatter class for dolfin::Expression generation."""

    def __init__(self, object_names):
        CppDefaultFormatter.__init__(self)
        self.object_names = object_names
        self.argument_names = {}
        self.coefficient_names = {}

    def update_terminals(self, terminals):
        # Store terminals
        self.terminals = list(terminals)

        # Extract functions
        coefficients = set()
        arguments = set()
        for o in terminals:
            t = o
            while not isinstance(t, Terminal):
                if isinstance(t, (Indexed,Grad,Restricted)):
                    t = t.operands()[0]
                else:
                    error("Unexpected %s." % t)
            if isinstance(t, Coefficient):
                coefficients.add(t)
            elif isinstance(t, Argument):
                arguments.add(t)

        # Renumber functions:
        for i,c in enumerate(sorted(coefficients, key=lambda x: x.count())):
            self.coefficient_names[c] = self.object_names.get(id(c), "w%d"%i)
        for i,c in enumerate(sorted(arguments, key=lambda x: x.count())):
            self.argument_names[c] = self.object_names.get(id(c), "v%d"%i)

    # --- Explicitly selecting rules for geometry here just for clarity:

    # x[0] etc.
    spatial_coordinate = CppDefaultFormatter.spatial_coordinate

    # n[0] etc.
    facet_normal = CppDefaultFormatter.facet_normal

    # K_vol
    cell_volume = CppDefaultFormatter.cell_volume

    # K_rad
    circumradius = CppDefaultFormatter.circumradius

    # K_surf
    cell_surface_area = CppDefaultFormatter.cell_surface_area

    # F_area
    facet_area = CppDefaultFormatter.facet_area

    # --- Rules for coefficients and arguments:

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        basename = self.coefficient_names.get(o, "w%d"%o.count())
        return self.form_argument(o, component, derivatives, restriction, basename)

    def argument(self, o, component=(), derivatives=(), restriction=None):
        basename = self.argument_names.get(o, "v%d"%o.count())
        return self.form_argument(o, component, derivatives, restriction, basename)

    def form_argument(self, o, component, derivatives, restriction, base_name):
        # FIXME: This probably needs some work, revisit when implementing
        #        actual generation of declarations of these quantities

        rcode = {None:"", "+": "_p", "-": "_m"}[restriction]

        def indstring(indices):
            # FIXME: Indexing flat or nested in C++?
            if 1:
                return "".join("[%s]" % i for i in indices)
            else:
                return ("[%s]" % (", ".join(map(str,indices))))

        if derivatives:
            dcodepre  = 'd%d_' % (len(derivatives),)
            dcodepost = indstring(derivatives)
        else:
            dcodepre, dcodepost = "", ""

        if component:
            icode = indstring(component)
        else:
            icode = ""

        code = dcodepre + base_name + rcode + icode + dcodepost

        self.require(o, component, derivatives, restriction, code)
        return code
