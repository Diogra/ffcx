
from ufl.classes import (Terminal, Indexed, Grad, Restricted,
                         Coefficient, Argument,
                         SpatialCoordinate,
                         FacetNormal, FacetArea,
                         CellVolume, CellSurfaceArea, FacetArea, Circumradius)
from ufl.common import product
from uflacs.utils.assertions import uflacs_assert
from uflacs.codeutils.target_formatter import analyse_terminalish
from uflacs.codeutils.target_formatter import (DependencyHandler,
                                               CppLanguageFormatter,
                                               CppStatementFormatter, flatten_component)


class DolfinExpressionStatementFormatter(CppStatementFormatter):
    def __init__(self, dependency_handler, cell):
        CppStatementFormatter.__init__(self, dependency_handler, cell)

        # Configuration options for statement formatting
        self._output_basename = "values"

    def define_registers(self, num_registers):
        return ['double s[%d];' % num_registers]

    def define_piecewise_geometry(self):
        # FIXME: Compute piecewise constant geometry and coeffs in DG0 and R.
        code = []
        for o in self._dependency_handler.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, (FacetNormal, FacetArea)):
                code += ["// Facet unknown in Expression eval: %s" % repr(t)]
            elif isinstance(t, (CellVolume, CellSurfaceArea, FacetArea, Circumradius)):
                code += ["// Cell unknown in Expression eval: %s" % repr(t)]
        return code

    def define_piecewise_coefficients(self):
        # FIXME: Compute coeffs in DG0 and R.
        code = []
        for o in self._dependency_handler.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient) and t.is_cellwise_constant():
                uflacs_assert(not ngrads,
                              "grad(constant) should be removed at "\
                              "earlier stage by compiler.")
                uflacs_assert(r == "", "Restrictions not supported.")

                basename = self._dependency_handler.coefficient_names[t]
                der = "d%d_" % ngrads if ngrads else "v_"
                name = "%s%s%s" % (der, basename, r)
                n = product(o.shape())
                tdecl = "Array<double> %s(%d);" % (name, n)
                teval = "%s->eval(%s, x);" % (basename, name)

                code += [tdecl, teval]
        return code

    def define_coord_loop(self):
        # When evaluating expressions in a point, there is no coordinate loop
        return None

    def define_coord_vars(self):
        # Since x is an input argument to Expression, nothing to do here.
        return []

    def define_coord_dependent_geometry(self):
        # No coordinate dependent geometry supported here.
        return []

    def define_coord_dependent_coefficients(self):
        # FIXME: Compute x dependent coefficients.
        code = []
        for o in self._dependency_handler.terminals:
            (t, ngrads, r) = analyse_terminalish(o)
            if isinstance(t, Coefficient) and not t.is_cellwise_constant():
                uflacs_assert(r == "", "Restrictions not supported.")

                basename = self._dependency_handler.coefficient_names[t]
                der = "d%d_" % ngrads if ngrads else "v_"
                name = "%s%s%s" % (der, basename, r)
                n = product(o.shape())
                tdecl = "Array<double> %s(%d);" % (name, n)

                if ngrads == 0:
                    teval = "%s->eval(%s, x);" % (basename, name)
                elif ngrads == 1:
                    teval = "%s->eval_derivatives(%s, x);" % (basename, name)
                else:
                    error("Higher order derivatives not supported.")

                code += [tdecl, teval]
        return code

    def define_argument_for_loop(self, argument_count):
        return None

    def define_argument_loop_vars(self, argument_count):
        return []

    def accumulation_scaling_factor(self):
        return None

    def define_output_variables_reset(self):
        return []

    def output_variable_names(self, num_variables):
        return ['%s[%d]' % (self._output_basename, i,) for i in xrange(num_variables)]


from ufl.algorithms import MultiFunction
from uflacs.codeutils.cpp_format import CppFormatterRulesCollection

class DolfinExpressionLanguageFormatter(MultiFunction, CppFormatterRulesCollection):
    def __init__(self, dependency_handler, form_argument_mapping):
        MultiFunction.__init__(self)
        CppFormatterRulesCollection.__init__(self)

        # An object used to track who depends on what
        self._dependency_handler = dependency_handler

        # A FormArgument:FormArgument mapping to override
        # counts and elements of functions without rebuilding integrand
        self._form_argument_mapping = form_argument_mapping

    def geometric_quantity(self, o, component=(), derivatives=(), restriction=None):
        "Generic rendering of variable names for all piecewise constant geometric quantities."
        uflacs_assert(not derivatives,
                      "Compiler should be able to simplify derivatives of geometry.")

        # Simply using the UFL str to define the name in the generated code, ensures consistency
        name = str(o)
        if restriction:
            name = name + restriction

        # Indexing if there is a shape
        sh = o.shape()
        if sh:
            uflacs_assert(component, "Missing component for nonscalar %r." % o)
            code = "%s[%d]" % (name, flatten_component(component, sh, None))
        else:
            uflacs_assert(component == (), "Component specified for scalar %r." % o)
            code = name

        # Make a record of dependency
        self._dependency_handler.require(o, component, derivatives, restriction, code)

        return code

    def facet_area(self, o, component=(), derivatives=(), restriction=None):
        uflacs_assert(restriction is None, "Assuming facet_area is not restricted.")
        return self.geometric_quantity(o, component, derivatives, restriction)

    def coefficient(self, o, component=(), derivatives=(), restriction=None):
        return self.form_argument(o, component, derivatives, restriction,
                                  self._dependency_handler.coefficient_names[o])

    def argument(self, o, component=(), derivatives=(), restriction=None):
        return self.form_argument(o, component, derivatives, restriction,
                                  self._dependency_handler.argument_names[o])

    def form_argument(self, o, component, derivatives, restriction, base_name):
        o = self._form_argument_mapping.get(o, o)

        # FIXME: This probably needs some work, revisit when implementing
        #        actual generation of declarations of these quantities

        # FIXME: I think we need to flatten and combine component and derivatives.

        def indstring(indices):
            # FIXME: Indexing flat or nested in C++?
            if 1:
                return "".join("[%s]" % i for i in indices)
            else:
                return ("[%s]" % (", ".join(map(str,indices))))

        rcode = {None:"", "+": "_p", "-": "_m"}[restriction]

        if derivatives:
            dcodepre  = 'd%d_' % (len(derivatives),)
            dcodepost = indstring(derivatives)
        else:
            dcodepre = "v_"
            dcodepost = ""

        icode = indstring(component) if component else "[0]"

        code = dcodepre + base_name + rcode + icode + dcodepost

        self._dependency_handler.require(o, component, derivatives, restriction, code)
        return code
