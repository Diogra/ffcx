#!/usr/bin/env python
"""
Tests of generic table manipulation utilities.
"""

from ufltestcase import UflTestCase
#from uflacs.codeutils.table_utils import *

import numpy as np

default_tolerance = 1e-14

def tables_equal(a, b, eps=default_tolerance):
    "Compare tables to be equal within a tolerance."
    a = np.asarray(a)
    b = np.asarray(b)
    if a.shape != b.shape:
        return False
    if len(a.shape) > 1:
        return all(tables_equal(a[i], b[i], eps) for i in range(a.shape[0]))
    def scalars_equal(x, y, eps):
        return abs(x-y) < eps
    return all(scalars_equal(a[i], b[i], eps) for i in range(a.shape[0]))

def strip_table_zeros(table, eps=default_tolerance):
    "Strip zero columns from table. Returns column range (begin,end) and the new compact table."
    # Get shape of table and number of columns, defined as the last axis
    table = np.asarray(table)
    sh = table.shape
    nc = sh[-1]

    # Find first nonzero column
    begin = nc
    for i in range(nc):
        if np.linalg.norm(table[...,i]) > eps:
            begin = i
            break

    # Find (one beyond) last nonzero column
    end = begin
    for i in range(nc-1,begin-1,-1):
        if np.linalg.norm(table[...,i]) > eps:
            end = i+1
            break

    # Make subtable by stripping first and last columns
    return begin, end, table[...,begin:end]

def build_unique_tables(tables):
    """Given an ordered list of tables, return a list of unique tables
    and a list of unique table indices for each input table."""
    unique = []
    mapping = [None]*len(tables)
    for j,t in enumerate(tables):
        found = -1
        for i,u in enumerate(unique):
            if tables_equal(u, t):
                found = i
                break
        if found == -1:
            i = len(unique)
            unique.append(t)
        mapping[j] = i
    return unique, mapping

def get_table_values(tables, entitytype, num_points, element, component, derivatives):
    """Extract values from ffc element table.

    Returns a 3D numpy array with axes
    (entity number, quadrature point number, dof number)
    """
    # Get quadrule/element subtable
    element_table = tables[num_points][element]

    # Figure out shape of final array by inspecting tables
    num_entities = len(element_table)
    num_dofs = len(element_table[list(element_table.keys())[0]][derivatives])

    # Make 3D array for final result
    shape = (num_entities, num_points, num_dofs)
    res = np.zeros(shape)

    # Loop over entities and fill table blockwise (each block = points x dofs)
    sh = element.value_shape()
    for entity in range(num_entities):
        # Access subtable
        entity_key = None if entitytype == "cell" else entity
        tbl = element_table[entity_key][derivatives]

        # Extract array for right component and order axes as (points, dofs)
        if sh == ():
            arr = np.transpose(tbl)
        else:
            arr = np.transpose(tbl[:,component,:])

        # Assign block of values for this entity
        res[entity, :, :] = arr
    return res


def _analyze(table):

    begin, end, table = strip_table_zeros(table)
    all_zeros = table.shape[-1] == 0
    all_ones = tables_equal(table, np.ones(table.shape))

class TableUtilsTest(UflTestCase):

    def assertTablesEqual(self, a, b, eps=default_tolerance):
        self.assertEqual(np.shape(a), np.shape(b))
        self.assertTrue(tables_equal(a, b, eps))

    def assertNotTablesEqual(self, a, b, eps=default_tolerance):
        self.assertFalse(tables_equal(a, b, eps))

    def test_get_table_values(self):
        entitytype = "cell"
        num_points = 1
        class MockElement:
            def value_shape(self): return ()
        element = MockElement()
        component = ()
        derivatives = ()

        num_dofs = 3
        arr = np.ones((num_dofs, num_points))

        ffc_tables = {
            num_points: {
                element: {
                    None: {
                        derivatives: arr
                    }
                }
            }
        }
        table = get_table_values(ffc_tables, entitytype, num_points, element, component, derivatives)
        self.assertTablesEqual(table[0,...], np.transpose(arr))

    def test_tables_equal(self):
        a = np.zeros((2,3))
        b = np.zeros((2,3))
        self.assertTablesEqual(a, b)

        a = np.ones((2,3))
        b = np.zeros((2,3))
        self.assertNotTablesEqual(a, b)

        a = np.ones((2,3))
        b = np.ones((3,2))
        self.assertNotTablesEqual(a, b)

        a = np.ones((2,3))*1.1
        b = np.ones((2,3))
        self.assertNotTablesEqual(a, b)

        # Checking for all ones within given tolerance:
        a = np.ones((2,3))*(1.0+1e-4)
        self.assertTablesEqual(a, np.ones(a.shape), eps=1e-3)

    def test_strip_table_zeros(self):
        # Can strip entire table:
        a = np.zeros((2,3))
        e = np.zeros((2,0))
        begin, end, b = strip_table_zeros(a)
        self.assertEqual(begin, a.shape[-1])
        self.assertEqual(end, a.shape[-1])
        self.assertEqual(begin, end) # This is a way to check for all-zero table
        self.assertTablesEqual(b, e)

        # Can keep entire nonzero table:
        a = np.ones((2,3))
        e = np.ones((2,3))
        begin, end, b = strip_table_zeros(a)
        self.assertEqual(begin, 0)
        self.assertEqual(end, a.shape[-1])
        self.assertNotEqual(begin, end)
        self.assertTablesEqual(b, e)

        # Can strip one left side column:
        a = np.ones((2,3))
        a[:,0] = 0.0
        e = np.ones((2,2))
        begin, end, b = strip_table_zeros(a)
        self.assertEqual(begin, 1)
        self.assertEqual(end, a.shape[-1])
        self.assertNotEqual(begin, end)
        self.assertTablesEqual(b, e)

        # Can strip one right side column:
        a = np.ones((2,3))
        a[:,2] = 0.0
        e = np.ones((2,2))
        begin, end, b = strip_table_zeros(a)
        self.assertEqual(begin, 0)
        self.assertEqual(end, a.shape[-1]-1)
        self.assertNotEqual(begin, end)
        self.assertTablesEqual(b, e)

        # Can strip two columns on each side:
        a = np.ones((2,5))
        a[:,0] = 0.0
        a[:,1] = 0.0
        a[:,3] = 0.0
        a[:,4] = 0.0
        e = np.ones((2,1))
        begin, end, b = strip_table_zeros(a)
        self.assertEqual(begin, 2)
        self.assertEqual(end, a.shape[-1]-2)
        self.assertNotEqual(begin, end)
        self.assertTablesEqual(b, e)

        # Can strip two columns on each side of rank 1 table:
        a = np.ones((5,))
        a[...,0] = 0.0
        a[...,1] = 0.0
        a[...,3] = 0.0
        a[...,4] = 0.0
        e = np.ones((1,))
        begin, end, b = strip_table_zeros(a)
        self.assertEqual(begin, 2)
        self.assertEqual(end, a.shape[-1]-2)
        self.assertNotEqual(begin, end)
        self.assertTablesEqual(b, e)

        # Can strip two columns on each side of rank 3 table:
        a = np.ones((3,2,5))
        a[...,0] = 0.0
        a[...,1] = 0.0
        a[...,3] = 0.0
        a[...,4] = 0.0
        e = np.ones((3,2,1))
        begin, end, b = strip_table_zeros(a)
        self.assertEqual(begin, 2)
        self.assertEqual(end, a.shape[-1]-2)
        self.assertNotEqual(begin, end)
        self.assertTablesEqual(b, e)

    def test_unique_tables_some_equal(self):
        tables = [
            np.zeros((2,)),
            np.ones((2,)),
            np.zeros((3,)),
            np.ones((2,)),
            np.ones((2,))*2,
            np.ones((2,))*2,
            ]
        unique, mapping = build_unique_tables(tables)
        expected_unique = [
            np.zeros((2,)),
            np.ones((2,)),
            np.zeros((3,)),
            #np.ones((2,)),
            np.ones((2,))*2,
            #np.ones((2,))*2,
            ]
        expected_mapping = [0, 1, 2, 1, 3, 3]
        self.assertEqual(mapping, expected_mapping)
        self.assertEqual(len(set(mapping)), len(unique))
        for i,t in enumerate(tables):
            self.assertTablesEqual(t, unique[mapping[i]])

    def test_unique_tables_all_equal(self):
        tables = [np.ones((3,5))*2.0]*6
        unique, mapping = build_unique_tables(tables)
        expected_unique = [tables[0]]
        expected_mapping = [0]*6
        self.assertEqual(mapping, expected_mapping)
        self.assertEqual(len(set(mapping)), len(unique))
        for i,t in enumerate(tables):
            self.assertTablesEqual(t, unique[mapping[i]])

    def test_unique_tables_all_different(self):
        tables = [
            np.ones((2,)),
            np.ones((2,3)),
            np.ones((2,3,4)),
            np.ones((2,3,4,5)),
            ]
        unique, mapping = build_unique_tables(tables)
        expected_unique = tables
        expected_mapping = list(range(len(tables)))
        self.assertEqual(mapping, expected_mapping)
        self.assertEqual(len(set(mapping)), len(unique))
        for i,t in enumerate(tables):
            self.assertTablesEqual(t, unique[mapping[i]])

if __name__ == '__main__':
    import unittest
    unittest.main()
