#!/usr/bin/env python
"""
Tests of generic code formatting utilities,
which focus on the overall structure of the code,
e.g. indentation, curly brace blocks, control flow
structures like loops, and class and function definitions.
Some of this is C++ specific, some is more generic.
"""

from ufltestcase import UflTestCase
from uflacs.codeutils.format_code_structure import *

class CodeUtilsTest(UflTestCase):

    def test_format_basics(self):
        # Reproduce a string
        self.assertEqual(format_code_structure("string"), "string")

        # Insert keywords in string using <2.6 syntax
        self.assertEqual(format_code_structure("%(string)s %(other)s",
                                keywords=dict(string='Hello', other='World')),
                    "Hello World")

        # Basic strings with indentation
        self.assertEqual(format_code_structure("string", 1), "    string")
        self.assertEqual(format_code_structure("string", 2, indentchar='xy'), "xyxystring")

        # Multiline strings with indentation
        self.assertEqual(format_code_structure("fee\nfie\nfoe", level=1, indentchar='q'),
                    "qfee\nqfie\nqfoe")

        # One item lists are the same as strings
        self.assertEqual(format_code_structure(["hello"]), "hello")
        self.assertEqual(format_code_structure(["hello"], 1), "    hello")
        self.assertEqual(format_code_structure(["hello"], 2, indentchar='xy'), "xyxyhello")

        # Tuples are concatenated directly
        self.assertEqual(format_code_structure(("hello", "world")),
                    "helloworld")
        self.assertEqual(format_code_structure(("hello", "world"), 1),
                    "    helloworld")
        self.assertEqual(format_code_structure(("hello", "world"), 2, indentchar='xy'),
                    "xyxyhelloworld")

        # Lists are joined with newlines
        self.assertEqual(format_code_structure(["hello", "world"]),
                    "hello\nworld")
        self.assertEqual(format_code_structure(["hello", "world"], 1),
                    "    hello\n    world")
        self.assertEqual(format_code_structure(["hello", "world"], 2, indentchar='xy'),
                    "xyxyhello\nxyxyworld")

    def test_format_blocks(self):
        # Strings and lists can be put in Indented containers
        self.assertEqual(format_code_structure(Indented("hei")), "    hei")
        self.assertEqual(format_code_structure(Indented(["hei", Indented("verden")]),
                                               indentchar='z'),
                    "zhei\nzzverden")

        # A Block is an indented body with brackets before and after
        self.assertEqual(format_code_structure(["{", Indented("fee\nfie\nfoe"), "}"],
                                               indentchar='\t'),
                    "{\n\tfee\n\tfie\n\tfoe\n}")
        self.assertEqual(format_code_structure(Block("fee\nfie\nfoe"), indentchar='\t'),
                    "{\n\tfee\n\tfie\n\tfoe\n}")
        # A Namespace is a 'namespace foo' line before a block
        self.assertEqual(format_code_structure(Namespace("bar", "fee\nfie\nfoe"), indentchar='\t'),
                    "namespace bar\n{\n\tfee\n\tfie\n\tfoe\n}")

        # Making a for loop
        self.assertEqual(format_code_structure(["for (iq...)", Block("foo(iq);")]),
                    "for (iq...)\n{\n    foo(iq);\n}")
        # Making a do loop
        self.assertEqual(format_code_structure(["iq = 0;", "do",
                                                (Block("foo(iq);"), " while (iq < nq);")]),
                    "iq = 0;\ndo\n{\n    foo(iq);\n} while (iq < nq);")

    def test_format_keywords(self):
        # Making a for loop with keywords
        self.assertEqual(format_code_structure(["for (%(i)s=0; %(i)s<n; ++%(i)s)",
                                                Block("foo(%(i)s);")], keywords={'i': 'k'}),
                    "for (k=0; k<n; ++k)\n{\n    foo(k);\n}")
        self.assertEqual(format_code_structure(WithKeywords(["for (%(i)s=0; %(i)s<n; ++%(i)s)",
                                                             Block("foo(%(i)s);")],
                                             keywords={'i': 'k'})),
                    "for (k=0; k<n; ++k)\n{\n    foo(k);\n}")

        # Formatting the same code with different keywords using WithKeywords
        tmp = ['%(a)s', '%(b)s']
        self.assertEqual(format_code_structure([WithKeywords(tmp, keywords={'a': 'a', 'b':'b'}),
                                 WithKeywords(tmp, keywords={'a': 'x', 'b':'y'})]),
                    "a\nb\nx\ny")

    def test_format_class(self):
        # Making a class declaration
        self.assertEqual(format_code_structure(Class('Car')), 'class Car\n{\n};')
        self.assertEqual(format_code_structure(Class('Car', superclass='Vehicle')),
                    'class Car: public Vehicle\n{\n};')
        self.assertEqual(format_code_structure(Class('Car', public_body='void eval()\n{\n}')),
                    'class Car\n{\npublic:\n    void eval()\n    {\n    }\n};')
        self.assertEqual(format_code_structure(Class('Car', protected_body='void eval()\n{\n}')),
                    'class Car\n{\nprotected:\n    void eval()\n    {\n    }\n};')
        self.assertEqual(format_code_structure(Class('Car', private_body='void eval()\n{\n}')),
                    'class Car\n{\nprivate:\n    void eval()\n    {\n    }\n};')

    def test_format_template_argument_list(self):
        def t(args, mlcode, slcode):
            self.assertEqual(format_code_structure(TemplateArgumentList(args, False),
                                                   indentchar=' '), slcode)
            self.assertEqual(format_code_structure(TemplateArgumentList(args, True),
                                                   indentchar=' '), mlcode)
        t(('A',), '<\n A\n>', '<A>')
        t(('A', 'B'), '<\n A,\n B\n>', '<A, B>')

    def test_format_templated_type(self):
        self.assertEqual(format_code_structure(Type('Foo')),
                         'Foo')
        self.assertEqual(format_code_structure(Type('Foo', ('int', '123'))),
                         'Foo<int, 123>')
        self.assertEqual(format_code_structure(Type('Foo', ('int', Type('Bar', ('123', 'float'))))),
                         'Foo<int, Bar<123, float> >')

    def test_format_typedef(self):
        self.assertEqual(format_code_structure(TypeDef('int', 'myint')),
                         'typedef int myint;')
        self.assertEqual(format_code_structure(TypeDef(Type('Foo', ('int', Type('Bar', ('123', 'float')))), 'Thing')),
                         'typedef Foo<int, Bar<123, float> > Thing;')

    def test_format_template_class(self):
        expected = "template<typename T, typename R>\nclass MyClass\n{\npublic:\n    void hello(int world) {}\n};"

        code = [('template', TemplateArgumentList(('typename T', 'typename R'), False)),
                Class('MyClass', public_body='void hello(int world) {}')]
        self.assertEqual(format_code_structure(code), expected)

        code = Class('MyClass', public_body='void hello(int world) {}',
                     template_arguments=('typename T', 'typename R'))
        self.assertEqual(format_code_structure(code), expected)

    def test_format_variable_decl(self):
        code = VariableDecl("double", "foo")
        expected = "double foo;"
        self.assertEqual(format_code_structure(code), expected)

    def test_format_array_decl(self):
        expected = "double foo[3];"
        code = ArrayDecl("double", "foo", 3)
        self.assertEqual(format_code_structure(code), expected)
        code = ArrayDecl("double", "foo", (3,))
        self.assertEqual(format_code_structure(code), expected)
        decl = code

        expected = "foo[1]"
        code = ArrayAccess(decl, 1)
        self.assertEqual(format_code_structure(code), expected)
        code = ArrayAccess(decl, (1,))
        self.assertEqual(format_code_structure(code), expected)

        expected = "foo[0]"
        code = ArrayAccess(decl, 0)
        self.assertEqual(format_code_structure(code), expected)
        self.assertRaises(ValueError, lambda: ArrayAccess(decl, 3))

        code = ArrayDecl("double", "foo", (3,4))
        expected = "double foo[3][4];"
        self.assertEqual(format_code_structure(code), expected)
        decl = code

        expected = "foo[0][1]"
        code = ArrayAccess(decl, (0,1))
        self.assertEqual(format_code_structure(code), expected)
        expected = "foo[2][3]"
        code = ArrayAccess(decl, (2,3))
        self.assertEqual(format_code_structure(code), expected)

        self.assertRaises(ValueError, lambda: ArrayAccess(decl, 0))
        self.assertRaises(ValueError, lambda: ArrayAccess(decl, (0,4)))
        self.assertRaises(ValueError, lambda: ArrayAccess(decl, (3,0)))
        self.assertRaises(ValueError, lambda: ArrayAccess(decl, (3,-1)))

    def test_class_with_arrays(self):
        adecl = ArrayDecl('double', 'phi', (3,5))
        aacc = ArrayAccess(adecl, (2,1))
        expected = "Car.phi[2][1]"
        code = ("Car", ".", aacc)
        self.assertEqual(format_code_structure(code), expected)

        decls = [VariableDecl('double', 'foo'),
                 VariableDecl('int', 'bar'),
                 adecl,
                 ]
        classcode = Class('Car', public_body=decls)

        expected_decls = [format_code_structure(decl) for decl in decls]
        expected = 'class Car\n{\npublic:\n    %s\n};' % '\n    '.join(expected_decls)
        actual = format_code_structure(classcode)
        self.assertEqual(actual, expected)

    def test_class_array_access(self):
        oname = 'pvars[iq]'
        vname = 'phi'
        shape = (3,4)
        component = ('i0',2)
        decl = ArrayDecl('double', vname, shape)
        dcode = format_code_structure(decl)
        acode = format_code_structure((oname, '.', ArrayAccess(decl, component)))
        self.assertEquals(dcode, 'double phi[3][4];')
        self.assertEquals(acode, 'pvars[iq].phi[i0][2]')

    def test_while_loop(self):
        code = WhileLoop("--k < 3")
        actual = format_code_structure(code)
        expected = "while (--k < 3)"
        self.assertEquals(actual, expected)

        code = WhileLoop("--k < 3", body=["ting;", "tang;"])
        actual = format_code_structure(code)
        expected = "while (--k < 3)\n{\n    ting;\n    tang;\n}"
        self.assertEquals(actual, expected)

    def test_for_loop(self):
        code = ForLoop("int i = 0", "i < 3", "++i")
        actual = format_code_structure(code)
        expected = "for (int i = 0; i < 3; ++i)"
        self.assertEquals(actual, expected)

        code = ForLoop("int i = 0", "i < 3", "++i", body=["ting;", "tang;"])
        actual = format_code_structure(code)
        expected = "for (int i = 0; i < 3; ++i)\n{\n    ting;\n    tang;\n}"
        self.assertEquals(actual, expected)

    def test_for_range(self):
        code = ForRange("i", "0", "3")
        actual = format_code_structure(code)
        expected = "for (int i = 0; i < 3; ++i)"
        self.assertEquals(actual, expected)

        code = ForRange("i", "0", "3", body=["ting;", "tang;"])
        actual = format_code_structure(code)
        expected = "for (int i = 0; i < 3; ++i)\n{\n    ting;\n    tang;\n}"
        self.assertEquals(actual, expected)

if __name__ == '__main__':
    import unittest
    unittest.main()

