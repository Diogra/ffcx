#!/usr/bin/env python
"""
Tests of C++ expression formatting rules.
"""

from ufltestcase import UflTestCase

import ufl
from ufl.constantvalue import as_ufl
from ufl.algorithms import preprocess_expression, expand_indices
import uflacs
from uflacs.codeutils.cpp_format import (CppLiteralFormatterRules,
                                         CppArithmeticFormatterRules,
                                         CppCmathFormatterRules,
                                         CppConditionalFormatterRules)
from uflacs.codeutils.dependency_handler import DependencyHandler
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.backends.toy.toy_language_formatter import ToyCppLanguageFormatter

def format_expression_as_test_cpp(expr, variables=None):
    "This is a test specific function for formatting ufl to C++."

    common_cell = expr.cell() or ufl.cell3D # Cell choice hack!

    # Preprocessing expression before applying formatting.
    # In a compiler, one should probably assume that these
    # have been applied and use ExprFormatter directly.
    expr_data = preprocess_expression(expr, common_cell=common_cell)

    # Applying expand_indices instead of going through
    # compiler algorithm to get scalar valued expressions
    # that can be directlly formatted into C++
    expr = expand_indices(expr_data.preprocessed_expr)

    # Setup arguments to language formatter...
    ir = {}
    modified_terminals = [] # FIXME: Need something here?
    form_argument_mapping = {}
    object_names = {}
    dh = DependencyHandler(modified_terminals, expr_data.cell, form_argument_mapping, object_names)

    # This formatter is a multifunction implementing target
    # specific C++ formatting rules
    cpp_formatter = ToyCppLanguageFormatter(dh, ir)

    # This final formatter implements a generic framework handling indices etc etc.
    expr_formatter = ExprFormatter(cpp_formatter, variables or {})

    # Finally perform the formatting
    code = expr_formatter.visit(expr)
    return code

class PureCppFormatterTest(UflTestCase):
    """Pure C++ expression formatting, not involving any UFL expressions."""
    def test_cpp_literal_formatter(self):
        fmt = CppLiteralFormatterRules()

        self.assertEqual(fmt.int_value(as_ufl(123)), "123")
        self.assertEqual(fmt.float_value(as_ufl(1.0/3.0))[:7], "0.33333")
        self.assertEqual(fmt.zero(as_ufl(0)), "0")

        self.assertEqual(fmt.int_value(123), "123")
        self.assertEqual(fmt.float_value(1.0/3.0)[:7], "0.33333")
        self.assertEqual(fmt.zero(0), "0")

        self.assertEqual(fmt.int_value("123"), "123")
        self.assertEqual(fmt.float_value(str(1.0/3.0))[:7], "0.33333")
        self.assertEqual(fmt.zero("0"), "0")

    def test_cpp_arithmetic_formatter(self):
        fmt = CppArithmeticFormatterRules()
        self.assertEqual(fmt.sum(None, "1", "2"), "1 + 2")
        self.assertEqual(fmt.sum(None, "1", "2", "3"), "1 + 2 + 3")
        self.assertEqual(fmt.product(None, "1", "2"), "1 * 2")
        self.assertEqual(fmt.product(None, "1", "2", "3"), "1 * 2 * 3")
        self.assertEqual(fmt.division(None, "1", "2"), "1 / 2")

    def test_cpp_cmath_formatter(self):
        fmt = CppCmathFormatterRules()
        self.assertEqual(fmt.power(None, "x", "y"), "pow(x, y)")
        self.assertEqual(fmt.sqrt(None, "x"), "sqrt(x)")
        self.assertEqual(fmt.ln(None, "x"), "log(x)")
        self.assertEqual(fmt.exp(None, "x"), "exp(x)")
        self.assertEqual(fmt.abs(None, "x"), "fabs(x)")
        self.assertEqual(fmt.cos(None, "x"), "cos(x)")
        self.assertEqual(fmt.sin(None, "x"), "sin(x)")
        self.assertEqual(fmt.tan(None, "x"), "tan(x)")
        self.assertEqual(fmt.cosh(None, "x"), "cosh(x)")
        self.assertEqual(fmt.sinh(None, "x"), "sinh(x)")
        self.assertEqual(fmt.tanh(None, "x"), "tanh(x)")
        self.assertEqual(fmt.acos(None, "x"), "acos(x)")
        self.assertEqual(fmt.asin(None, "x"), "asin(x)")
        self.assertEqual(fmt.atan(None, "x"), "atan(x)")
        #self.assertEqual(fmt.bessel_i(None, "n", "x"), "cyl_bessel_i(n, x)") # TODO
        #self.assertEqual(fmt.bessel_j(None, "n", "x"), "cyl_bessel_j(n, x)")
        #self.assertEqual(fmt.bessel_k(None, "n", "x"), "cyl_bessel_k(n, x)")
        #self.assertEqual(fmt.bessel_l(None, "n", "x"), "cyl_neumann(n, x)")

    def test_cpp_conditional_formatter(self):
        fmt = CppConditionalFormatterRules()
        self.assertEqual(fmt.eq(None, "x", "y"), "x == y")
        self.assertEqual(fmt.ne(None, "x", "y"), "x != y")
        self.assertEqual(fmt.lt(None, "x", "y"), "x < y")
        self.assertEqual(fmt.gt(None, "x", "y"), "x > y")
        self.assertEqual(fmt.le(None, "x", "y"), "x <= y")
        self.assertEqual(fmt.ge(None, "x", "y"), "x >= y")
        self.assertEqual(fmt.and_condition(None, "x", "y"), "x && y")
        self.assertEqual(fmt.or_condition(None, "x", "y"), "x || y")
        self.assertEqual(fmt.not_condition(None, "x"), "!x")

class Ufl2CppFormatterTest(UflTestCase):

    def assertCppEqual(self, expr, code, variables=None):
        r = format_expression_as_test_cpp(expr, variables)
        self.assertEqual(code, r)

    def test_cpp_formatting_of_literals(self):
        # Test literals
        self.assertCppEqual(ufl.as_ufl(2), "2")
        self.assertCppEqual(ufl.as_ufl(3.14), '3.14')
        self.assertCppEqual(ufl.as_ufl(0), "0")
        # These are actually converted to int before formatting:
        self.assertCppEqual(ufl.Identity(2)[0,0], "1")
        self.assertCppEqual(ufl.Identity(2)[0,1], "0")
        self.assertCppEqual(ufl.Identity(2)[1,0], "0")
        self.assertCppEqual(ufl.Identity(2)[1,1], "1")
        self.assertCppEqual(ufl.PermutationSymbol(3)[1,2,3], "1")
        self.assertCppEqual(ufl.PermutationSymbol(3)[2,1,3], "-1")
        self.assertCppEqual(ufl.PermutationSymbol(3)[1,1,3], "0")

    def test_cpp_formatting_of_geometry(self):
        # Test geometry quantities (faked for testing!)
        x = ufl.cell1D.x[0]
        self.assertCppEqual(x, "x[0]")
        x, y = ufl.cell2D.x
        self.assertCppEqual(x, "x[0]")
        self.assertCppEqual(y, "x[1]")
        nx, ny = ufl.cell2D.n
        self.assertCppEqual(nx, "n[0]")
        self.assertCppEqual(ny, "n[1]")
        Kv = ufl.cell2D.volume
        self.assertCppEqual(Kv, "volume")
        Kr = ufl.cell2D.circumradius
        self.assertCppEqual(Kr, "circumradius")

    def test_cpp_formatting_of_form_arguments(self):
        # Test form arguments (faked for testing!)
        V = ufl.FiniteElement("CG", ufl.cell2D, 1)
        f = ufl.Coefficient(V).reconstruct(count=0)
        self.assertCppEqual(f, "w0")
        v = ufl.Argument(V).reconstruct(count=0)
        self.assertCppEqual(v, "v0")

        V = ufl.VectorElement("CG", ufl.cell2D, 1)
        f = ufl.Coefficient(V).reconstruct(count=1)
        self.assertCppEqual(f[0], "w0[0]") # Renumbered to 0...
        v = ufl.Argument(V).reconstruct(count=3)
        self.assertCppEqual(v[1], "v0[1]") # Renumbered to 0...

        V = ufl.TensorElement("CG", ufl.cell2D, 1)
        f = ufl.Coefficient(V).reconstruct(count=2)
        self.assertCppEqual(f[1,0], "w0[1][0]") # Renumbered to 0...
        v = ufl.Argument(V).reconstruct(count=3)
        self.assertCppEqual(v[0,1], "v0[0][1]") # Renumbered to 0...

        # TODO: Test mixed functions
        # TODO: Test tensor functions with symmetries

    def test_cpp_formatting_of_arithmetic(self):
        x, y = ufl.triangle.x
        # Test basic arithmetic operators
        self.assertCppEqual(x + 3, "3 + x[0]")
        self.assertCppEqual(x * 2, "2 * x[0]")
        self.assertCppEqual(x / 2, "x[0] / 2")
        self.assertCppEqual(x*x, "pow(x[0], 2)") # TODO: Will gcc optimize this to x*x for us?
        self.assertCppEqual(x**3, "pow(x[0], 3)")
        # TODO: Test all basic operators

    def test_cpp_formatting_of_cmath(self):
        x, y = ufl.triangle.x
        # Test cmath functions
        self.assertCppEqual(ufl.exp(x), "exp(x[0])")
        self.assertCppEqual(ufl.ln(x), "log(x[0])")
        self.assertCppEqual(ufl.sqrt(x), "sqrt(x[0])")
        self.assertCppEqual(abs(x), "fabs(x[0])")
        self.assertCppEqual(ufl.sin(x), "sin(x[0])")
        self.assertCppEqual(ufl.cos(x), "cos(x[0])")
        self.assertCppEqual(ufl.tan(x), "tan(x[0])")
        self.assertCppEqual(ufl.asin(x), "asin(x[0])")
        self.assertCppEqual(ufl.acos(x), "acos(x[0])")
        self.assertCppEqual(ufl.atan(x), "atan(x[0])")

    def test_cpp_formatting_of_derivatives(self):
        xx = ufl.triangle.x
        x, y = xx
        # Test derivatives of basic operators
        self.assertCppEqual(x.dx(0), "1")
        self.assertCppEqual(x.dx(1), "0")
        self.assertCppEqual(ufl.grad(xx)[0,0], "1")
        self.assertCppEqual(ufl.grad(xx)[0,1], "0")
        self.assertCppEqual(ufl.sin(x).dx(0), "cos(x[0])")

        # Test derivatives of target specific test fakes
        V = ufl.FiniteElement("CG", ufl.cell2D, 1)
        f = ufl.Coefficient(V).reconstruct(count=0)
        self.assertCppEqual(f.dx(0), "d1_w0[0]")
        v = ufl.Argument(V).reconstruct(count=3)
        self.assertCppEqual(v.dx(1), "d1_v0[1]") # Renumbered to 0...
        # TODO: Test more derivatives
        # TODO: Test variable derivatives using diff

    def test_cpp_formatting_of_conditionals(self):
        x, y = ufl.triangle.x
        # Test conditional expressions
        self.assertCppEqual(ufl.conditional(ufl.lt(x, 2), y, 3),
                    "x[0] < 2 ? x[1]: 3")
        self.assertCppEqual(ufl.conditional(ufl.gt(x, 2), 4+y, 3),
                    "x[0] > 2 ? 4 + x[1]: 3")
        self.assertCppEqual(ufl.conditional(ufl.And(ufl.le(x, 2), ufl.ge(y, 4)), 7, 8),
                    "x[0] <= 2 && x[1] >= 4 ? 7: 8")
        self.assertCppEqual(ufl.conditional(ufl.Or(ufl.eq(x, 2), ufl.ne(y, 4)), 7, 8),
                    "x[0] == 2 || x[1] != 4 ? 7: 8")
        # TODO: Some tests of nested conditionals with correct precedences?

    def test_cpp_formatting_precedence_handling(self):
        x, y = ufl.triangle.x
        # Test precedence handling with sums
        # Note that the automatic sorting is reflected in formatting!
        self.assertCppEqual(y + (2 + x), "x[1] + (2 + x[0])")
        self.assertCppEqual((x + 2) + y, "x[1] + (2 + x[0])")

        self.assertCppEqual((2 + x) + (3 + y), "(2 + x[0]) + (3 + x[1])")

        self.assertCppEqual((x + 3) + 2 + y, "x[1] + (2 + (3 + x[0]))")
        self.assertCppEqual(2 + (x + 3) + y, "x[1] + (2 + (3 + x[0]))")
        self.assertCppEqual(2 + (3 + x) + y, "x[1] + (2 + (3 + x[0]))")
        self.assertCppEqual(y + (2 + (3 + x)), "x[1] + (2 + (3 + x[0]))")

        self.assertCppEqual(2 + x + 3 + y, "x[1] + (3 + (2 + x[0]))")
        self.assertCppEqual(2 + x + 3 + y, "x[1] + (3 + (2 + x[0]))")

        # Test precedence handling with divisions
        # This is more stable than sums since there is no sorting.
        self.assertCppEqual((x / 2) / 3, "(x[0] / 2) / 3")
        self.assertCppEqual(x / (y / 3), "x[0] / (x[1] / 3)")
        self.assertCppEqual((x / 2) / (y / 3), "(x[0] / 2) / (x[1] / 3)")
        self.assertCppEqual(x / (2 / y) / 3, "(x[0] / (2 / x[1])) / 3")

        # Test precedence handling with highest level types
        self.assertCppEqual(ufl.sin(x), "sin(x[0])")
        self.assertCppEqual(ufl.cos(x+2), "cos(2 + x[0])")
        self.assertCppEqual(ufl.tan(x/2), "tan(x[0] / 2)")
        self.assertCppEqual(ufl.acos(x + 3 * y), "acos(x[0] + 3 * x[1])")
        self.assertCppEqual(ufl.asin(ufl.atan(x**4)), "asin(atan(pow(x[0], 4)))")
        self.assertCppEqual(ufl.sin(y) + ufl.tan(x), "sin(x[1]) + tan(x[0])")

        # Test precedence handling with mixed types
        self.assertCppEqual(3 * (2 + x), "3 * (2 + x[0])")
        self.assertCppEqual((2 * x) + (3 * y), "2 * x[0] + 3 * x[1]")
        self.assertCppEqual(2 * (x + 3) * y, "x[1] * (2 * (3 + x[0]))")
        self.assertCppEqual(2 * (x + 3)**4 * y, "x[1] * (2 * pow(3 + x[0], 4))")
        # TODO: More tests covering all types and more combinations!

    def test_cpp_formatting_with_variables(self):
        x, y = ufl.triangle.x
        # Test user-provided C variables for subexpressions
        # we can use variables for x[0], and sum, and power
        self.assertCppEqual(x**2 + y**2, "x2 + y2", variables={x**2: 'x2', y**2: 'y2'})
        self.assertCppEqual(x**2 + y**2, "pow(z, 2) + y2", variables={x: 'z', y**2: 'y2'})
        self.assertCppEqual(x**2 + y**2, "q", variables={x**2 + y**2: 'q'})
        # we can use variables in conditionals
        self.assertCppEqual(ufl.conditional(ufl.Or(ufl.eq(x, 2), ufl.ne(y, 4)), 7, 8),
                    "c1 || c2 ? 7: 8",
                    variables={ufl.eq(x, 2): 'c1', ufl.ne(y, 4): 'c2'})
        # we can replace coefficients (formatted by user provided code)
        V = ufl.FiniteElement("CG", ufl.cell2D, 1)
        f = ufl.Coefficient(V).reconstruct(count=0)
        self.assertCppEqual(f, "f", variables={f: 'f'})
        self.assertCppEqual(f**3, "pow(f, 3)", variables={f: 'f'})
        # variables do not replace derivatives of variable expressions
        self.assertCppEqual(f.dx(0), "d1_w0[0]", variables={f: 'f'})

        # This test depends on which differentiation algorithm is in use
        # in UFL, representing derivatives as SpatialDerivative or Grad:
        # variables do replace variable expressions that are themselves derivatives
        self.assertCppEqual(f.dx(0), "df", variables={f.dx(0): 'df',
                                                      ufl.grad(f)[0]: 'df'})
        self.assertCppEqual(ufl.grad(f)[0], "df", variables={f.dx(0): 'df',
                                                             ufl.grad(f)[0]: 'df'})

        # TODO: Test variables in more situations with indices and derivatives

    # TODO: Test various compound operators

if __name__ == '__main__':
    import unittest
    unittest.main()
