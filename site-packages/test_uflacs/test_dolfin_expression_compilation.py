"""
Tests of C++ expression formatting rules.
"""

from ufltestcase import UflTestCase

import ufl
from ufl.constantvalue import as_ufl
import uflacs, uflacs.codeutils
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules, CppDefaultFormatter

from uflacs.backends.dolfin.expression import format_dolfin_expression

# For test comparisons
dolfin_expression_minimal = """\
class MyExpression: public Expression
{
public:

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }
};"""

dolfin_expression_with_constructor1 = """\
class MyExpression: public Expression
{
public:
    MyExpression(): Expression(2) {}

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }
};"""

dolfin_expression_with_constructor2 = """\
class MyExpression: public Expression
{
public:
    MyExpression(): Expression(2, 3) {}

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }
};"""

dolfin_expression_with_members = """\
class MyExpression: public Expression
{
public:

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }

    double c;
    boost::shared_ptr<MeshFunction<double> > mf;
    boost::shared_ptr<GenericFunction> gf;
    boost::shared_ptr<Function> f;
};"""

dolfin_expression_with_members2 = """\
class MyExpression: public Expression
{
public:

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }

    double c0;
    double c1;
    boost::shared_ptr<MeshFunction<double> > mf0;
    boost::shared_ptr<MeshFunction<double> > mf1;
    boost::shared_ptr<GenericFunction> gf0;
    boost::shared_ptr<GenericFunction> gf1;
    boost::shared_ptr<Function> f0;
    boost::shared_ptr<Function> f1;
};"""

other_stuff = """
        // Getting cell data
        const uint gd = cell.geometric_dimension;
        const uint td = cell.topological_dimension;
        const uint cell_index = cell.entity_indices[td][0];

        // Tabulation of mesh function values
        double mf0v = (*mf0)[cell_index];

        // Evaluation of functions
        Array<double> w0v(1);
        w0->eval(w0v, x, cell);

        // Writing output values
        values[0] = w0v[0]*mf0v;
        values[1] = w0v[0]+mf0v;
"""

class DolfinExpressionCompilerTest(UflTestCase):
    """Tests of Dolfin C++ Expression compilation from UFL expressions."""
    def setUp(self):
        self.fmt = CppFormatterRules()

    def assertEqual2(self, a, b):
        if a != b:
            print
            print a.replace('\t', 'TAB').replace(' ','S')
            print
            print b.replace('\t', 'TAB').replace(' ','S')
            print
        self.assertEqual(a,b)

    def test_dolfin_expression_constructors(self):
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=())
        self.assertEqual2(code, dolfin_expression_minimal)
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(2,))
        self.assertEqual2(code, dolfin_expression_with_constructor1)
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(2,3))
        self.assertEqual2(code, dolfin_expression_with_constructor2)

    def test_dolfin_expression_members(self):
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(),
                                        constants=('c',),
                                        mesh_functions=('mf',),
                                        generic_functions=('gf',),
                                        functions=('f',),
                                        )
        self.assertEqual2(code, dolfin_expression_with_members)
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(),
                                        constants=('c0','c1'),
                                        mesh_functions=('mf0','mf1'),
                                        generic_functions=('gf0','gf1'),
                                        functions=('f0','f1'),
                                        )
        self.assertEqual2(code, dolfin_expression_with_members2)

    def test_explicit_dolfin_expression_compilation(self):
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(2,),
                                        eval_body=['values[0] = x[0];',
                                                   'values[1] = x[1];'],
                                        constants=('c0','c1'),
                                        mesh_functions=('mf0','mf1'),
                                        generic_functions=('gf0','gf1'),
                                        functions=('f0','f1'),
                                        )
        try:
            import dolfin
        except:
            self.assertTrue(False, msg="Failed to import dolfin.")
        expr = dolfin.Expression(cppcode=code)
        self.assertTrue(hasattr(expr, 'c0'))
        self.assertTrue(hasattr(expr, 'c1'))
        self.assertTrue(hasattr(expr, 'mf0'))
        self.assertTrue(hasattr(expr, 'mf1'))
        self.assertTrue(hasattr(expr, 'gf0'))
        self.assertTrue(hasattr(expr, 'gf1'))
        self.assertTrue(hasattr(expr, 'f0'))
        self.assertTrue(hasattr(expr, 'f1'))
        #dolfin.plot(expr, mesh=dolfin.UnitSquare(10,10), interactive=True)

    def xtest_dolfin_expression_compilation(self):
        x = ufl.triangle.x
        uexpr = 2*x
        shape = uexpr.shape()
        name = "MyExpression"
        expected_lines = ['double s[2];',
                          's[0] = 2 * x[0];',
                          's[1] = 2 * x[1];',
                          'values[0] = s[0];',
                          'values[1] = s[1];']

        compiled_lines = [] #compile_ufl_to_dolfin_expression(uexpr) # FIXME
        self.assertEqual(compiled_lines, expected_lines)

        compiled_lines = expected_lines
        code = format_dolfin_expression(classname=name,
                                        shape=shape,
                                        eval_body=compiled_lines)
        try:
            import dolfin
        except:
            self.assertTrue(False, msg="Failed to import dolfin.")
        expr = dolfin.Expression(cppcode=code)

