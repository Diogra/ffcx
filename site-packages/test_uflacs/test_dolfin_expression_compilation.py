"""
Tests of C++ expression formatting rules.
"""

from ufltestcase import UflTestCase

import ufl
from ufl.constantvalue import as_ufl
import uflacs, uflacs.codeutils
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules, CppDefaultFormatter
from uflacs.codeutils.format_code_structure import (format_code_structure,
                                                    strip_trailing_whitespace,
                                                    WithKeywords, Class, Indented)

eval_template = """
void eval(Array<double>& values,
          const Array<double>& x,
          const ufc::cell& cell) const
{%(eval_body)s
}"""

def format_dolfin_expression(classname="MyExpression",
                             shape=(),
                             eval_body="",
                             mesh_functions=(),
                             functions=(),
                             generic_functions=(),
                             constants=()):
    # ...
    r = len(shape)
    if r == 0:
        constructors = []
    elif r == 1:
        constructors = ["%s(): Expression(%d) {}" % (classname, shape[0])]
    elif r == 2:
        constructors = ["%s(): Expression(%d, %d) {}" % (classname, shape[0], shape[1])]
    else:
        error
    # Make class body
    classbody = []
    classbody += constructors
    classbody += [WithKeywords(eval_template, { 'eval_body': Indented(eval_body) })]
    classbody += [mf_template % f for f in mesh_functions]
    classbody += [gf_template % f for f in generic_functions]
    classbody += [f_template  % f for f in functions]
    code = Class(name=classname,
                 superclass="Expression",
                 public_body=classbody)
    return strip_trailing_whitespace(format_code_structure(code))

# For test comparisons
dolfin_expression_minimal = """\
class MyExpression: public Expression
{
public:

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }
};"""

dolfin_expression_with_constructor1 = """\
class MyExpression: public Expression
{
public:
    MyExpression(): Expression(2) {}

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }
};"""

dolfin_expression_with_constructor2 = """\
class MyExpression: public Expression
{
public:
    MyExpression(): Expression(2, 3) {}

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }
};"""

dolfin_expression_with_members = """\
class MyExpression: public Expression
{
public:

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }

    boost::shared_ptr<MeshFunction<double> > mf;
    boost::shared_ptr<GenericFunction> gf;
    boost::shared_ptr<GenericFunction> f;
};"""

dolfin_expression_with_members2 = """\
class MyExpression: public Expression
{
public:

    void eval(Array<double>& values,
              const Array<double>& x,
              const ufc::cell& cell) const
    {
    }

    boost::shared_ptr<MeshFunction<double> > mf0;
    boost::shared_ptr<MeshFunction<double> > mf1;
    boost::shared_ptr<GenericFunction> gf0;
    boost::shared_ptr<GenericFunction> gf1;
    boost::shared_ptr<GenericFunction> f0;
    boost::shared_ptr<GenericFunction> f1;
};"""

other_stuff = """
        // Getting cell data
        const uint gd = cell.geometric_dimension;
        const uint td = cell.topological_dimension;
        const uint cell_index = cell.entity_indices[td][0];

        // Tabulation of mesh function values
        double mf0v = (*mf0)[cell_index];

        // Evaluation of functions
        Array<double> w0v(1);
        w0->eval(w0v, x, cell);

        // Writing output values
        values[0] = w0v[0]*mf0v;
        values[1] = w0v[0]+mf0v;
"""

class DolfinExpressionCompilerTest(UflTestCase):
    """Tests of Dolfin C++ Expression compilation from UFL expressions."""
    def setUp(self):
        self.fmt = CppFormatterRules()

    def assertEqual2(self, a, b):
        if a != b:
            print
            print a.replace('\t', 'TAB').replace(' ','S')
            print
            print b.replace('\t', 'TAB').replace(' ','S')
            print
        self.assertEqual(a,b)

    def test_dolfin_expression_constructors(self):
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=())
        self.assertEqual2(code, dolfin_expression_minimal)
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(2,))
        self.assertEqual2(code, dolfin_expression_with_constructor1)
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(2,3))
        self.assertEqual2(code, dolfin_expression_with_constructor2)
