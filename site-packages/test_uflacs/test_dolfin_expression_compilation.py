"""
Tests of C++ expression formatting rules.
"""

from ufltestcase import UflTestCase

import ufl
from ufl.constantvalue import as_ufl

import numpy
import dolfin

import uflacs, uflacs.codeutils
from uflacs.codeutils.expr_formatter import ExprFormatter
from uflacs.codeutils.cpp_format import CppFormatterRules
from uflacs.codeutils.target_formatter import CppDefaultFormatter

from uflacs.backends.dolfin.expression import format_dolfin_expression
from uflacs.backends.dolfin.compiler import compile_dolfin_expression_body


# For test comparisons
dolfin_expression_minimal = """\
class MyExpression: public Expression
{
public:

    virtual void eval(Array<double>& values,
                      const Array<double>& x) const
    {

    }
};"""

dolfin_expression_with_constructor1 = """\
class MyExpression: public Expression
{
public:
    MyExpression(): Expression(2) {}

    virtual void eval(Array<double>& values,
                      const Array<double>& x) const
    {

    }
};"""

dolfin_expression_with_constructor2 = """\
class MyExpression: public Expression
{
public:
    MyExpression(): Expression(2, 3) {}

    virtual void eval(Array<double>& values,
                      const Array<double>& x) const
    {

    }
};"""

dolfin_expression_with_members = """\
class MyExpression: public Expression
{
public:

    virtual void eval(Array<double>& values,
                      const Array<double>& x) const
    {

    }

    double c;
    boost::shared_ptr<MeshFunction<double> > mf;
    boost::shared_ptr<GenericFunction> gf;
    boost::shared_ptr<Function> f;
};"""

dolfin_expression_with_members2 = """\
class MyExpression: public Expression
{
public:

    virtual void eval(Array<double>& values,
                      const Array<double>& x) const
    {

    }

    double c0;
    double c1;
    boost::shared_ptr<MeshFunction<double> > mf0;
    boost::shared_ptr<MeshFunction<double> > mf1;
    boost::shared_ptr<GenericFunction> gf0;
    boost::shared_ptr<GenericFunction> gf1;
    boost::shared_ptr<Function> f0;
    boost::shared_ptr<Function> f1;
};"""

other_stuff = """
        // Getting cell data
        const uint gd = cell.geometric_dimension;
        const uint td = cell.topological_dimension;
        const uint cell_index = cell.entity_indices[td][0];

        // Tabulation of mesh function values
        double mf0v = (*mf0)[cell_index];

        // Evaluation of functions
        Array<double> w0v(1);
        w0->eval(w0v, x, cell);

        // Writing output values
        values[0] = w0v[0]*mf0v;
        values[1] = w0v[0]+mf0v;
"""

class DolfinExpressionFormatterTest(UflTestCase):
    """Tests of Dolfin C++ Expression formatting utilities."""
    def setUp(self):
        self.fmt = CppFormatterRules()

    def assertEqual2(self, a, b):
        if a != b:
            print
            print a.replace('\t', 'TAB').replace(' ','S')
            print
            print b.replace('\t', 'TAB').replace(' ','S')
            print
        self.assertEqual(a,b)

    def test_dolfin_expression_constructors(self):
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=())
        self.assertEqual2(code, dolfin_expression_minimal)
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(2,))
        self.assertEqual2(code, dolfin_expression_with_constructor1)
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(2,3))
        self.assertEqual2(code, dolfin_expression_with_constructor2)

    def test_dolfin_expression_members(self):
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(),
                                        constants=('c',),
                                        mesh_functions=('mf',),
                                        generic_functions=('gf',),
                                        functions=('f',),
                                        )
        self.assertEqual2(code, dolfin_expression_with_members)
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(),
                                        constants=('c0','c1'),
                                        mesh_functions=('mf0','mf1'),
                                        generic_functions=('gf0','gf1'),
                                        functions=('f0','f1'),
                                        )
        self.assertEqual2(code, dolfin_expression_with_members2)

    def test_explicit_dolfin_expression_compilation(self):
        code = format_dolfin_expression(classname="MyExpression",
                                        shape=(2,),
                                        eval_body=['values[0] = x[0];',
                                                   'values[1] = x[1];'],
                                        constants=('c0','c1'),
                                        mesh_functions=('mf0','mf1'),
                                        generic_functions=('gf0','gf1'),
                                        functions=('f0','f1'),
                                        )
        try:
            import dolfin
        except:
            self.assertTrue(False, msg="Failed to import dolfin.")
        expr = dolfin.Expression(cppcode=code)
        self.assertTrue(hasattr(expr, 'c0'))
        self.assertTrue(hasattr(expr, 'c1'))
        self.assertTrue(hasattr(expr, 'mf0'))
        self.assertTrue(hasattr(expr, 'mf1'))
        self.assertTrue(hasattr(expr, 'gf0'))
        self.assertTrue(hasattr(expr, 'gf1'))
        self.assertTrue(hasattr(expr, 'f0'))
        self.assertTrue(hasattr(expr, 'f1'))
        #dolfin.plot(expr, mesh=dolfin.UnitSquare(10,10), interactive=True)

def flattened_nonempty_lines(lines):
    res = []
    for l in lines:
        if isinstance(l, list):
            res.extend(flattened_nonempty_lines(l))
        elif l:
            res.append(l)
        else:
            pass
    return res

import hashlib
class Ufl2DolfinExpressionCompilerTest(UflTestCase):
    """Tests of Dolfin C++ Expression compilation from UFL expressions."""

    def _test_dolfin_expression_compilation(self, uexpr, expected_lines, expected_values,
                                            members={}):
        # Compile expression
        compiled_lines, member_names = compile_dolfin_expression_body(uexpr)

        # Wrap it in a dolfin::Expression class
        shape = uexpr.shape()
        name = "MyExpression_%s" % hashlib.md5(str(hash(uexpr))).hexdigest()
        code = format_dolfin_expression(classname=name,
                                        shape=shape,
                                        eval_body=compiled_lines,
                                        **member_names)
        if 0:
            print "SKIPPING REST OF TEST"
            return

        # Check expected compilation output
        self.assertEqual(flattened_nonempty_lines(compiled_lines), expected_lines)

        # Try to compile it with DOLFIN
        try:
            import dolfin
        except:
            self.assertTrue(False, msg="Failed to import dolfin.")
        dexpr = dolfin.Expression(cppcode=code)

        # Connect compiled dolfin::Expression object with dolfin::Function instances
        for name, value in members.iteritems():
            setattr(dexpr, name, value)

        # Evaluate and assert compiled value!
        for x, v in expected_values:
            u = dexpr(x) # TODO: Not sure if this works
            if not hasattr(u, '__len__'):
                u = (u,)
            diff = numpy.array(u) - numpy.array(v)
            print diff
            self.assertLess(numpy.dot(diff, diff), 1e-14)

    def test_dolfin_expression_compilation_of_scalar_literal(self):
        # Define some literal ufl expression
        uexpr = as_ufl(3.14)

        # Define expected output from compilation
        expected_lines = ['double s[1];',
                          's[0] = 3.14;',
                          'values[0] = s[0];']

        # Define expected evaluation values: [(x,value), (x,value), ...]
        expected_values = [((0.0,0.0), (3.14,)),
                           ((0.6,0.7), (3.14,)),
                           ]

        # Execute all tests
        self._test_dolfin_expression_compilation(uexpr, expected_lines, expected_values)

    def test_dolfin_expression_compilation_of_vector_literal(self):
        # Define some literal ufl expression
        uexpr = ufl.as_vector((1.23, 7.89))

        # Define expected output from compilation
        expected_lines = ['double s[2];',
                          's[0] = 1.23;',
                          's[1] = 7.89;',
                          'values[0] = s[0];',
                          'values[1] = s[1];']

        # Define expected evaluation values: [(x,value), (x,value), ...]
        expected_values = [((0.0,0.0), (1.23,7.89)),
                           ((0.6,0.7), (1.23,7.89)),
                           ]

        # Execute all tests
        self._test_dolfin_expression_compilation(uexpr, expected_lines, expected_values)

    def test_dolfin_expression_compilation_of_x(self):
        # Define some ufl expression
        x = ufl.triangle.x
        uexpr = 2*x

        # Define expected output from compilation
        expected_lines = ['double s[2];',
                          's[0] = 2 * x[0];',
                          's[1] = 2 * x[1];',
                          'values[0] = s[0];',
                          'values[1] = s[1];']

        # Define expected evaluation values: [(x,value), (x,value), ...]
        expected_values = [((0.0,0.0), (0.0,0.0)),
                           ((0.6,0.7), (1.2,1.4)),
                           ]

        # Execute all tests
        self._test_dolfin_expression_compilation(uexpr, expected_lines, expected_values)

    def test_dolfin_expression_compilation_of_coefficient(self):
        # Define some ufl expression with PyDOLFIN coefficients
        mesh = dolfin.UnitSquare(3,3)
        # Using quadratic element deliberately for accuracy
        V = dolfin.FunctionSpace(mesh, "CG", 2)
        u = dolfin.Function(V)
        u.interpolate(dolfin.Expression("x[0]*x[1]"))
        uexpr = 2*u

        # Define expected output from compilation
        expected_lines = ['double s[1];',
                          'Array<double> v_w0(1);',
                          'w0->eval(v_w0, x);',
                          's[0] = 2 * v_w0[0];',
                          'values[0] = s[0];']

        # Define expected evaluation values: [(x,value), (x,value), ...]
        expected_values = [((0.0,0.0), (0.0,)),
                           ((0.6,0.7), (2*0.6*0.7,)),
                           ]

        # Execute all tests
        self._test_dolfin_expression_compilation(uexpr, expected_lines, expected_values,
                                                 members={'w0':u})

