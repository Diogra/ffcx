"""
Tests of new experimental graph representation of expressions,
intended for code generation stages.
"""

from ufltestcase import UflTestCase
from ufl import *
from uflacs.algorithms.indexing import shape_to_strides, multiindex_to_component, component_to_multiindex, indexing_to_component
from uflacs.algorithms.indexing import map_indexed_arg_components, map_indexed_arg_components2, map_component_tensor_arg_components
from uflacs.algorithms.graph import map_list_tensor_symbols, map_transposed_symbols, get_node_symbols2
from uflacs.algorithms.graph import build_graph, rebuild_expression_from_graph

class GraphAlgorithmTest(UflTestCase):

    def test_shape_to_strides(self):
        self.assertEqual((),       shape_to_strides(()))
        self.assertEqual((1,),     shape_to_strides((3,)))
        self.assertEqual((2,1),    shape_to_strides((3,2)))
        self.assertEqual((4,1),    shape_to_strides((3,4)))
        self.assertEqual((12,4,1), shape_to_strides((6,3,4)))

    def test_multiindex_to_component_to_multiindex(self):
        sh = (2, 3, 5)
        strides = shape_to_strides(sh)
        for i in range(sh[2]):
            for j in range(sh[1]):
                for k in range(sh[0]):
                    index = (k, j, i)
                    c = multiindex_to_component(index, strides)
                    index2 = component_to_multiindex(c, strides)
                    self.assertEqual(index, index2)

    def test_indexing_to_component(self):
        self.assertEqual(0, indexing_to_component(  (), (),   ()))
        self.assertEqual(0, indexing_to_component((0,), (), (2,)))
        self.assertEqual(1, indexing_to_component((1,), (), (2,)))
        self.assertEqual(3, indexing_to_component((1,1), (), (2,2)))
        for i in range(5):
            for j in range(3):
                for k in range(2):
                    self.assertEqual(15*k+5*j+i, indexing_to_component((k,j,i), (), (2,3,5)))
        # TODO: Add free indices to the mix!

    def test_map_indexed_arg_components(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_indexed_arg_components(A[i,j])
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_indexed_arg_components(A[j,i])
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_indexed_arg_components2(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_indexed_arg_components2(A[i,j])
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_indexed_arg_components2(A[j,i])
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_componenttensor_arg_components(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_component_tensor_arg_components(as_tensor(2*A[i,j], (i,j)))
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_component_tensor_arg_components(as_tensor(2*A[i,j], (j,i)))
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_list_tensor_symbols(self):
        U = FiniteElement("CG", cell2D, 1)
        u = Coefficient(U)
        A = as_tensor(((u+1,u+2,u+3),(u**2+1,u**2+2,u**2+3)))
        # Would be nicer to refactor build_graph a bit so we could call map_list_tensor_symbols directly...
        G = build_graph(A, DEBUG=False)
        s1 = list(get_node_symbols2(A, G.e2i, G.V_symbols))
        s2 = [get_node_symbols2(e, G.e2i, G.V_symbols)[0] for e in (u+1,u+2,u+3,u**2+1,u**2+2,u**2+3)]
        self.assertEqual(s1, s2)

    def test_map_transposed_symbols(self):
        W = TensorElement("CG", cell2D, 1)
        w = Coefficient(W)
        A = w.T
        # Would be nicer to refactor build_graph a bit so we could call map_transposed_symbols directly...
        G = build_graph(A, DEBUG=False)
        s1 = list(get_node_symbols2(A, G.e2i, G.V_symbols))
        s2 = list(get_node_symbols2(w, G.e2i, G.V_symbols))
        s2[1], s2[2] = s2[2], s2[1]
        self.assertEqual(s1, s2)

        W = TensorElement("CG", cell3D, 1)
        w = Coefficient(W)
        A = w.T
        # Would be nicer to refactor build_graph a bit so we could call map_transposed_symbols directly...
        G = build_graph(A, DEBUG=False)
        s1 = list(get_node_symbols2(A, G.e2i, G.V_symbols))
        s2 = list(get_node_symbols2(w, G.e2i, G.V_symbols))
        s2[1], s2[2], s2[5], s2[3], s2[6], s2[7] = s2[3], s2[6], s2[7], s2[1], s2[2], s2[5]
        self.assertEqual(s1, s2)

    def test_graph_algorithm(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        expr = u
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 1)
        self.assertEqual(G.total_unique_symbols, 1)

        expr = u**2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 3)
        self.assertEqual(G.total_unique_symbols, 3)

        expr = u**2/2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 4)
        self.assertEqual(G.total_unique_symbols, 4)

        expr = dot(v,v)/2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 5)
        self.assertEqual(G.total_unique_symbols, 5)

        # Testing Indexed
        expr = v[i]*v[i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 2+2+2+1)
        self.assertEqual(G.total_unique_symbols, 2+2+1)

        # Reusing symbols for indexed with different ordering
        # Note that two index sums are created, giving 2+1 symbols
        expr = w[i,j]*w[j,i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 4+4+4+4+2+1)
        self.assertEqual(G.total_unique_symbols, 4+4+2+1)

        # Testing ComponentTensor
        expr = dot(as_vector(2*v[i], i), v)
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 2+1 + 2+2+2 + 1)
        self.assertEqual(G.total_unique_symbols, 2+1 + 2+1)

        expr = dot(v+2*v,v)
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 2+1 + 2+2+2+2 + 1)
        self.assertEqual(G.total_unique_symbols, 2+1 + 2+2 + 1)

        expr = outer(v,v)[i,j]*outer(v,v)[j,i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 21) # 2+4+4+4 + 4+2+1
        self.assertEqual(G.total_unique_symbols, 13) # 2+4+4 + 2+1

    def test_rebuild_expression_from_graph(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        v1 = outer(v,v)[i,j]*outer(v,v)[j,i]
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        #print v1
        #print v2
        # FIXME: Assert something
