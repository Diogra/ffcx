"""
Tests of generic C++ compilation code.
"""

from ufltestcase import UflTestCase

from itertools import izip
from collections import namedtuple
import numpy

import ufl
from ufl.common import product
from ufl.classes import Terminal, Indexed, ComponentTensor, ListTensor, UtilityType, Zero, ScalarValue
from ufl.algorithms.traversal import traverse_terminals, pre_traversal,\
    post_traversal, fast_pre_traversal, fast_post_traversal

def int_array(size):
    return numpy.zeros(size, dtype=int)
def object_array(size):
    # TODO: Any gain in using a numpy array for object lists?
    #return numpy.array(dtype=object)
    return [None]*size

def build_graph(expr, DEBUG=False):
    if DEBUG:
        print "In build_graph:"
        print "expr = ", str(expr)
        print "expr = ", repr(expr)
        print

    # Make empty graph
    class Graph2(object):
        def __init__(self):
            pass
    G = Graph2()

    # Count unique expression nodes
    i = 0
    e2i = {}
    # Terminals first... (TODO: Not really necessary, but nice, or?)
    for e in traverse_terminals(expr):
        if isinstance(e, UtilityType):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1
    # ... then the rest
    for e in fast_post_traversal(expr):
        if isinstance(e, Terminal):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1
    assert len(e2i) == i
    G.nv = i

    # List the nodes
    G.V = object_array(G.nv)
    assert len(G.V) == G.nv
    for e,i in e2i.iteritems():
        G.V[i] = e

    if DEBUG:
        print "V:"
        for i, v in enumerate(G.V):
            print "%d\t%s\t%s" % (i, type(v).__name__, str(v))
        print

    # Compute the node shapes and value dimensions
    G.V_shapes  = object_array(G.nv)
    G.V_sizes   = int_array(G.nv)
    G.V_offsets = int_array(G.nv)
    G.total_value_size = 0
    for i,v in enumerate(G.V):
        # Regular shape
        sh = v.shape()
        nsh = product(sh)

        # Index "shape"
        idims = v.index_dimensions()
        indices = v.free_indices()
        if indices:
            indices = sorted(indices, key=lambda x: x.count())
            ish = tuple(idims[idx] for idx in indices)
            nish = product(ish)
        else:
            ish = ()
            nish = 1

        # "Total" shape
        shape = sh + ish
        nshape = nsh * nish
        assert nshape == product(shape)

        G.V_shapes[i] = shape
        G.V_sizes[i] = nshape
        G.V_offsets[i] = G.total_value_size
        G.total_value_size += nshape

    if DEBUG:
        print
        print "V_shapes", G.V_shapes
        print "V_sizes", G.V_sizes
        print "V_offsets", G.V_offsets
        print "total_value_size", G.total_value_size
        print

    # Mark values with symbols
    G.V_symbols = int_array(G.total_value_size)

    def new_symbols(n):
        o = new_symbols.symbol_count
        new_symbols.symbol_count += n
        return list(xrange(o, o+n))
    new_symbols.symbol_count = 0

    for i in xrange(G.nv):
        v = G.V[i]
        sh = G.V_shapes[i]
        n = G.V_sizes[i]
        o = G.V_offsets[i]

        if isinstance(v, Indexed):
            Aii = v
            A, ii = Aii.operands()
            j = e2i[A]
            A_o = G.V_offsets[j]
            A_n = G.V_sizes[j]
            A_symbols = G.V_symbols[A_o:A_o+A_n]

            if 0:
                symbols = FIXME # Map symbols to A_symbols, need to track index sorting
            else:
                symbols = new_symbols(n)

        elif isinstance(v, ComponentTensor):
            A = v
            Aii, ii = A.operands()
            j = e2i[Aii]

            Aii_o = G.V_offsets[j]
            Aii_n = G.V_sizes[j]
            Aii_symbols = G.V_symbols[Aii_o:Aii_o+Aii_n]

            if 0:
                symbols = FIXME # Map symbols to A_symbols, need to track index sorting
            else:
                symbols = new_symbols(n)

        elif isinstance(v, ListTensor):
            A = v
            rows = A.operands()
            js = [e2i[row] for row in rows]

            if 0:
                symbols = FIXME # Fetch symbols from argument, need mapping between extended shapes
            else:
                symbols = new_symbols(n)

        else:
            # Simply create one new symbol for each scalar component:
            symbols = new_symbols(n)
            # TODO: How/where to handle literals? Maybe use negative symbol indices?
            # TODO: How/where to handle derivatives? Probably want separate symbols for those.
            # TODO: Ignoring symmetries, reuse, etc. at this point

        G.V_symbols[o:o+n] = symbols

    if DEBUG:
        print "symbols:"
        for i, o in enumerate(G.V_offsets):
            print "%d:\t%s" % (i, G.V_symbols[o:o+G.V_sizes[i]])
        print

    return G

def shape_to_strides(sh):
    n = len(sh)
    if not n:
        return ()
    strides = [None]*n
    strides[n-1] = 1
    for i in xrange(n-1, 0, -1):
        strides[i-1] = strides[i]*sh[i]
    return tuple(strides)

def multiindex_to_component(ii, strides):
    return sum(i*s for i,s in izip(ii,strides))

def component_to_multiindex(c, strides):
    ii = []
    rest = c
    for s in strides:
        k = rest // s
        ii.append(k)
        rest -= k*s
    return tuple(ii)

def indexing_to_component(ii, ind, sh):
    strides = shape_to_strides(sh)
    # TODO: Handle ind
    assert not ind

    index = ii
    c = multiindex_to_component(index, strides)
    return c

class GraphAlgorithmTest(UflTestCase):

    def test_shape_to_strides(self):
        self.assertEqual((), shape_to_strides(()))
        self.assertEqual((1,), shape_to_strides((3,)))
        self.assertEqual((2,1), shape_to_strides((3,2)))
        self.assertEqual((4,1), shape_to_strides((3,4)))
        self.assertEqual((12,4,1), shape_to_strides((6,3,4)))

    def test_multiindex_to_component_to_multiindex(self):
        sh = (2, 3, 5)
        strides = shape_to_strides(sh)
        for i in range(sh[2]):
            for j in range(sh[1]):
                for k in range(sh[0]):
                    index = (k, j, i)
                    c = multiindex_to_component(index, strides)
                    index2 = component_to_multiindex(c, strides)
                    self.assertEqual(index, index2)

    def test_indexing_to_component(self):
        self.assertEqual(0, indexing_to_component(  (), (),   ()))
        self.assertEqual(0, indexing_to_component((0,), (), (2,)))
        self.assertEqual(1, indexing_to_component((1,), (), (2,)))
        self.assertEqual(3, indexing_to_component((1,1), (), (2,2)))
        for i in range(5):
            for j in range(3):
                for k in range(2):
                    self.assertEqual(15*k+5*j+i, indexing_to_component((k,j,i), (), (2,3,5)))

        # TODO: Add free indices to the mix!

    def test_graph_algorithm(self):
        from ufl import cell2D, FiniteElement, VectorElement, Coefficient, dot, i, dx
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)

        expr = u
        G = build_graph(expr, DEBUG=1)
        self.assertEqual(G.total_value_size, 1)

        expr = u**2
        G = build_graph(expr, DEBUG=1)
        self.assertEqual(G.total_value_size, 3)

        expr = u**2/2
        G = build_graph(expr, DEBUG=1)
        self.assertEqual(G.total_value_size, 4)

        expr = dot(v,v)/2
        G = build_graph(expr, DEBUG=1)
        self.assertEqual(G.total_value_size, 5)

        expr = dot(v+2*v,v)/2
        G = build_graph(expr, DEBUG=1)
        self.assertEqual(G.total_value_size, 5)

        expr = v[i]*v[i]/2
        G = build_graph(expr, DEBUG=1)
        self.assertEqual(G.total_value_size, 9)

