#!/usr/bin/env python
"""
Tests of new experimental graph representation of expressions,
intended for code generation stages.
"""

from ufltestcase import UflTestCase
from ufl import *
from ufl.common import product
from ufl.permutation import compute_indices

from uflacs.algorithms.indexing import (shape_to_strides, multiindex_to_component,
                                        component_to_multiindex, indexing_to_component)
from uflacs.algorithms.indexing import (map_indexed_arg_components,
                                        map_indexed_arg_components2,
                                        map_component_tensor_arg_components)
from uflacs.algorithms.graph_symbols import (map_list_tensor_symbols,
                                             map_transposed_symbols, get_node_symbols)
from uflacs.algorithms.graph import build_graph, rebuild_expression_from_graph
from uflacs.algorithms.graph_rebuild import rebuild_scalar_e2i
from uflacs.algorithms.graph_ssa import (compute_dependencies,
                                         mark_active,
                                         mark_partitions,
                                         compute_dependency_count,
                                         invert_dependencies,
                                         default_cache_score_policy,
                                         compute_cache_scores,
                                         allocate_registers)


class BasicShapesAndIndexingTest(UflTestCase):

    def test_shape_to_strides(self):
        self.assertEqual((),       shape_to_strides(()))
        self.assertEqual((1,),     shape_to_strides((3,)))
        self.assertEqual((2,1),    shape_to_strides((3,2)))
        self.assertEqual((4,1),    shape_to_strides((3,4)))
        self.assertEqual((12,4,1), shape_to_strides((6,3,4)))

    def test_multiindex_to_component_to_multiindex(self):
        sh = (2, 3, 5)
        strides = shape_to_strides(sh)
        for i in range(sh[2]):
            for j in range(sh[1]):
                for k in range(sh[0]):
                    index = (k, j, i)
                    c = multiindex_to_component(index, strides)
                    index2 = component_to_multiindex(c, strides)
                    self.assertEqual(index, index2)

    def test_indexing_to_component(self):
        self.assertEqual(0, indexing_to_component(  (), (),   ()))
        self.assertEqual(0, indexing_to_component((0,), (), (2,)))
        self.assertEqual(1, indexing_to_component((1,), (), (2,)))
        self.assertEqual(3, indexing_to_component((1,1), (), (2,2)))
        for i in range(5):
            for j in range(3):
                for k in range(2):
                    self.assertEqual(15*k+5*j+i, indexing_to_component((k,j,i), (), (2,3,5)))
        # TODO: Add free indices to the mix!

class UflShapesAndIndexingTest(UflTestCase):

    def test_map_indexed_arg_components(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_indexed_arg_components(A[i,j])
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_indexed_arg_components(A[j,i])
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_indexed_arg_components2(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_indexed_arg_components2(A[i,j])
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_indexed_arg_components2(A[j,i])
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_componenttensor_arg_components(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_component_tensor_arg_components(as_tensor(2*A[i,j], (i,j)))
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_component_tensor_arg_components(as_tensor(2*A[i,j], (j,i)))
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_list_tensor_symbols(self):
        U = FiniteElement("CG", cell2D, 1)
        u = Coefficient(U)
        A = as_tensor(((u+1,u+2,u+3),(u**2+1,u**2+2,u**2+3)))
        # Would be nicer to refactor build_graph a bit so we could call map_list_tensor_symbols directly...
        G = build_graph(A, DEBUG=False)
        s1 = list(get_node_symbols(A, G.e2i, G.V_symbols))
        s2 = [get_node_symbols(e, G.e2i, G.V_symbols)[0] for e in (u+1,u+2,u+3,u**2+1,u**2+2,u**2+3)]
        self.assertEqual(s1, s2)

    def test_map_transposed_symbols(self):
        W = TensorElement("CG", cell2D, 1)
        w = Coefficient(W)
        A = w.T
        # Would be nicer to refactor build_graph a bit so we could call map_transposed_symbols directly...
        G = build_graph(A, DEBUG=False)
        s1 = list(get_node_symbols(A, G.e2i, G.V_symbols))
        s2 = list(get_node_symbols(w, G.e2i, G.V_symbols))
        s2[1], s2[2] = s2[2], s2[1]
        self.assertEqual(s1, s2)

        W = TensorElement("CG", cell3D, 1)
        w = Coefficient(W)
        A = w.T
        # Would be nicer to refactor build_graph a bit so we could call map_transposed_symbols directly...
        G = build_graph(A, DEBUG=False)
        s1 = list(get_node_symbols(A, G.e2i, G.V_symbols))
        s2 = list(get_node_symbols(w, G.e2i, G.V_symbols))
        s2[1], s2[2], s2[5], s2[3], s2[6], s2[7] = s2[3], s2[6], s2[7], s2[1], s2[2], s2[5]
        self.assertEqual(s1, s2)

class GraphAlgorithmTest(UflTestCase):

    def test_graph_algorithm_allocates_correct_number_of_symbols(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        expr = u
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 1)
        self.assertEqual(G.total_unique_symbols, 1)

        expr = u**2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 3)
        self.assertEqual(G.total_unique_symbols, 3)

        expr = u**2/2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 4)
        self.assertEqual(G.total_unique_symbols, 4)

        expr = dot(v,v)/2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 5)
        self.assertEqual(G.total_unique_symbols, 5)

        # Testing Indexed
        expr = v[i]*v[i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 2+2+2+1)
        self.assertEqual(G.total_unique_symbols, 2+2+1)

        # Reusing symbols for indexed with different ordering
        # Note that two index sums are created, giving 2+1 symbols
        expr = w[i,j]*w[j,i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 4+4+4+4+2+1)
        self.assertEqual(G.total_unique_symbols, 4+4+2+1)

        # Testing ComponentTensor
        expr = dot(as_vector(2*v[i], i), v)
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 2+1 + 2+2+2 + 1)
        self.assertEqual(G.total_unique_symbols, 2+1 + 2+1)

        expr = dot(v+2*v,v)
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 2+1 + 2+2+2+2 + 1)
        self.assertEqual(G.total_unique_symbols, 2+1 + 2+2 + 1)

        expr = outer(v,v)[i,j]*outer(v,v)[j,i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 21) # 2+4+4+4 + 4+2+1
        self.assertEqual(G.total_unique_symbols, 13) # 2+4+4 + 2+1

    def test_rebuild_expression_from_graph_basic_scalar_expressions(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        # ... Literals are reproduced
        literals = [as_ufl(0), as_ufl(1), as_ufl(3.14)]
        for v1 in literals:
            G = build_graph(v1)
            v2 = rebuild_expression_from_graph(G)
            self.assertEqual(v1, v2)

        v1 = u
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        self.assertEqual(v1, v2)

        # ... Simple operators are reproduced
        for v1 in [2+u, u+u, u*u, u*2, u**2, u**u, u/u, sin(u)]:
            G = build_graph(v1)
            v2 = rebuild_expression_from_graph(G)
            self.assertEqual(v1, v2)

    def test_rebuild_expression_from_graph_on_products_with_indices(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)
        i, j, k, l = indices(4)

        # Test fixed index
        fixed = [u*v[0], v[1]*v[0], w[0,1]*w[0,0]]
        for v1 in fixed:
            G = build_graph(v1)
            v2 = rebuild_expression_from_graph(G)
            self.assertEqual(v1, v2)

        # Test simple repeated index
        v1 = v[i]*v[i]
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = v[0]**2 + v[1]**2
        self.assertEqual(ve, v2)

        # Test double repeated index
        v1 = w[i,j]*w[j,i]
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = (w[1,1]**2 + w[1,0]*w[0,1]) + (w[0,1]*w[1,0] + w[0,0]**2)
        if 0:
            print
            print v1
            print ve
            print v2
            print
        self.assertEqual(ve, v2)

        # Test mix of repeated and non-repeated index
        v1 = (w[i,j]*w[j,0] + v[i])*v[i]
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = ( (w[0,0]*w[0,0] + w[0,1]*w[1,0] + v[0])*v[0]
              +(w[1,0]*w[0,0] + w[1,1]*w[1,0] + v[1])*v[1])
        self.assertEqual(ve, v2)

    def test_rebuild_expression_from_graph_basic_tensor_expressions(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        v1 = v
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        self.assertEqual(as_vector((v1[0],v1[1])), v2)

        v1 = w
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        self.assertEqual(as_vector((v1[0,0],v1[0,1],v1[1,0],v1[1,1])), v2)

        v1 = v+v
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = as_vector((2*v[0],2*v[1]))
        if 0:
            print
            print ve
            print v2
            print
        self.assertEqual(ve, v2)

        v1 = w+w
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = as_vector((2*w[0,0],2*w[0,1],2*w[1,0],2*w[1,1]))
        self.assertEqual(ve, v2)

        v1 = u*v
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = as_vector((u*v[0],u*v[1]))
        self.assertEqual(ve, v2)

        v1 = u*w
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = as_vector((u*w[0,0],u*w[0,1],u*w[1,0],u*w[1,1]))
        self.assertEqual(ve, v2)

        v1 = v[i]*v[i]
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = v[0]*v[0] + v[1]*v[1]
        self.assertEqual(ve, v2)

        v1 = w[i,j]*w[j,i]
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = (w[0,0]*w[0,0] + w[0,1]*w[1,0]) \
           + (w[1,0]*w[0,1] + w[1,1]*w[1,1])
        self.assertEqual(ve, v2)

    # Compounds not implemented, not expecting to do this anytime soon
    def xtest_rebuild_expression_from_graph_on_compounds(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        v1 = dot(v,v)
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)

        v1 = outer(v,v)
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)

        v1 = outer(v,v)[i,j]*outer(v,v)[j,i]
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        #print v1
        #print v2
        # FIXME: Assert something

    def test_flattening_of_tensor_valued_expression_symbols(self):
        #from uflacs.algorithms.graph import foo
        def flatten_expression_symbols(v, vsyms, opsyms):
            sh = v.shape()
            if sh == ():
                assert len(vsyms) == 1
                if not opsyms:
                    res = [(v, vsyms[0], ())]
                else:
                    assert len(opsyms[0]) == 1
                    res = [(v, vsyms[0], tuple(syms[0] for syms in opsyms))]
            else:
                res = []
                if isinstance(v, ufl.classes.Sum):
                    for i in range(len(vsyms)):
                        u = None # sum of component i for syms in opsyms
                        res += (u, vsyms[i], tuple(syms[i] for syms in opsyms))
            return res

        v = as_ufl(1)
        vsyms = (0,)
        opsyms = ()
        res = flatten_expression_symbols(v, vsyms, opsyms)
        self.assertEqual(res, [(v, 0, ())])


class SSAManipulationTest(UflTestCase):

    def test_dependency_construction(self):
        cell = cell2D
        d = cell.d
        x = cell.x
        n = cell.n

        U = FiniteElement("CG", cell, 1)
        V = VectorElement("CG", cell, 1)
        W = TensorElement("CG", cell, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        i, j, k, l = indices(4)

        expressions = [as_ufl(1),
                       as_ufl(3.14),
                       as_ufl(0),
                       x[0],
                       n[0],
                       u,
                       v[0],
                       v[1],
                       w[0,1],
                       w[0,0]+w[1,1],
                       (2*v+w[1,:])[i]*v[i],
                       ]

        for expr in expressions:
            G = build_graph(expr)
            ne2i, NV, W, terminals, nvs = rebuild_scalar_e2i(G)

            e2i = ne2i
            V = NV

            dependencies = compute_dependencies(e2i, V)

            max_symbol = len(V)
            targets = (max_symbol-1,)
            active, num_active = mark_active(max_symbol, dependencies, targets)

            partitions = mark_partitions(V, active, dependencies, {})

            depcount = compute_dependency_count(dependencies)

            inverse_dependencies = invert_dependencies(dependencies, depcount)

            scores = compute_cache_scores(V,
                                          active,
                                          dependencies,
                                          inverse_dependencies,
                                          partitions,
                                          cache_score_policy=default_cache_score_policy)

            max_registers = 4
            score_threshold = 1
            allocations = allocate_registers(active, partitions, targets,
                                             scores, max_registers, score_threshold)

            if 1:
                print
                print "====== expr                \n", expr
                print "====== V                   \n", '\n'.join(map(str,V))
                print "====== dependencies        \n", dependencies
                print "====== active              \n", active
                print "====== partitions          \n", partitions
                print "====== depcount            \n", depcount
                print "====== inverse_dependencies\n", inverse_dependencies
                print "====== scores              \n", scores
                print "====== allocations         \n", allocations
                print

if __name__ == '__main__':
    import unittest
    unittest.main()

