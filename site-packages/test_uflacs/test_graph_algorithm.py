"""
Tests of new experimental graph representation of expressions,
intended for code generation stages.
"""

from ufltestcase import UflTestCase
from ufl import *
from ufl.common import product
from ufl.permutation import compute_indices

from uflacs.algorithms.indexing import (shape_to_strides, multiindex_to_component,
                                        component_to_multiindex, indexing_to_component)
from uflacs.algorithms.indexing import (map_indexed_arg_components,
                                        map_indexed_arg_components2,
                                        map_component_tensor_arg_components)
from uflacs.algorithms.graph_symbols import (map_list_tensor_symbols,
                                             map_transposed_symbols, get_node_symbols)
from uflacs.algorithms.graph import build_graph, rebuild_expression_from_graph

class BasicShapesAndIndexingTest(UflTestCase):

    def test_shape_to_strides(self):
        self.assertEqual((),       shape_to_strides(()))
        self.assertEqual((1,),     shape_to_strides((3,)))
        self.assertEqual((2,1),    shape_to_strides((3,2)))
        self.assertEqual((4,1),    shape_to_strides((3,4)))
        self.assertEqual((12,4,1), shape_to_strides((6,3,4)))

    def test_multiindex_to_component_to_multiindex(self):
        sh = (2, 3, 5)
        strides = shape_to_strides(sh)
        for i in range(sh[2]):
            for j in range(sh[1]):
                for k in range(sh[0]):
                    index = (k, j, i)
                    c = multiindex_to_component(index, strides)
                    index2 = component_to_multiindex(c, strides)
                    self.assertEqual(index, index2)

    def test_indexing_to_component(self):
        self.assertEqual(0, indexing_to_component(  (), (),   ()))
        self.assertEqual(0, indexing_to_component((0,), (), (2,)))
        self.assertEqual(1, indexing_to_component((1,), (), (2,)))
        self.assertEqual(3, indexing_to_component((1,1), (), (2,2)))
        for i in range(5):
            for j in range(3):
                for k in range(2):
                    self.assertEqual(15*k+5*j+i, indexing_to_component((k,j,i), (), (2,3,5)))
        # TODO: Add free indices to the mix!

class UflShapesAndIndexingTest(UflTestCase):

    def test_map_indexed_arg_components(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_indexed_arg_components(A[i,j])
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_indexed_arg_components(A[j,i])
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_indexed_arg_components2(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_indexed_arg_components2(A[i,j])
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_indexed_arg_components2(A[j,i])
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_componenttensor_arg_components(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_component_tensor_arg_components(as_tensor(2*A[i,j], (i,j)))
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_component_tensor_arg_components(as_tensor(2*A[i,j], (j,i)))
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_list_tensor_symbols(self):
        U = FiniteElement("CG", cell2D, 1)
        u = Coefficient(U)
        A = as_tensor(((u+1,u+2,u+3),(u**2+1,u**2+2,u**2+3)))
        # Would be nicer to refactor build_graph a bit so we could call map_list_tensor_symbols directly...
        G = build_graph(A, DEBUG=False)
        s1 = list(get_node_symbols(A, G.e2i, G.V_symbols))
        s2 = [get_node_symbols(e, G.e2i, G.V_symbols)[0] for e in (u+1,u+2,u+3,u**2+1,u**2+2,u**2+3)]
        self.assertEqual(s1, s2)

    def test_map_transposed_symbols(self):
        W = TensorElement("CG", cell2D, 1)
        w = Coefficient(W)
        A = w.T
        # Would be nicer to refactor build_graph a bit so we could call map_transposed_symbols directly...
        G = build_graph(A, DEBUG=False)
        s1 = list(get_node_symbols(A, G.e2i, G.V_symbols))
        s2 = list(get_node_symbols(w, G.e2i, G.V_symbols))
        s2[1], s2[2] = s2[2], s2[1]
        self.assertEqual(s1, s2)

        W = TensorElement("CG", cell3D, 1)
        w = Coefficient(W)
        A = w.T
        # Would be nicer to refactor build_graph a bit so we could call map_transposed_symbols directly...
        G = build_graph(A, DEBUG=False)
        s1 = list(get_node_symbols(A, G.e2i, G.V_symbols))
        s2 = list(get_node_symbols(w, G.e2i, G.V_symbols))
        s2[1], s2[2], s2[5], s2[3], s2[6], s2[7] = s2[3], s2[6], s2[7], s2[1], s2[2], s2[5]
        self.assertEqual(s1, s2)

class GraphAlgorithmTest(UflTestCase):

    def test_graph_algorithm_allocates_correct_number_of_symbols(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        expr = u
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 1)
        self.assertEqual(G.total_unique_symbols, 1)

        expr = u**2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 3)
        self.assertEqual(G.total_unique_symbols, 3)

        expr = u**2/2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 4)
        self.assertEqual(G.total_unique_symbols, 4)

        expr = dot(v,v)/2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 5)
        self.assertEqual(G.total_unique_symbols, 5)

        # Testing Indexed
        expr = v[i]*v[i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 2+2+2+1)
        self.assertEqual(G.total_unique_symbols, 2+2+1)

        # Reusing symbols for indexed with different ordering
        # Note that two index sums are created, giving 2+1 symbols
        expr = w[i,j]*w[j,i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 4+4+4+4+2+1)
        self.assertEqual(G.total_unique_symbols, 4+4+2+1)

        # Testing ComponentTensor
        expr = dot(as_vector(2*v[i], i), v)
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 2+1 + 2+2+2 + 1)
        self.assertEqual(G.total_unique_symbols, 2+1 + 2+1)

        expr = dot(v+2*v,v)
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 2+1 + 2+2+2+2 + 1)
        self.assertEqual(G.total_unique_symbols, 2+1 + 2+2 + 1)

        expr = outer(v,v)[i,j]*outer(v,v)[j,i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.V_symbols.num_elements, 21) # 2+4+4+4 + 4+2+1
        self.assertEqual(G.total_unique_symbols, 13) # 2+4+4 + 2+1

    def test_rebuild_expression_from_graph_basic_scalar_expressions(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        # ... Literals are reproduced
        literals = [as_ufl(0), as_ufl(1), as_ufl(3.14)]
        for v1 in literals:
            G = build_graph(v1)
            v2 = rebuild_expression_from_graph(G)
            self.assertEqual(v1, v2)

        v1 = u
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        self.assertEqual(v1, v2)

        # ... Simple operators are reproduced
        for v1 in [2+u, u+u, u*u, u*2, u**2, u**u, u/u, sin(u)]:
            G = build_graph(v1)
            v2 = rebuild_expression_from_graph(G)
            self.assertEqual(v1, v2)

    def test_rebuild_expression_from_graph_basic_tensor_expressions(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        v1 = v
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        self.assertEqual(as_vector((v1[0],v1[1])), v2)

        v1 = w
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        self.assertEqual(as_vector((v1[0,0],v1[0,1],v1[1,0],v1[1,1])), v2)

        v1 = v+v
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = as_vector((2*v[0],2*v[1]))
        self.assertEqual(ve, v2)

        v1 = w+w
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = as_vector((2*w[0,0],2*w[0,1],2*w[1,0],2*w[1,1]))
        self.assertEqual(ve, v2)

        v1 = u*v
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = as_vector((u*v[0],u*v[1]))
        self.assertEqual(ve, v2)

        v1 = u*w
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)
        ve = as_vector((u*w[0,0],u*w[0,1],u*w[1,0],u*w[1,1]))
        self.assertEqual(ve, v2)

    def test_rebuild_expression_from_graph(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        v1 = dot(v,v)
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)

        v1 = outer(v,v)
        G = build_graph(v1)
        v2 = rebuild_expression_from_graph(G)

        if 1: # Fails because of missing IndexSum handling
            v1 = outer(v,v)[i,j]*outer(v,v)[j,i]
            G = build_graph(v1)
            v2 = rebuild_expression_from_graph(G)
        #print v1
        #print v2
        # FIXME: Assert something

    def test_flattening_of_tensor_valued_expression_symbols(self):
        #from uflacs.algorithms.graph import foo
        def flatten_expression_symbols(v, vsyms, opsyms):
            sh = v.shape()
            if sh == ():
                assert len(vsyms) == 1
                if not opsyms:
                    res = [(v, vsyms[0], ())]
                else:
                    assert len(opsyms[0]) == 1
                    res = [(v, vsyms[0], tuple(syms[0] for syms in opsyms))]
            else:
                res = []
                if isinstance(v, ufl.classes.Sum):
                    for i in range(len(vsyms)):
                        u = None # sum of component i for syms in opsyms
                        res += (u, vsyms[i], tuple(syms[i] for syms in opsyms))
            return res

        v = as_ufl(1)
        vsyms = (0,)
        opsyms = ()
        res = flatten_expression_symbols(v, vsyms, opsyms)
        self.assertEqual(res, [(v, 0, ())])
