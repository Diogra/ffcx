"""
Tests of generic C++ compilation code.
"""

from ufltestcase import UflTestCase

from itertools import izip
from collections import namedtuple
import numpy

import ufl
from ufl.common import product
from ufl.classes import Terminal, Indexed, ComponentTensor, ListTensor, UtilityType, Zero, ScalarValue, Index
from ufl.algorithms.traversal import traverse_terminals, pre_traversal,\
    post_traversal, fast_pre_traversal, fast_post_traversal
from ufl.permutation import compute_indices

from ufl import cell2D, FiniteElement, VectorElement, TensorElement,\
    Coefficient, indices, i, j,\
    dot, inner, outer,\
    as_vector, as_tensor,\
    dx

def int_array(size):
    return numpy.zeros(size, dtype=int)

def object_array(size):
    # TODO: Any gain in using a numpy array for object lists?
    #return numpy.array(dtype=object)
    return [None]*size

def build_graph(expr, DEBUG=False):
    if DEBUG:
        print "In build_graph:"
        print "expr = ", str(expr)
        print "expr = ", repr(expr)
        print

    # Make empty graph
    class Graph2(object):
        def __init__(self):
            pass
    G = Graph2()

    # Count unique expression nodes
    i = 0
    e2i = {}
    # Terminals first... (TODO: Not really necessary, but nice, or?)
    for e in traverse_terminals(expr):
        if isinstance(e, UtilityType):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1
    # ... then the rest
    for e in fast_post_traversal(expr):
        if isinstance(e, Terminal):
            continue
        if e not in e2i:
            e2i[e] = i
            i += 1
    assert len(e2i) == i
    G.nv = i

    # List the nodes
    G.V = object_array(G.nv)
    assert len(G.V) == G.nv
    for e,i in e2i.iteritems():
        G.V[i] = e

    if DEBUG:
        print "V:"
        for i, v in enumerate(G.V):
            print "%d\t%s\t%s" % (i, type(v).__name__, str(v))
        print

    # Compute the node shapes and value dimensions
    G.V_shapes  = object_array(G.nv)
    G.V_sizes   = int_array(G.nv)
    G.V_offsets = int_array(G.nv)
    G.total_value_size = 0
    for i,v in enumerate(G.V):
        # Regular shape
        sh = v.shape()
        nsh = product(sh)

        # Index "shape"
        idims = v.index_dimensions()
        indices = v.free_indices()
        if indices:
            indices = sorted(indices, key=lambda x: x.count())
            ish = tuple(idims[idx] for idx in indices)
            nish = product(ish)
        else:
            ish = ()
            nish = 1

        # "Total" shape
        shape = sh + ish
        nshape = nsh * nish
        assert nshape == product(shape)

        G.V_shapes[i] = shape
        G.V_sizes[i] = nshape
        G.V_offsets[i] = G.total_value_size
        G.total_value_size += nshape

    if DEBUG:
        print
        print "V_shapes", G.V_shapes
        print "V_sizes", G.V_sizes
        print "V_offsets", G.V_offsets
        print "total_value_size", G.total_value_size
        print

    # Mark values with symbols
    G.V_symbols = int_array(G.total_value_size)

    def new_symbols(n):
        o = new_symbols.symbol_count
        new_symbols.symbol_count += n
        return list(xrange(o, o+n))
    new_symbols.symbol_count = 0

    for i in xrange(G.nv):
        v = G.V[i]
        sh = G.V_shapes[i]
        n = G.V_sizes[i]
        o = G.V_offsets[i]

        if isinstance(v, Indexed):
            # Reuse symbols of arg A for Aii
            Aii = v
            A = Aii.operands()[0]

            # Get symbols of argument A
            j = e2i[A]
            A_o = G.V_offsets[j]
            A_n = G.V_sizes[j]
            A_symbols = G.V_symbols[A_o:A_o+A_n]

            # Map A_symbols to Aii_symbols
            d = map_indexed_arg_components(Aii)
            symbols = [A_symbols[k] for k in d]

        elif isinstance(v, ComponentTensor):
            # Reuse symbols of arg Aii for A
            A = v
            Aii = A.operands()[0]

            # Get symbols of argument Aii
            j = e2i[Aii]
            Aii_o = G.V_offsets[j]
            Aii_n = G.V_sizes[j]
            Aii_symbols = G.V_symbols[Aii_o:Aii_o+Aii_n]

            if 1:
                # Map A_symbols to Aii_symbols
                d = map_component_tensor_arg_components(A)
                symbols = [Aii_symbols[k] for k in d]
            else:
                symbols = new_symbols(n)

        elif isinstance(v, ListTensor):
            A = v
            rows = A.operands()
            js = [e2i[row] for row in rows]

            if 0:
                symbols = FIXME # Fetch symbols from argument, need mapping between extended shapes
            else:
                symbols = new_symbols(n)

        else:
            # Simply create one new symbol for each scalar component:
            symbols = new_symbols(n)
            # TODO: How/where to handle literals? Maybe use negative symbol indices?
            # TODO: How/where to handle derivatives? Probably want separate symbols for those.
            # TODO: Ignoring symmetries, reuse, etc. at this point

        G.V_symbols[o:o+n] = symbols

    G.total_unique_symbols = new_symbols.symbol_count

    if DEBUG:
        print "symbols:"
        for i, o in enumerate(G.V_offsets):
            print "%d:\t%s" % (i, G.V_symbols[o:o+G.V_sizes[i]])
        print

    return G

def shape_to_strides(sh):
    n = len(sh)
    if not n:
        return ()
    strides = [None]*n
    strides[n-1] = 1
    for i in xrange(n-1, 0, -1):
        strides[i-1] = strides[i]*sh[i]
    return tuple(strides)

def multiindex_to_component(ii, strides):
    return sum(i*s for i,s in izip(ii,strides))

def component_to_multiindex(c, strides):
    ii = []
    rest = c
    for s in strides:
        k = rest // s
        ii.append(k)
        rest -= k*s
    return tuple(ii)

def indexing_to_component(ii, ind, sh):
    strides = shape_to_strides(sh)
    # TODO: Handle ind
    assert not ind

    index = ii
    c = multiindex_to_component(index, strides)
    return c

def map_indexed_to_arg_components(indexed):
    e1 = indexed
    assert isinstance(e1, Indexed)
    A1, mi1 = e1.operands()
    e2 = A1

    # Compute index shape
    ind1 = sorted(e1.free_indices(), key=lambda x: x.count())
    ind2 = sorted(e2.free_indices(), key=lambda x: x.count())
    idims1 = e1.index_dimensions()
    idims2 = e2.index_dimensions()
    ish1 = tuple(idims1[i] for i in ind1)
    ish2 = tuple(idims2[i] for i in ind2)

    # Compute regular and total shape
    sh1 = e1.shape()
    sh2 = e2.shape()
    tsh1 = sh1 + ish1
    tsh2 = sh2 + ish2
    str1 = shape_to_strides(tsh1)
    str2 = shape_to_strides(tsh2)
    assert product(tsh1) == product(tsh2)
    assert (not sh1) and (ish1) and (sh2) and (not ish2)

    sh_to_ind_map = [ind1.index(i) for i in mi1 if isinstance(i, Index)]
    comp1 = []
    comp2 = []
    for p2 in compute_indices(sh2):
        p1 = [None]*len(p2)
        for j, p in enumerate(p2):
            p1[sh_to_ind_map[j]] = p
        c1 = multiindex_to_component(p1, str1)
        c2 = multiindex_to_component(p2, str2)
        print c1, c2
        comp1.append(c1)
        comp2.append(c2)
    return tuple(comp1), tuple(comp2)
def map_indexed_arg_components2(Aii): # TODO: Remove when the new version is better tested
    c1, c2 = map_indexed_to_arg_components(Aii)
    d = [None]*len(c1)
    for k in range(len(c1)):
        d[c1[k]] = k
    return d


def map_indexed_arg_components4(indexed):
    assert isinstance(indexed, Indexed)
    e1 = indexed
    e2, mi = e1.operands()

    # Compute index shape
    ind1 = sorted(e1.free_indices(), key=lambda x: x.count())
    ind2 = sorted(e2.free_indices(), key=lambda x: x.count())
    idims1 = e1.index_dimensions()
    idims2 = e2.index_dimensions()
    ish1 = tuple(idims1[i] for i in ind1)
    ish2 = tuple(idims2[i] for i in ind2)

    # Compute regular and total shape
    sh1 = e1.shape()
    sh2 = e2.shape()
    tsh1 = sh1 + ish1
    tsh2 = sh2 + ish2
    str1 = shape_to_strides(tsh1)
    #str2 = shape_to_strides(tsh2)
    assert product(tsh1) == product(tsh2)
    assert (not sh1) and (ish1) and (sh2) and (not ish2)

    # Build map from ind1/ish1 position to mi position
    mi = [i for i in mi if isinstance(i, Index)]
    nmi = len(mi)
    ind1_to_mi_map = [None]*nmi
    for k in xrange(nmi):
        ind1_to_mi_map[ind1.index(mi[k])] = k

    # Build map from flattened e1 component to flattened e2 component
    indices2 = compute_indices(sh2)
    ni = len(indices2)
    d1 = [None]*ni
    d2 = [None]*ni
    for c2, p2 in enumerate(indices2):
        p1 = [p2[k] for k in ind1_to_mi_map]
        c1 = multiindex_to_component(p1, str1)
        d1[c1] = c2
        d2[c2] = c1
    assert d1 == d2
    return d1

def map_component_tensor_arg_components4(component_tensor):
    assert isinstance(component_tensor, ComponentTensor)
    e2 = component_tensor
    e1, mi = e2.operands()

    # Compute index shape
    ind1 = sorted(e1.free_indices(), key=lambda x: x.count())
    ind2 = sorted(e2.free_indices(), key=lambda x: x.count())
    idims1 = e1.index_dimensions()
    idims2 = e2.index_dimensions()
    ish1 = tuple(idims1[i] for i in ind1)
    ish2 = tuple(idims2[i] for i in ind2)

    # Compute regular and total shape
    sh1 = e1.shape()
    sh2 = e2.shape()
    tsh1 = sh1 + ish1
    tsh2 = sh2 + ish2
    str1 = shape_to_strides(tsh1)
    #str2 = shape_to_strides(tsh2)
    assert product(tsh1) == product(tsh2)
    assert (not sh1) and (ish1) and (sh2) and (not ish2)

    # Build map from ind1/ish1 position to mi position
    mi = [i for i in mi if isinstance(i, Index)]
    nmi = len(mi)
    ind1_to_mi_map = [None]*nmi
    for k in xrange(nmi):
        ind1_to_mi_map[ind1.index(mi[k])] = k

    # Build map from flattened e1 component to flattened e2 component
    indices2 = compute_indices(sh2)
    ni = len(indices2)
    d1 = [None]*ni
    d2 = [None]*ni
    for c2, p2 in enumerate(indices2):
        p1 = [p2[k] for k in ind1_to_mi_map]
        c1 = multiindex_to_component(p1, str1)
        d1[c1] = c2
        d2[c2] = c1
    assert d1 == d2
    return d2


def map_indexed_arg_components(indexed):
    assert isinstance(indexed, Indexed)
    e1 = indexed
    e2, mi = e1.operands()
    return map_tensor_components(e2, e1, mi)

def map_component_tensor_arg_components(component_tensor):
    assert isinstance(component_tensor, ComponentTensor)
    e2 = component_tensor
    e1, mi = e2.operands()
    return map_tensor_components(e2, e1, mi)

def map_tensor_components(tensor, indexed, multiindex):
    e2 = tensor
    e1 = indexed
    mi = multiindex

    # Compute index shape
    ind1 = sorted(e1.free_indices(), key=lambda x: x.count())
    ind2 = sorted(e2.free_indices(), key=lambda x: x.count())
    idims1 = e1.index_dimensions()
    idims2 = e2.index_dimensions()
    ish1 = tuple(idims1[i] for i in ind1)
    ish2 = tuple(idims2[i] for i in ind2)

    # Compute regular and total shape
    sh1 = e1.shape()
    sh2 = e2.shape()
    tsh1 = sh1 + ish1
    tsh2 = sh2 + ish2
    str1 = shape_to_strides(tsh1)
    #str2 = shape_to_strides(tsh2)
    assert product(tsh1) == product(tsh2)
    assert (not sh1) and (ish1) and (sh2) and (not ish2)

    # Build map from ind1/ish1 position to mi position
    mi = [i for i in mi if isinstance(i, Index)]
    nmi = len(mi)
    ind1_to_mi_map = [None]*nmi
    for k in xrange(nmi):
        ind1_to_mi_map[ind1.index(mi[k])] = k

    # Build map from flattened e1 component to flattened e2 component
    indices2 = compute_indices(sh2)
    ni = len(indices2)
    d1 = [None]*ni
    d2 = [None]*ni
    for c2, p2 in enumerate(indices2):
        p1 = [p2[k] for k in ind1_to_mi_map]
        c1 = multiindex_to_component(p1, str1)
        d1[c1] = c2
        d2[c2] = c1
    assert d1 == d2
    return d2


class GraphAlgorithmTest(UflTestCase):

    def test_shape_to_strides(self):
        self.assertEqual((), shape_to_strides(()))
        self.assertEqual((1,), shape_to_strides((3,)))
        self.assertEqual((2,1), shape_to_strides((3,2)))
        self.assertEqual((4,1), shape_to_strides((3,4)))
        self.assertEqual((12,4,1), shape_to_strides((6,3,4)))

    def test_multiindex_to_component_to_multiindex(self):
        sh = (2, 3, 5)
        strides = shape_to_strides(sh)
        for i in range(sh[2]):
            for j in range(sh[1]):
                for k in range(sh[0]):
                    index = (k, j, i)
                    c = multiindex_to_component(index, strides)
                    index2 = component_to_multiindex(c, strides)
                    self.assertEqual(index, index2)

    def test_indexing_to_component(self):
        self.assertEqual(0, indexing_to_component(  (), (),   ()))
        self.assertEqual(0, indexing_to_component((0,), (), (2,)))
        self.assertEqual(1, indexing_to_component((1,), (), (2,)))
        self.assertEqual(3, indexing_to_component((1,1), (), (2,2)))
        for i in range(5):
            for j in range(3):
                for k in range(2):
                    self.assertEqual(15*k+5*j+i, indexing_to_component((k,j,i), (), (2,3,5)))

        # TODO: Add free indices to the mix!

    def test_map_indexed_arg_components(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_indexed_arg_components(A[i,j])
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_indexed_arg_components(A[j,i])
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_indexed_arg_components2(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_indexed_arg_components2(A[i,j])
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_indexed_arg_components2(A[j,i])
        self.assertEqual(d, [0, 2, 1, 3])

    def test_map_componenttensor_arg_components(self):
        W = TensorElement("CG", cell2D, 1)
        A = Coefficient(W)
        i, j = indices(2)

        # Ordered indices:
        d = map_component_tensor_arg_components(as_tensor(2*A[i,j], (i,j)))
        self.assertEqual(d, [0, 1, 2, 3])

        # Swapped ordering of indices:
        d = map_component_tensor_arg_components(as_tensor(2*A[i,j], (j,i)))
        self.assertEqual(d, [0, 2, 1, 3])

    def test_graph_algorithm(self):
        U = FiniteElement("CG", cell2D, 1)
        V = VectorElement("CG", cell2D, 1)
        W = TensorElement("CG", cell2D, 1)
        u = Coefficient(U)
        v = Coefficient(V)
        w = Coefficient(W)

        expr = u
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.total_value_size, 1)
        self.assertEqual(G.total_unique_symbols, 1)

        expr = u**2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.total_value_size, 3)
        self.assertEqual(G.total_unique_symbols, 3)

        expr = u**2/2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.total_value_size, 4)
        self.assertEqual(G.total_unique_symbols, 4)

        expr = dot(v,v)/2
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.total_value_size, 5)
        self.assertEqual(G.total_unique_symbols, 5)

        # Testing Indexed
        expr = v[i]*v[i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.total_value_size, 2+2+2+1)
        self.assertEqual(G.total_unique_symbols, 2+2+1)

        # Reusing symbols for indexed with different ordering
        # Note that two index sums are created, giving 2+1 symbols
        expr = w[i,j]*w[j,i]
        G = build_graph(expr, DEBUG=0)
        self.assertEqual(G.total_value_size, 4+4+4+4+2+1)
        self.assertEqual(G.total_unique_symbols, 4+4+2+1)

        # Testing ComponentTensor
        expr = dot(as_vector(2*v[i], i), v)
        G = build_graph(expr, DEBUG=1)
        self.assertEqual(G.total_value_size, 2+1 + 2+2+2 + 1)
        self.assertEqual(G.total_unique_symbols, 2+1 + 2+1)

        expr = dot(v+2*v,v)
        G = build_graph(expr, DEBUG=1)
        self.assertEqual(G.total_value_size, 2+1 + 2+2+2+2 + 1)
        self.assertEqual(G.total_unique_symbols, 2+1 + 2+2 + 1)

        expr = outer(v,v)[i,j]*outer(v,v)[j,i]
        G = build_graph(expr, DEBUG=1)
        self.assertEqual(G.total_value_size, 2+4+4+4 + 4+2+1)
        self.assertEqual(G.total_unique_symbols, 2+4+4 + 2+1)
