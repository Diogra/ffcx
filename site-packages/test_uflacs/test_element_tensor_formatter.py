"""
Tests of generic C++ compilation code.
"""

from ufltestcase import UflTestCase

import uflacs
from uflacs.codeutils.element_tensor_formatter import *

import ufl
from ufl import *
from uflacs.codeutils.format_code_structure import format_code_structure

class ElementTensorFormatterTest(UflTestCase):

    def setUp(self):
        self.cell = cell2D
        self.U = FiniteElement("U", self.cell, 1)
        self.V = VectorElement("U", self.cell, 1)
        self.W = TensorElement("U", self.cell, 1)
        self.u = Coefficient(self.U)
        self.v = Coefficient(self.V)
        self.w = Coefficient(self.W)

    def test_format_lines(self):
        def lineargs1():
            return ()
        fmt = "dummy"
        r = list(format_lines(fmt, lineargs1()))
        self.assertEqual(r, [])

        def lineargs2():
            for i in range(2):
                yield "hello", i*2, i*3
        fmt = "%s, %d, %d"
        r = list(format_lines(fmt, lineargs2()))
        self.assertEqual(r, ["hello, 0, 0", "hello, 2, 3"])

    def test_format_assignments(self):
        def name_value_pairs():
            for i in range(2):
                yield "s[%d]" % i, str((i+1)**2)
        r = list(format_assignments(name_value_pairs()))
        self.assertEqual(r, ["s[0] = 1;", "s[1] = 4;"])

    def test_format_additions(self):
        def name_value_pairs():
            for i in range(2):
                yield "A[%d]" % i, str((i+1)**2)
        r = list(format_additions(name_value_pairs()))
        self.assertEqual(r, ["A[0] += 1;", "A[1] += 4;"])

    def test_build_loops_empty(self):
        loops = []
        definitions = []
        partitions = []
        code = build_loops(loops, definitions, partitions)
        expected = ""
        self.assertEqual(format_code_structure(code), expected)

    def test_build_loops_one_level(self):
        """Build a single loop."""
        loops = ["for (i0;;)"]
        definitions = ["defs0;"]
        partitions = ["part0;"]
        code = build_loops(loops, definitions, partitions)
        #print format_code_structure(code)
        expected = "for (i0;;)\n{\n    defs0;\n    part0;\n}"
        self.assertEqual(format_code_structure(code), expected)

    def test_build_loops_two_levels_two_loops(self):
        """Build nested code with inner and outer loop."""
        loops = ["for (i0;;)", "for (i1;;)"]
        definitions = ["defs0;", "defs1;"]
        partitions = ["part0;", "part1;"]
        code = build_loops(loops, definitions, partitions)
        #print format_code_structure(code)
        expected = "for (i0;;)\n{\n    defs0;\n    part0;\n    "+\
            "for (i1;;)\n    {\n        defs1;\n        part1;\n    }\n}"
        self.assertEqual(format_code_structure(code), expected)

    def test_build_loops_two_levels_only_inner_loop(self):
        """Build nested code with no outer loop."""
        loops = ["", "for (i1;;)"]
        definitions = ["defs0;", "defs1;"]
        partitions = ["part0;", "part1;"]
        code = build_loops(loops, definitions, partitions)
        #print format_code_structure(code)
        expected = "defs0;\npart0;\nfor (i1;;)\n{\n    defs1;\n    part1;\n}"
        self.assertEqual(format_code_structure(code), expected)

    def test_build_loops_two_equivalent_levels(self):
        """If you want to make two loops after each other,
        just use build_loops twice."""
        code = []

        loops = ["for (i0;;)"]
        definitions = ["defs0;"]
        partitions = ["part0;"]
        code.append(build_loops(loops, definitions, partitions))
        
        loops = ["for (i1;;)"]
        definitions = ["defs1;"]
        partitions = ["part1;"]
        code.append(build_loops(loops, definitions, partitions))

        #print format_code_structure(code)
        expected = "for (i0;;)\n{\n    defs0;\n    part0;\n}\nfor (i1;;)\n{\n    defs1;\n    part1;\n}"
        self.assertEqual(format_code_structure(code), expected)
