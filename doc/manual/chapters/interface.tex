\chapter{Interface specification}
\label{sec:interface}

% Write about all functions are const except a few and why
% Write about the order in which we present the interface


\section{Cell shapes}

%%  /// Valid cell shapes
%%  enum shape {interval, triangle, quadrilateral, tetrahedron, hexahedron};

\begin{code}
enum shape {interval,
            triangle, quadrilateral,
            tetrahedron, hexahedron};
\end{code}

This enumeration includes all cell shapes that have a UFC definition, see chapter \ref{chapter:meshTODO}.


\section{The class \texttt{ufc::mesh}}

The class \texttt{ufc::mesh} defines a data structure containing basic information about
an unstuctured mesh. It is used for passing a minimal amount of information about the
global mesh to some UFC functions, with no intrusion on how the mesh is represented.

%%\subsection{The mesh dimensions}
\subsection{The integers \texttt{topological\_dimension} and \texttt{geometric\_dimension}}

%%     /// Topological dimension of the mesh
%%     unsigned int topological_dimension;

The unsigned integer \texttt{topological\_dimension}
specifies the topological dimension of the mesh, that is the
topological dimension of the cells of the mesh. For the supported
cell shapes defined above, the topological dimensions are as follows:
\texttt{interval} has dimension 0, \texttt{triangle} and
\texttt{quadrilateral} have dimension 2, and tetrahedron and
hexahedron have dimension 3.

%%     /// Geometric dimension of the mesh
%%     unsigned int geometric_dimension;

The unsigned integer \texttt{geometric\_dimension} is the geometric dimension
of the mesh, that is the dimension of the coordinates.
This is usually equal to the topological dimension, but can differ f.ex. for
a 2D surface mesh in a 3D space.

\subsection{The array \texttt{num\_entities}}

%%     /// Array of the global number of entities of each topological dimension
%%     unsigned int* num_entities;

\begin{code}
unsigned int* num_entities;
\end{code}

TODO: write about \texttt{num\_entities}


\section{The class \texttt{ufc::cell}}

The class \texttt{ufc::cell} defines the data structure for a cell in a mesh.
Its intended use is not as a building block in a mesh data structure, but merely as a view
of a single cell for argument passing with no intrusion on how the mesh is represented.

%%   class cell
%%   {
%%   public:

%%     /// Constructor
%%     cell(): cell_shape(interval),
%%             topological_dimension(0), geometric_dimension(0),
%%             entity_indices(0), coordinates(0) {}

%%     /// Destructor
%%     virtual ~cell() {}

%%     /// Shape of the cell
%%     shape cell_shape;

%%     /// Topological dimension of the mesh
%%     unsigned int topological_dimension;

%%     /// Geometric dimension of the mesh
%%     unsigned int geometric_dimension;

%%     /// Array of global indices for the mesh entities of the cell
%%     unsigned int** entity_indices;

%%     /// Array of coordinates for the vertices of the cell
%%     double** coordinates;

%%   };

The cell has a \texttt{ufc::shape}, \texttt{topological\_dimension} and \texttt{geometric\_dimension},
as well as two pointers to arrays \texttt{entity\_indices} and \texttt{coordinates}.
Representing these arrays with pointers gives the implementer flexibility
to fill in the cell structure efficiently in the assembly loop.

TODO: describe 
\texttt{entity\_indices}

The double pointer pointer \texttt{coordinates} points to an array of coordinates for the vertices of the cell.
The order of the vertices on a particular cell shape is defined in chapter \ref{chapter:meshTODO}.
%Within the assembly loop over all cells, these coordinates are filled in by the assembly software in 
%the way that is most efficient for a particular mesh library.


\section{The class \texttt{ufc::function}}

%%   /// This class defines the interface for a general tensor-valued function.

%%   class function
%%   {
%%   public:

%%     /// Constructor
%%     function() {}

%%     /// Destructor
%%     virtual ~function() {}

%%     /// Evaluate function at given point in cell
%%     virtual void evaluate(double* values,
%%                           const double* coordinates,
%%                           const cell& c) const = 0;

%%   };

The class \texttt{ufc::function} is an interface for evaluation of
general tensor-valued functions of spatial coordinates.

\begin{code}
virtual void evaluate(double* values,
                      const double* coordinates,
                      const cell& c) const = 0;
\end{code}

The only function in this class is \texttt{evaluate},
which evaluates all the value components of the function in a single point.
The output is placed in the array \texttt{values},
while the input arguments are the \texttt{coordinates} of the point
and the cell \texttt{c} in which this point is located.

See also the description of \texttt{ufc::finite\_element::evaluate\_dof}.


\section{The class \texttt{ufc::finite\_element}}

TODO: update this with mathematical notation and references to earlier equations

%%   /// This class defines the interface for a finite element.

%%   class finite_element
%%   {
%%   public:

%%     /// Constructor
%%     finite_element() {}

%%     /// Destructor
%%     virtual ~finite_element() {}

%%     /// Return a string identifying the finite element
%%     virtual const char* signature() const = 0;

\subsection{The function \texttt{signature}}
This function returns a signature string that uniquely identifies the \texttt{finite\_element} subclass.

%%     /// Return the cell shape
%%     virtual shape cell_shape() const = 0;

\subsection{The function \texttt{cell\_shape}}
This function returns the shape of the cell the finite element is defined on.

%%     /// Return the dimension of the finite element function space
%%     virtual unsigned int space_dimension() const = 0;

\subsection{The function \texttt{space\_dimension}}
This function returns the dimension of the local finite element space ($| V_h^K |$),
which is equal to the number of basis functions. This is equal to \texttt{dof\_map::local\_dimension()}
from the matching \texttt{dof\_map} object.

%%     /// Return the rank of the value space
%%     virtual unsigned int value_rank() const = 0;

%%     /// Return the dimension of the value space for axis i
%%     virtual unsigned int value_dimension(unsigned int i) const = 0;

\subsection{The functions \texttt{value\_rank} and \texttt{value\_dimension}}
A finite element can have general tensor-valued basis functions.
These functions return the rank of the value space and the dimension along each axis.
The total value size is the product of \texttt{value\_dimension(i)} for $0 \le i <$ \texttt{value\_rank()}.

To give a few examples, the rank of a scalar element is 0, while a vector element has rank 1 and size \texttt{value\_dimension(0)}, 
and for a 3 by 3 tensor element the rank is 2 and the value size is \texttt{value\_dimension(0)}*\texttt{value\_dimension(1)}=9.

%%     /// Evaluate basis function i at given point in cell
%%     virtual void evaluate_basis(unsigned int i,
%%                                 double* values,
%%                                 const double* coordinates,
%%                                 const cell& c) const = 0;

\subsection{The function \texttt{evaluate\_basis}}
This function evaluates basis function \texttt{i} at the given \texttt{coordinates}
within the given cell \texttt{c}, and stores the value components in the array \texttt{values}.
The size of this output array equals the value size (see \texttt{value\_rank} and \texttt{value\_dimension}).

%%     /// Evaluate order n derivatives of basis function i at given point in cell
%%     virtual void evaluate_basis_derivatives(unsigned int i,
%%                                             unsigned int n,
%%                                             double* values,
%%                                             const double* coordinates,
%%                                             const ufc::cell& c) const = 0;

\subsection{The function \texttt{evaluate\_basis\_derivatives}}
This function evaluates all order \texttt{n} derivatives of basis function \texttt{i}
at the given \texttt{coordinates} within the given \texttt{cell},
and stores the value components in the array \texttt{values}.

The number of derivatives equals $d^n$ where d is the geometric dimension.
For n = 1, the order of the derivatives is naturally
$\partial/\partial x$, $\partial/\partial y$, $\partial/\partial z$
in a 3D case.
For n = 2, the order of the derivatives in a 2D case is 
  $\frac{\partial^2}{\partial x\partial x}$,
  $\frac{\partial^2}{\partial x\partial y}$,
  $\frac{\partial^2}{\partial y\partial x}$,
  $\frac{\partial^2}{\partial y\partial y}$,
ie the last derivative varies the fastest similar to the standard C array ordering (TODO: does this have a better name?).

TODO: How do we know which derivatives are supported? We probably should have a function for this.

The memory layout of \texttt{values} is
\texttt{values[k*value\_size + j]},
where k is the number of the derivative,
and j is the number of the value component.
The length of this array is thus the value size times $d^n$.


%%     /// Evaluate linear functional for dof i on the function f
%%     virtual double evaluate_dof(unsigned int i,
%%                                 const function& f,
%%                                 const cell& c) const = 0;

\subsection{The function \texttt{evaluate\_dof}}
This function evaluates the linear functional $\nu_i(f)$ of function \texttt{f}
on the given cell, where in equation \eqref{eq:TODOUsum} $U_i = \nu_i(u)$
TODO: explain this better (ie what is meant by the linear functional)

%%     /// Interpolate vertex values from dof values
%%     virtual void interpolate_vertex_values(double* vertex_values,
%%                                            const double* dof_values,
%%                                            const cell& c) const = 0;

\subsection{The function \texttt{interpolate\_vertex\_values}}
This function takes as input the dofs \texttt{dof\_values} (TODO: nodal values? TODO: reference some equations)
of a function $f(x)$ in the finite element space, as well as a cell.
It then performs a local interpolation of $f(x)$ in the vertices of the cell.

%%     /// Return the number of sub elements (for a mixed element)
%%     virtual unsigned int num_sub_elements() const = 0;

\subsection{The function \texttt{num\_sub\_elements}}
This function returns the number of sub elements for a mixed element.
See description of the sub element concept under the form class.

%%     /// Create a new finite element for sub element i (for a mixed element)
%%     virtual finite_element* create_sub_element(unsigned int i) const = 0;

\subsection{The function \texttt{num\_sub\_elements}}
This function constructs a \texttt{finite\_element} object for sub element \texttt{i}.
See description of the sub element concept under the form class.
The caller is responsible for deleting the returned object.

%%   };



\section{The class \texttt{ufc::dof\_map}}

This class represents one local-to-global mapping of degrees of freedom (dofs),
as defined in equation \eqref{eq:iota_K}.
The most central function in this interface is \texttt{tabulate\_dofs}, described below.

%%   /// This class defines the interface for a local-to-global mapping of
%%   /// degrees of freedom (dofs).

%%   class dof_map
%%   {
%%   public:

%%     /// Constructor
%%     dof_map() {}

%%     /// Destructor
%%     virtual ~dof_map() {}

%%     /// Return a string identifying the dof map
%%     virtual const char* signature() const = 0;

\subsection{The function \texttt{signature}}
This function returns a signature string that uniquely identifies the \texttt{dof\_map} subclass.
The only requirement for the signature is that it is unique, such
that a comparison of two signatures can be used by the assembly
implementer to optimize the code by not initializing and tabulating equivalent dof maps more than once.

%%     /// Return true iff mesh entities of topological dimension d are needed
%%     virtual bool needs_mesh_entities(unsigned int d) const = 0;

\subsection{The function \texttt{needs\_mesh\_entities}}
This function returns true if the \texttt{dof\_map} requires mesh entities
of topological dimension d to be filled in \texttt{ufc::cell} arguments.
This is needed because computation of some mesh entity numberings
are expensive operations which can often be skipped.

%%     /// Initialize dof map for mesh (return true iff init_cell() is needed)
%%     virtual bool init_mesh(const mesh& mesh) = 0;

\subsection{The function \texttt{init\_mesh}}
This function initializes the dof map for a given mesh.
If it returns true, initialization requires calls to \texttt{init\_cell} and \texttt{init\_cell\_finalize} to complete
After initialization is complete, the function \texttt{global\_dimension} can be called.

%%     /// Initialize dof map for given cell
%%     virtual void init_cell(const mesh& m,
%%                            const cell& c) = 0;

\subsection{The function \texttt{init\_cell}}
For dof\_map objects where init\_mesh returns true,
this function must be called for each cell in the mesh
to initialize the dof mapping.

%%     /// Finish initialization of dof map for cells
%%     virtual void init_cell_finalize() = 0;

\subsection{The function \texttt{init\_cell\_finalize}}
For dof\_map objects where init\_mesh returns true,
this function must be called after init\_cell is called for each cell in the mesh
to complete initialition of the dof mapping.

%%     /// Return the dimension of the global finite element function space
%%     virtual unsigned int global_dimension() const = 0;

\subsection{The function \texttt{global\_dimension}}
This function returns the dimension of the global finite element space on the mesh
the dof\_map has been initialized for.
The result of calling this function before initialition is complete is undefined.

%%     /// Return the dimension of the local finite element function space
%%     virtual unsigned int local_dimension() const = 0;

\subsection{The function \texttt{local\_dimension}}
This function returns the dimension of the local finite element space on a single cell.

%%     /// Return the number of dofs on each cell facet
%%     virtual unsigned int num_facet_dofs() const = 0;

\subsection{The function \texttt{num\_facet\_dofs}}
This function returns the number of dofs tied to a single facet of a cell.
This is the number of dofs that should be set if a Dirichlet boundary condition is applied to a single facet.

%%     /// Tabulate the local-to-global mapping of dofs on a cell
%%     virtual void tabulate_dofs(unsigned int* dofs,
%%                                const mesh& m,
%%                                const cell& c) const = 0;

\subsection{The function \texttt{tabulate\_dofs}}
This function tabulates the global dof indices for each dof on the given cell.
The output array \texttt{dofs} is allocated by the caller with size \texttt{local\_dimension()}.

%%     /// Tabulate the local-to-local mapping from facet dofs to cell dofs
%%     virtual void tabulate_facet_dofs(unsigned int* dofs,
%%                                      unsigned int facet) const = 0;

\subsection{The function \texttt{tabulate\_facet\_dofs}}
This function tabulates which local dof indices are tied to the local facet.
The output array \texttt{dofs} is allocated by the caller with size \texttt{num\_facet\_dofs()}

%%     /// Tabulate the coordinates of all dofs on a cell
%%     virtual void tabulate_coordinates(double **coordinates,
%%                                       const cell& c) const = 0;

\subsection{The function \texttt{tabulate\_coordinates}}
This function tabulates the coordinates for each dof on the given cell.
For elements which do not have a direct relationship between coordinates and dofs,
an attempt should be made at a sensible implementation of this function.
For example, if a dof is defined as the integral over a facet, the midpoint
of the facet can be used. If no other choice makes sense, the midpoint of the cell
can be used as a last resort. This function must thus be used with care if
non-Lagrangian elements are used.
The output array \texttt{coordinates} is allocated by the caller with size \texttt{local\_dimension()} times number of space dimensions.

%%     /// Return the number of sub dof maps (for a mixed element)
%%     virtual unsigned int num_sub_dof_maps() const = 0;

\subsection{The function \texttt{num\_sub\_dof\_maps}}
This function returns the number of sub dof maps for a mixed element.
See description of the sub element concept under the form class.

%%     /// Create a new dof_map for sub dof map i (for a mixed element)
%%     virtual dof_map* create_sub_dof_map(unsigned int i) const = 0;

\subsection{The function \texttt{create\_sub\_dof\_map}}
This factory function constructs a \texttt{dof\_map} object for sub dof map i.
See description of the sub element concept under the form class.
The caller is responsible for deleting the returned object.
TODO: Describe numbering convention for recursive sub elements with (v, p) as example.

%%   };



\section{The integral classes}

The computation of the element tensor $A^K$ on a cell $K$ is split into computation of
contributions from several integrals, as seen in equation \eqref{eq:form_integrals}.
Each of the three types of integrals is represented with its own class.
All three integral classes have a single function \texttt{tabulate\_tensor} which
computes the tensor values $A_i^K$.

For all types of integrals, the coefficient array \texttt{w[i][j]} contains the
arguments to the form. Each argument $w_i$, $0\le i<n$, is a function that resides in a 
particular finite element space. For a given argument i, the local degrees of freedom for $w_i$
is represented by \texttt{w[i][j]}, $0 \le j < d_i$, with $d_i$ being the local dimension of
the finite element space for argument i.

Note that, to support coefficient functions which should be evaluated in quadrature points
for use in a quadrature-based implementation of \texttt{tabulate\_tensor()},
an implementation of \texttt{finite\_element} and \texttt{dof\_map}
can be written were the degrees of freedom are the values of $f$ in each
quadrature point. For example, \texttt{finite\_element::evaluate\_dof(j, f, ...)}
would evaluate the function f in quadrature point j, and \texttt{w[i][j]} would contain
the value of $f=w_i$ in quadrature point $x_j$.

%See \texttt{class finite\_element}, \texttt{class dof\_map},
%\texttt{form::create\_finite\_element(i)} and \texttt{form::create\_dof\_map(i)}.

%\texttt{i}


%%\section{The class \texttt{ufc::cell\_integral}}

%%   /// This class defines the interface for the tabulation of the cell
%%   /// tensor corresponding to the local contribution to a form from
%%   /// the integral over a cell.

%%   class cell_integral
%%   {
%%   public:

%%     /// Constructor
%%     cell_integral() {}

%%     /// Destructor
%%     virtual ~cell_integral() {}

%%     /// Tabulate the tensor for the contribution from a local cell
%%     virtual void tabulate_tensor(double* A,
%%                                  const double * const * w,
%%                                  const cell& c) const = 0;

%%   };


\subsection{The class \texttt{ufc::cell\_integral}}
%%\subsection{The function \texttt{tabulate\_tensor}}
\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c) const = 0;
\end{code}
This function computes the contribution to the local element tensor
on the given cell from this cell integral.
The size of this tensor is TODO


%%\section{The class \texttt{ufc::exterior\_facet\_integral}}

%%   /// This class defines the interface for the tabulation of the
%%   /// exterior facet tensor corresponding to the local contribution to
%%   /// a form from the integral over an exterior facet.

%%   class exterior_facet_integral
%%   {
%%   public:

%%     /// Constructor
%%     exterior_facet_integral() {}

%%     /// Destructor
%%     virtual ~exterior_facet_integral() {}

%%     /// Tabulate the tensor for the contribution from a local exterior facet
%%     virtual void tabulate_tensor(double* A,
%%                                  const double * const * w,
%%                                  const cell& c,
%%                                  unsigned int facet) const = 0;

%%   };


\subsection{The class \texttt{ufc::exterior\_facet\_integral}}
%%\subsection{The function \texttt{tabulate\_tensor}}
\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c,
                             unsigned int facet) const = 0;
\end{code}
This function computes the contribution to the local element tensor
on the given cell facet from this exterior facet integral.
The size of this tensor is TODO



%%\section{The class \texttt{ufc::interior\_facet\_integral}}

%%   /// This class defines the interface for the tabulation of the
%%   /// interior facet tensor corresponding to the local contribution to
%%   /// a form from the integral over an interior facet.

%%   class interior_facet_integral
%%   {
%%   public:

%%     /// Constructor
%%     interior_facet_integral() {}

%%     /// Destructor
%%     virtual ~interior_facet_integral() {}

%%     /// Tabulate the tensor for the contribution from a local interior facet
%%     virtual void tabulate_tensor(double* A,
%%                                  const double * const * w,
%%                                  const cell& c0,
%%                                  const cell& c1,
%%                                  unsigned int facet0,
%%                                  unsigned int facet1) const = 0;

%%   };

\subsection{The class \texttt{ufc::interior\_facet\_integral}}
%%\subsection{The function \texttt{tabulate\_tensor}}
\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c0,
                             const cell& c1,
                             unsigned int facet0,
                             unsigned int facet1) const = 0;
\end{code}
This function computes the contribution to the local element tensor
on the given facet between two cells from this interior facet integral.
The size of this tensor is TODO


\section{The class \texttt{ufc::form}}

This class represents the central object in any UFC implementation.
A \texttt{form} object can provide some basic information about the form,
like the rank r and number of coefficients n.
In addition, an object of this type can be used to construct matching
implementations of all the other UFC classes with the use of factory functions.
This includes an arbitrary number of integral objects,
as well as one \texttt{finite\_element} and one \texttt{dof\_map} for
each argument (r+n) to the form.

TODO: Need a separate section for the sub element concept.
Some finite elements can be seen as composite elements with a number of sub elements.
A vector element is an element with a value size larger than one,
where each value component usually resides in the same function space.
A mixed element can be seen as a vector element where each value
component may reside in a different function space.
Some times it is convenient to see these composite elements as one element,
and other times it is necessary to extract one sub element at a time.

In UFC we treat vector elements and mixed elements the same way, by allowing
an element (and dof map) to contain sub elements (and sub dof maps).
The composite element for argument i is what you get directly from
\texttt{form::create\_finite\_element(i)} and \texttt{form::create\_dof\_map(i)}.
To get access to the sub elements, see the documentation for
\texttt{finite\_element} and \texttt{dof\_map}.
TODO: Describe recursive sub elements with (v, p) as example.

%%   /// This class defines the interface for the assembly of the global
%%   /// tensor corresponding to a form with r + n arguments, that is, a
%%   /// mapping
%%   ///
%%   ///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
%%   ///
%%   /// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
%%   /// global tensor A is defined by
%%   ///
%%   ///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
%%   ///
%%   /// where each argument Vj represents the application to the
%%   /// sequence of basis functions of Vj and w1, w2, ..., wn are given
%%   /// fixed functions (coefficients).

%%   class form
%%   {
%%   public:

%%     /// Constructor
%%     form() {}

%%     /// Destructor
%%     virtual ~form() {}

%%     /// Return a string identifying the form
%%     virtual const char* signature() const = 0;

\subsection{The function \texttt{signature}}
This function returns a unique signature for the form.
TODO: Requirements for the signature.


%%     /// Return the rank of the global tensor (r)
%%     virtual unsigned int rank() const = 0;

\subsection{The function \texttt{rank}}
This function returns the rank of the element tensors created by this form.


%%     /// Return the number of coefficients (n)
%%     virtual unsigned int num_coefficients() const = 0;

\subsection{The function \texttt{num\_coefficients}}
This function returns the number of coefficients for this form.
Note that, for simplicity, all integrals in a form must have
the same coefficients, even if they don't use them.


%%     /// Return the number of cell integrals
%%     virtual unsigned int num_cell_integrals() const = 0;

\subsection{The function \texttt{num\_cell\_integrals}}
This function returns the number of different cell integrals for this form.


\subsection{The function \texttt{num\_exterior\_facet\_integrals}}
%%     /// Return the number of exterior facet integrals
\begin{code}
virtual unsigned int num_exterior_facet_integrals() const = 0;
\end{code}
This function returns the number of different exterior facet integrals for this form.


%%     /// Return the number of interior facet integrals
%%     virtual unsigned int num_interior_facet_integrals() const = 0;

\subsection{The function \texttt{num\_interior\_facet\_integrals}}
This function returns the number of different interior facet integrals for this form.


%%     /// Create a new finite element for argument function i
%%     virtual finite_element* create_finite_element(unsigned int i) const = 0;

\subsection{The function \texttt{create\_finite\_element}}
This factory function constructs a \texttt{finite\_element} object for form argument i.
A form with rank r and a number of coefficients n will have r+n arguments,
such that this function returns the finite element object for coefficient $k$ if $i=r+k$,
or for tensor axis $k$ if $i=k<r$. TODO: is axis the right word?
The caller is responsible for deleting the returned object.


%%     /// Create a new dof map for argument function i
%%     virtual dof_map* create_dof_map(unsigned int i) const = 0;

\subsection{The function \texttt{create\_dof\_map}}
This factory function constructs a \texttt{dof\_map} object for form argument i.
A form with rank r and a number of coefficients n will have r+n arguments,
such that this function returns the finite element object for coefficient $k$ if $i=r+k$,
or for tensor axis $k$ if $i=k<r$. TODO: is axis the right word?
The caller is responsible for deleting the returned object.


%%     /// Create a new cell integral on sub domain i
%%     virtual cell_integral* create_cell_integral(unsigned int i) const = 0;

\subsection{The function \texttt{create\_cell\_integral}}
This factory function constructs a \texttt{cell\_integral} object for cell domain i.
TODO: math syntax. Domain description?
The caller is responsible for deleting the returned object.


%%     /// Create a new exterior facet integral on sub domain i
%%     virtual exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const = 0;

\subsection{The function \texttt{create\_exterior\_facet\_integral}}
This factory function constructs a \texttt{exterior\_facet\_integral} object for exterior facet domain i.
TODO: math syntax. Domain description?
The caller is responsible for deleting the returned object.


%%     /// Create a new interior facet integral on sub domain i
%%     virtual interior_facet_integral* create_interior_facet_integral(unsigned int i) const = 0;

\subsection{The function \texttt{create\_interior\_facet\_integral}}
This factory function constructs a \texttt{interior\_facet\_integral} object for interior facet domain i.
TODO: math syntax. Domain description?
The caller is responsible for deleting the returned object.


%%   };

%% }

%% #endif

% Need to write about the Python utils somewhere, should be in appendix
