\chapter{Interface specification}
\label{sec:interface}

% Write about all functions are const except a few and why
% Write about the order in which we present the interface

\section{A short remark on design}

UFC is organized as a minimalistic C++ class hierarchy for
representing low-level abstractions of the finite element method. The
functions in these classes are mainly of two types: (i) Functions
returning dimensions, which are typically used to allocate an array or
check whether an existing array is of proper size and (ii) Functions
that fill an array with values according to the method and variational
form.

It is considered the user's or the assembly routine's
responsibility to allocate and deallocate arrays of proper size.
Consider for example the function for evaluating the $i$th basis
function in the class \texttt{finite\_element}:
\begin{code}
virtual void evaluate_basis(unsigned int i, double* values,
                            const double* coordinates,
                            const cell& c) const = 0;
\end{code}
This function assumes that the array \texttt{values} has the 
correct size, which may be obtained by calling the functions
\texttt{value\_rank} and \texttt{value\_dimension}.

Thus, the UFC interface is a low-level interface that should be simple
to integrate into an existing C++ finite element code, but which is
probably not suitable to be exposed as part of an end-user interface.

\section{Cell shapes}

\begin{code}
enum shape {interval,
            triangle, quadrilateral,
            tetrahedron, hexahedron};
\end{code}

This enumeration includes all cell shapes that are covered by the UFC
specification, see Chapter~\ref{sec:referencecells}.

\section{The class \texttt{ufc::mesh}}

The class \texttt{ufc::mesh} defines a data structure containing basic
information about an unstuctured mesh. It is used for passing a
minimal amount of information about the global mesh to UFC
functions.

\subsection{The integer \texttt{topological\_dimension}}

\begin{code}
unsigned int topological_dimension;
\end{code}

The unsigned integer\texttt{topological\_dimension}
specifies the topological dimension of the mesh, that is, the
topological dimension of the cells of the mesh. For the supported
cell shapes defined above, the topological dimensions are as follows:
\texttt{interval} has dimension one, \texttt{triangle} and
\texttt{quadri\-lateral} have dimension two, and tetrahedron and
hexahedron have dimension three.

\subsection{The integer \texttt{geometric\_dimension}}

\begin{code}
unsigned int geometric_dimension;
\end{code}

The unsigned integer \texttt{geometric\_dimension} is the geometric dimension
of the mesh, that is, the dimension of the coordinates of the mesh vertices.
Often, the geometric dimension is equal to the topological dimension,
but they may differ. For example, one may have a topologically
two-dimensional mesh embedded in three-dimensional space.

\subsection{The array \texttt{num\_entities}}

\begin{code}
unsigned int* num_entities;
\end{code}

The array \texttt{num\_entities} should contain the number of entities
within each topological dimension of the mesh (see
Chapter~\ref{sec:referencecells}). Thus, for a mesh of tetrahedral
cells, \texttt{num\_entitites[0]} should contain the number of
vertices, \texttt{num\_entities[1]} should contain the number of edges
(if they are needed, see below) and \texttt{num\_entities[2]} should
contain the number of faces, and \texttt{num\_entities[3]} should
contain the number of cells.

\section{The class \texttt{ufc::cell}}

The class \texttt{ufc::cell} defines the data structure for a cell in
a mesh. Its intended use is not as a building block in a mesh data
structure, but merely as a view of specific data for a single cell.
It is used to pass cell data to UFC functions with a minimal amount of
assumptions on how the computational mesh is represented and stored.

\subsection{The enum variable \texttt{cell\_shape}}

\begin{code}
shape cell_shape;
\end{code}

The variable \texttt{cell\_shape} should be set to the corresponding
\texttt{ufc::shape} for the cell (see above).

\subsection{The integer \texttt{topological\_dimension}}

\begin{code}
unsigned int topological_dimension;
\end{code}

The integer \texttt{topological\_dimension} should be set equal to the
topological dimension of the cell (see above).

\subsection{The integer \texttt{geometric\_dimension}}

\begin{code}
unsigned int geometric_dimension;
\end{code}

The integer \texttt{geometric\_dimension} should be set equal to the
geometric dimension of the cell (see above).

\subsection{The array \texttt{entity\_indices}}

\begin{code}
unsigned int** entity_indices;
\end{code}

The array \texttt{entity\_indices} should contain the global indices
for all entities of the cell (see Chapter~\ref{sec:referencecells}).
The length of the array \texttt{entity\_indices} should be equal to
the value of the variable \texttt{topological\_dimension} plus one.

Thus, \texttt{entity\_indices[0]} should be an array containing the
global indices of all the vertices of the cell,
\texttt{entity\_indices[1]} should be an array containing the global
indices of all the edges of the cell, etc. 

Note that entity indices are not always needed for all entities of the
cell. Which entities are needed is specified by the
\texttt{ufc::dof\_map} class (see below).

\subsection{The array \texttt{coordinates}}

\begin{code}
double** coordinates;
\end{code}

The array \texttt{coordinates} should contain the global coordinates
for all vertices of the cell. The length of the array
\texttt{coordinates} should be equal to number of vertices of the
mesh. The length of the array \texttt{coordinates[0]} should be equal
to the value of the variable \texttt{geometric\_dimension} and it
should contain the $x$, $y$, \ldots coordinates of the first
vertex etc.

\section{The class \texttt{ufc::function}}

The class \texttt{ufc::function} is an interface for evaluation of
general tensor-valued functions on the cells of a mesh.

\begin{code}
virtual void evaluate(double* values,
                      const double* coordinates,
                      const cell& c) const = 0;
\end{code}

The only function in this class is \texttt{evaluate},
which evaluates all the value components of the function at a given
point in a given cell of the mesh.

The output of \texttt{evaluate} should be written to the array
\texttt{values}. For a scalar-valued functon, a single value should be
written to \texttt{values[0]}. For general tensor-valued functions,
the values should be written in a flattened row-major ordering of the
tensor values. Thus, for a function $f : K \rightarrow \R^2$ with $A =
f(x)$ a $2 \times 2$ matrix, the array \texttt{values} should contain
the values $A_{11}, A_{12}, A_{21}, A_{22}$.

The input of \texttt{evalute} are the coordinates of a point in a cell and
the UFC view of the cell containing the point.

See also the description of \texttt{ufc::finite\_element::evaluate\_dof} below.

\section{The class \texttt{ufc::finite\_element}}

The class \texttt{ufc::finite\_element} represents a finite element in
the classical Ciarlet sense~\cite{Cia78}, or rather a particular
instance of a finite element for a particular choice of nodal basis
functions. Thus, a \texttt{ufc::finite\_element} has functions for
accessing the shape of the finite element, the dimension of the
polynomial function space, the basis functions of the function space
(and their derivatives), and the linear functionals defining the
degrees of freedom. In addition, a \texttt{ufc::finite\_element}
provides functionality for interpolation.

\subsection{The function \texttt{signature}}

\begin{code}
virtual const char* signature() const = 0;
\end{code}

This function returns a signature string that uniquely identifies the
finite element. This can be used to compare whether or not two given
\texttt{ufc::fi\-nite\_element}s are equal.

\subsection{The function \texttt{cell\_shape}}

\begin{code}
virtual shape cell_shape() const = 0;
\end{code}

This function returns the shape of the cell the finite element is
defined on.

\subsection{The function \texttt{space\_dimension}}

\begin{code}
virtual unsigned int space_dimension() const = 0;
\end{code}

This function returns the dimension of the local finite element space
($|V_h^K|$), which is equal to the number of basis functions. This
should also be equal to the value of \texttt{local\_dimension()} for
the corresponding \texttt{ufc::dof\_map} (see below).

\subsection{The function \texttt{value\_rank}}

\begin{code}
virtual unsigned int value_rank() const = 0;
\end{code}

A finite element can have general tensor-valued basis functions.
The function \texttt{value\_rank} returns the rank of the value space
of the basis functions. For a scalar element, this function should
return zero, for vector-valued functions it should return one, for
matrix-valued functions it should return two, etc.

\subsection{The function \texttt{value\_dimension}}

\begin{code}
virtual unsigned int value_dimension(unsigned int i) const = 0;
\end{code}

This function returns the dimension of the value space of the finite
element basis functions for the given axis, where the given axis must
be a number between zero and the value rank minus one.

Note that the total size (number of values) of the value space is
obtained as the product \texttt{value\_dimension(i)} for $0 \le i <$
\texttt{value\_rank()}.

\subsection{The function \texttt{evaluate\_basis}}

\begin{code}
virtual void evaluate_basis(unsigned int i,
                            double* values,
                            const double* coordinates,
                            const cell& c) const = 0;
\end{code}

This function evaluates basis function \texttt{i} at the given
\texttt{coordinates} within the given cell \texttt{c}, and stores the
values in the array \texttt{values}. The size of this output array
equals the value size of value space (as described in the previous
section).

\subsection{The function \texttt{evaluate\_basis\_derivatives}}

\begin{code}
virtual void evaluate_basis_derivatives(unsigned int i,
                                        unsigned int n,
                                        double* values,
                                        const double* coordinates,
                                        const ufc::cell& c) const = 0;
\end{code}

This function evaluates all order \texttt{n} derivatives of basis
function \texttt{i} at the given \texttt{coordinates} within the given
\texttt{cell}, and stores the values in the array \texttt{values}.
Derivatives may be obtained up to the polynomial degree of the finite
element function space with higher degree derivatives evaluating to
zero.

The number of derivatives is given by $d^n$ where $d$ is the geometric
dimension of the cell. For $n = 1$, $d = 3$, the order of the
derivatives is naturally $\partial/\partial x$, $\partial/\partial y$,
$\partial/\partial z$. For $n = 2$, $d = 3$, the order of the
derivatives is $\frac{\partial^2}{\partial x\partial x},
\frac{\partial^2}{\partial x\partial y}, \ldots,
\frac{\partial^2}{\partial z\partial z}$. Thus, the derivatives are
stored in a flattened row-major ordering based on the derivative
spatial dimensons.

For tensor-valued basis functions, the ordering of derivatives is
row-major based on the value space dimensions followed by the
derivative spatial dimensions.

\subsection{The function \texttt{evaluate\_dof}}

\begin{code}
virtual double evaluate_dof(unsigned int i,
                            const function& f,
                            const cell& c) const = 0;
\end{code}

This function evaluates and returns the value degree of freedom
\texttt{i} (which is a linear functional) on the given function
\texttt{f}.
  
For example, the degrees of freedom for Lagrange finite element are
given by evaluation at a set of points. Degrees of freedom may also be
given by weighted integrals over facets, normal components etc.

\subsection{The function \texttt{interpolate\_vertex\_values}}

\begin{code}
virtual void interpolate_vertex_values(double* vertex_values,
                                       const double* dof_values,
                                       const cell& c) const = 0;
\end{code}

This function takes as input the array \texttt{dof\_values} containing
the expansion coefficients for some function in the nodal basis and
computes the values of that function at the vertices of the given
cell, storing those values in the array \texttt{vertex\_values}. If
the function is tensor-valued, the values are stored in the array
\texttt{dof\_values} row-major on the list of vertices followed by the
row-major ordering of the tensor values as described above.

\subsection{The function \texttt{num\_sub\_elements}}

\begin{code}
virtual unsigned int num_sub_elements() const = 0;
\end{code}

This function returns the number of sub elements for a nested (mixed)
element. For simple elements (non-nested), this function should return
one.

A nested element is an element that is defined from a set of elements
by taking the direct sum (tensor product) of the polynomial spaces of
those elements. For example, the basis functions $\psi_1, \psi_2,
\ldots$ of a vector-valued Lagrange element may be constructed from a
scalar Lagrange element by repeating the basis functions $\phi_1,
\psi_2, \ldots$ of the scalar element and padding with zeros: $\psi_1
= (\phi_1, 0), \psi_2 = (\phi_2, 0), \ldots, (0, \phi_1), (0, \phi_2),
\ldots$.

Finite elements may be nested at arbitrary depth. So for example, a
mixed Taylor--Hood element may be created my combining a vector-valued
quadratic Lagrange finite element with a scalar linear Lagrange finite
element, and the vector-valued element may in turn be created by
combining a set of scalar quadratic Lagrange elements.

\subsection{The function \texttt{create\_sub\_element}}

\begin{code}
virtual finite_element* create_sub_element(unsigned int i) const = 0;
\end{code}

This factory function constructs a \texttt{finite\_element} object for
sub element \texttt{i}. The argument \texttt{i} must be a number
between zero and the number of sub elements
(\texttt{num\_sub\_elements}) minus one. If the element is simple
(non-nested), this function creates a copy of the finite element
itself.

\section{The class \texttt{ufc::dof\_map}}

This class represents the local-to-global mapping of degrees of
freedom (dofs), or rather one particular instance of such a mapping
(there are many possible local-to-global mappings) as defined in
\eqref{eq:iota_K}.  The most central function of this class is
\texttt{tabulate\_dofs}, which tabulates the local-to-global mapping
from the degrees of freedom on a local cell to a global vector of
degrees of freedom.

\subsection{The function \texttt{signature}}

\begin{code}
virtual const char* signature() const = 0;
\end{code}

This function returns a signature string that uniquely identifies the
finite element. This can be used to compare whether or not two given
\texttt{ufc::dof\_map}s are equal. (This may be used to optimize the
assembly of forms by caching previously computed dof maps.)

\subsection{The function \texttt{needs\_mesh\_entities}}

\begin{code}
virtual bool needs_mesh_entities(unsigned int d) const = 0;
\end{code}

This function returns true if the \texttt{dof\_map} requires mesh
entities of topological dimension \texttt{d} to be filled in
\texttt{ufc::cell} arguments. This may be used to check which entities
must be generated to tabulate the local-to-global mapping. For
example, linear Lagrange elements will only need to know the vertices
of each cell in the mesh, while quadratic Lagrange elements will also
need to know the edges (or faces) of each cell in the mesh.

\subsection{The function \texttt{init\_mesh}}

\begin{code}
virtual bool init_mesh(const mesh& mesh) = 0;
\end{code}

This function initializes the dof map for a given mesh. If it returns
true, initialization requires calls to \texttt{init\_cell} and
\texttt{init\_cell\_finalize} to complete the initialization. Only
initialization is complete may the function \texttt{global\_dimension}
be called.

\subsection{The function \texttt{init\_cell}}

\begin{code}
virtual void init_cell(const mesh& m,
                       const cell& c) = 0;
\end{code}

For \texttt{dof\_map} objects where \texttt{init\_mesh} returns true,
this function must be called for each cell in the mesh to initialize
the dof mapping.

\subsection{The function \texttt{init\_cell\_finalize}}

\begin{code}
virtual void init_cell_finalize() = 0;
\end{code}

For \texttt{dof\_map} objects where \texttt{init\_mesh} returns true,
this function must be called after \texttt{init\_cell} is called for
each cell in the mesh to complete initialization of the dof mapping.

\subsection{The function \texttt{global\_dimension}}

\begin{code}
virtual unsigned int global_dimension() const = 0;
\end{code}

This function returns the dimension of the global finite element space
on the mesh that the \texttt{dof\_map} has been initialized for. The
result of calling this function before initialition is complete is
undefined.

\subsection{The function \texttt{local\_dimension}}

\begin{code}
virtual unsigned int local_dimension() const = 0;
\end{code}

This function returns the dimension of the local finite element space
on a single cell.

\subsection{The function \texttt{num\_facet\_dofs}}

\begin{code}
virtual unsigned int num_facet_dofs() const = 0;
\end{code}

This function returns the number of dofs tied to a single facet of a
cell. This is the number of dofs that should be set if a Dirichlet
boundary condition is applied to a single facet. It is assumed that
all cells of the mesh have the same number of degrees of freedom on
each of their facets.

\subsection{The function \texttt{tabulate\_dofs}}

\begin{code}
virtual void tabulate_dofs(unsigned int* dofs,
                           const mesh& m,
                           const cell& c) const = 0;
\end{code}

This function tabulates the global dof indices corresponding to each
dof on the given cell. The size of the output array \texttt{dofs}
should be equal to the value returned by \texttt{local\_dimension()}.

\subsection{The function \texttt{tabulate\_facet\_dofs}}

\begin{code}
/// Tabulate the local-to-local mapping from facet dofs to cell dofs
virtual void tabulate_facet_dofs(unsigned int* dofs,
                                 unsigned int facet) const = 0;
\end{code}

This function tabulates the local dof indices tied to a given local
facet. The size of the output array \texttt{dofs} should be equal to
the value returned by \texttt{num\_facet\_dofs()}.

\subsection{The function \texttt{tabulate\_coordinates}}

\begin{code}
virtual void tabulate_coordinates(double** coordinates,
                                  const cell& c) const = 0;
\end{code}

This function tabulates the coordinates for each dof on the given
cell. For Lagrange elements, this function will tabulate a set of
points on the given cell such that the dofs of the finite element are
given by evaluation of the function at those points.

For elements which do not have a direct relationship between
coordinates and dofs, an attempt should be made at a sensible
implementation of this function. For example, if a dof is defined as
the integral over a facet, the midpoint of the facet can be used. If
no other choice makes sense, the midpoint of the cell can be used as a
last resort. This function must thus be used with care if
non-Lagrangian elements are used. 

The size of the output array \texttt{coordinates} should be equal to
the value returned by \texttt{local\_dimension()} and the size of each
sub array \texttt{coordinates[0]}, \texttt{coordinates[1]} etc. should
be equal to the geometric dimension of the mesh.

\subsection{The function \texttt{num\_sub\_dof\_maps}}

\begin{code}
virtual unsigned int num_sub_dof_maps() const = 0;
\end{code}

This function returns the number of sub dof maps for a nested (mixed)
element. For a discussion on the sub element concept, see the
documentation of the function
\texttt{finite\_element::num\_sub\_dof\_maps}. For simple elements
(non-nested), this function should return one.

\subsection{The function \texttt{create\_sub\_dof\_map}}

\begin{code}
virtual dof_map* create_sub_dof_map(unsigned int i) const = 0;
\end{code}

This factory function constructs a \texttt{dof\_map} object for sub
element \texttt{i}. The argument \texttt{i} must be a number between
zero and the number of sub dof maps (\texttt{num\_sub\_dof\_maps})
minus one. If the dof map is simple (non-nested), this function creates a
copy of the dof map element itself.

\section{The integral classes}

The computation of the element tensor $A^K$ on a cell $K$ is split into computation of
contributions from several integrals, as seen in equation \eqref{eq:form_integrals}.
Each of the three types of integrals is represented with its own class.
All three integral classes have a single function \texttt{tabulate\_tensor} which
computes the tensor values $A_i^K$.

For all types of integrals, the coefficient array \texttt{w[i][j]} contains the
arguments to the form. Each argument $w_i$, $0\le i<n$, is a function that resides in a 
particular finite element space. For a given argument i, the local degrees of freedom for $w_i$
is represented by \texttt{w[i][j]}, $0 \le j < d_i$, with $d_i$ being the local dimension of
the finite element space for argument i.

Note that, to support coefficient functions which should be evaluated in quadrature points
for use in a quadrature-based implementation of \texttt{tabulate\_tensor()},
an implementation of \texttt{finite\_element} and \texttt{dof\_map}
can be written were the degrees of freedom are the values of $f$ in each
quadrature point. For example, \texttt{finite\_element::evaluate\_dof(j, f, ...)}
would evaluate the function f in quadrature point j, and \texttt{w[i][j]} would contain
the value of $f=w_i$ in quadrature point $x_j$.

\section{The class \texttt{ufc::cell\_integral}}

\subsection{The function \texttt{tabulate\_tensor}}

\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c) const = 0;
\end{code}

This function computes the contribution to the local element tensor
on the given cell from this cell integral.
The size of this tensor is TODO

\subsection{The class \texttt{ufc::exterior\_facet\_integral}}

\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c,
                             unsigned int facet) const = 0;
\end{code}

\section{The class \texttt{ufc::exterior\_facet\_integral}}

\subsection{The function \texttt{tabulate\_tensor}}

\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c,
                             unsigned int facet) const = 0;
\end{code}

This function computes the contribution to the local element tensor
on the given cell facet from this exterior facet integral.
The size of this tensor is TODO

\subsection{The class \texttt{ufc::interior\_facet\_integral}}

\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c0,
                             const cell& c1,
                             unsigned int facet0,
                             unsigned int facet1) const = 0;
\end{code}

\section{The class \texttt{ufc::interior\_facet\_integral}}

\subsection{The function \texttt{tabulate\_tensor}}

\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c0,
                             const cell& c1,
                             unsigned int facet0,
                             unsigned int facet1) const = 0;
\end{code}

This function computes the contribution to the local element tensor
on the given facet between two cells from this interior facet integral.
The size of this tensor is TODO

\section{The class \texttt{ufc::form}}

This class represents the central object in any UFC implementation.
A \texttt{form} object can provide some basic information about the form,
like the rank r and number of coefficients n.
In addition, an object of this type can be used to construct matching
implementations of all the other UFC classes with the use of factory functions.
This includes an arbitrary number of integral objects,
as well as one \texttt{finite\_element} and one \texttt{dof\_map} for
each argument (r+n) to the form.

TODO: Need a separate section for the sub element concept.
Some finite elements can be seen as composite elements with a number of sub elements.
A vector element is an element with a value size larger than one,
where each value component usually resides in the same function space.
A mixed element can be seen as a vector element where each value
component may reside in a different function space.
Some times it is convenient to see these composite elements as one element,
and other times it is necessary to extract one sub element at a time.

In UFC we treat vector elements and mixed elements the same way, by allowing
an element (and dof map) to contain sub elements (and sub dof maps).
The composite element for argument i is what you get directly from
\texttt{form::create\_finite\_element(i)} and \texttt{form::create\_dof\_map(i)}.
To get access to the sub elements, see the documentation for
\texttt{finite\_element} and \texttt{dof\_map}.
TODO: Describe recursive sub elements with (v, p) as example.

\subsection{The function \texttt{signature}}

This function returns a unique signature for the form.
TODO: Requirements for the signature.

\begin{code}
virtual const char* signature() const = 0;
\end{code}

\subsection{The function \texttt{rank}}

\begin{code}
virtual unsigned int rank() const = 0;
\end{code}

This function returns the rank of the element tensors created by this form.

\subsection{The function \texttt{num\_coefficients}}

\begin{code}
virtual unsigned int num_coefficients() const = 0;
\end{code}

This function returns the number of coefficients for this form.
Note that, for simplicity, all integrals in a form must have
the same coefficients, even if they don't use them.

\subsection{The function \texttt{num\_cell\_integrals}}

\begin{code}
virtual unsigned int num_cell_integrals() const = 0;
\end{code}

This function returns the number of different cell integrals for this form.

\subsection{The function \texttt{num\_exterior\_facet\_integrals}}

\begin{code}
virtual unsigned int num_exterior_facet_integrals() const = 0;
\end{code}

This function returns the number of different exterior facet integrals for this form.

\subsection{The function \texttt{num\_interior\_facet\_integrals}}

\begin{code}
virtual unsigned int num_interior_facet_integrals() const = 0;
\end{code}

This function returns the number of different interior facet integrals for this form.

\subsection{The function \texttt{create\_finite\_element}}

\begin{code}
virtual finite_element* create_finite_element(unsigned int i) const = 0;
\end{code}

This factory function constructs a \texttt{finite\_element} object for form argument i.
A form with rank r and a number of coefficients n will have r+n arguments,
such that this function returns the finite element object for coefficient $k$ if $i=r+k$,
or for tensor axis $k$ if $i=k<r$. TODO: is axis the right word?
The caller is responsible for deleting the returned object.

\subsection{The function \texttt{create\_dof\_map}}

\begin{code}
virtual dof_map* create_dof_map(unsigned int i) const = 0;
\end{code}

This factory function constructs a \texttt{dof\_map} object for form argument i.
A form with rank r and a number of coefficients n will have r+n arguments,
such that this function returns the finite element object for coefficient $k$ if $i=r+k$,
or for tensor axis $k$ if $i=k<r$. TODO: is axis the right word?
The caller is responsible for deleting the returned object.

\subsection{The function \texttt{create\_cell\_integral}}

\begin{code}
virtual cell_integral* create_cell_integral(unsigned int i) const = 0;
\end{code}

This factory function constructs a \texttt{cell\_integral} object for cell domain i.
TODO: math syntax. Domain description?
The caller is responsible for deleting the returned object.

\subsection{The function \texttt{create\_exterior\_facet\_integral}}

\begin{code}
virtual exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const = 0;
\end{code}

This factory function constructs a \texttt{exterior\_facet\_integral} object for exterior facet domain i.
TODO: math syntax. Domain description?
The caller is responsible for deleting the returned object.

\subsection{The function \texttt{create\_interior\_facet\_integral}}

\begin{code}
virtual interior_facet_integral* create_interior_facet_integral(unsigned int i) const = 0;
\end{code}

This factory function constructs a \texttt{interior\_facet\_integral} object for interior facet domain i.
TODO: math syntax. Domain description?
The caller is responsible for deleting the returned object.

% Need to write about the Python utils somewhere, should be in appendix
