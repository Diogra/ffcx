\chapter{Interface specification}
\label{sec:interface}

% Write about all functions are const except a few and why
% Write about the order in which we present the interface

\section{A short remark on design}

UFC is organized as a minimalistic C++ class hierarchy for
representing low-level abstractions of the finite element method. The
functions in these classes are mainly of two types: (i) Functions
returning dimensions, which are typically used to allocate an array or
check whether an existing array is of proper size and (ii) Functions
that fill an array with values according to the method and variational
form.

It is considered the user's or the assembly routine's
responsibility to allocate and deallocate arrays of proper size.
Consider for example the function for evaluating the $i$th basis
function in the class \texttt{finite\_element}:
\begin{code}
virtual void evaluate_basis(unsigned int i, double* values,
                            const double* coordinates,
                            const cell& c) const = 0;
\end{code}
This function assumes that the array \texttt{values} has the 
correct size, which may be obtained by calling the functions
\texttt{value\_rank} and \texttt{value\_dimension}.

Thus, the UFC interface is a low-level interface that should be simple
to integrate into an existing C++ finite element code, but which is
probably not suitable to be exposed as part of an end-user interface.

\section{Cell shapes}

\begin{code}
enum shape {interval,
            triangle, quadrilateral,
            tetrahedron, hexahedron};
\end{code}

This enumeration includes all cell shapes that are covered by the UFC
specification, see Chapter~\ref{sec:referencecells}.

\section{The class \texttt{ufc::mesh}}

The class \texttt{ufc::mesh} defines a data structure containing basic
information about an unstuctured mesh. It is used for passing a
minimal amount of information about the global mesh to UFC
functions.

%%\subsection{The mesh dimensions}
\subsection{The integer \texttt{topological\_dimension}}

\begin{code}
unsigned int topological_dimension;
\end{code}

The unsigned integer\texttt{topological\_dimension}
specifies the topological dimension of the mesh, that is, the
topological dimension of the cells of the mesh. For the supported
cell shapes defined above, the topological dimensions are as follows:
\texttt{interval} has dimension one, \texttt{triangle} and
\texttt{quadri\-lateral} have dimension two, and tetrahedron and
hexahedron have dimension three.

\subsection{The integer \texttt{geometric\_dimension}}

\begin{code}
unsigned int geometric_dimension;
\end{code}

The unsigned integer \texttt{geometric\_dimension} is the geometric dimension
of the mesh, that is, the dimension of the coordinates of the mesh vertices.
Often, the geometric dimension is equal to the topological dimension,
but they may differ. For example, one may have a topologically
two-dimensional mesh embedded in three-dimensional space.

\subsection{The array \texttt{num\_entities}}

\begin{code}
unsigned int* num_entities;
\end{code}

The array \texttt{num\_entities} should contain the number of entities
within each topological dimension of the mesh (see
Chapter~\ref{sec:referencecells}). Thus, for a mesh of tetrahedral
cells, \texttt{num\_entitites[0]} should contain the number of
vertices, \texttt{num\_entities[1]} should contain the number of edges
(if they are needed, see below) and \texttt{num\_entities[2]} should
contain the number of faces, and \texttt{num\_entities[3]} should
contain the number of cells.

\section{The class \texttt{ufc::cell}}

The class \texttt{ufc::cell} defines the data structure for a cell in
a mesh. Its intended use is not as a building block in a mesh data
structure, but merely as a view of specific data for a single cell.
It is used to pass cell data to UFC functions with a minimal amount of
assumptions on how the computational mesh is represented and stored.

\subsection{The enum variable \texttt{cell\_shape}}

\begin{code}
shape cell_shape;
\end{code}

The variable \texttt{cell\_shape} should be set to the corresponding
\texttt{ufc::shape} for the cell (see above).

\subsection{The integer \texttt{topological\_dimension}}

\begin{code}
unsigned int topological_dimension;
\end{code}

The integer \texttt{topological\_dimension} should be set equal to the
topological dimension of the cell (see above).

\subsection{The integer \texttt{geometric\_dimension}}

\begin{code}
unsigned int geometric_dimension;
\end{code}

The integer \texttt{geometric\_dimension} should be set equal to the
geometric dimension of the cell (see above).

\subsection{The array \texttt{entity\_indices}}

\begin{code}
unsigned int** entity_indices;
\end{code}

The array \texttt{entity\_indices} should contain the global indices
for all entities of the cell (see Chapter~\ref{sec:referencecells}).
The length of the array \texttt{entity\_indices} should be equal to
the value of the variable \texttt{topological\_dimension} plus one.

Thus, \texttt{entity\_indices[0]} should be an array containing the
global indices of all the vertices of the cell,
\texttt{entity\_indices[1]} should be an array containing the global
indices of all the edges of the cell, etc. 

Note that entity indices are not always needed for all entities of the
cell. Which entities are needed is specified by the
\texttt{ufc::dof\_map} class (see below).

\subsection{The array \texttt{coordinates}}

\begin{code}
double** coordinates;
\end{code}

The array \texttt{coordinates} should contain the global coordinates
for all vertices of the cell. The length of the array
\texttt{coordinates} should be equal to number of vertices of the
mesh. The length of the array \texttt{coordinates[0]} should be equal
to the value of the variable \texttt{geometric\_dimension} and it
should contain the $x_0$, $x_1$, \ldots coordinates of the first
vertex etc.

\section{The class \texttt{ufc::function}}

The class \texttt{ufc::function} is an interface for evaluation of
general tensor-valued functions on the cells of a mesh.

\begin{code}
virtual void evaluate(double* values,
                      const double* coordinates,
                      const cell& c) const = 0;
\end{code}

The only function in this class is \texttt{evaluate},
which evaluates all the value components of the function at a given
point in a given cell of the mesh.

The output of \texttt{evaluate} should be written to the array
\texttt{values}. For a scalar-valued functon, a single value should be
written to \texttt{values[0]}. For general tensor-valued functions,
the values should be written in a flattened row-major ordering of the
tensor values. Thus, for a function $f : K \rightarrow \R^2$ with $A =
f(x)$ a $2 \times 2$ matrix, the array \texttt{values} should contain
the values $A_{11}, A_{12}, A_{21}, A_{22}$.

The input of \texttt{evalute} are the coordinates of a point in a cell and
the UFC view of the cell containing the point.

See also the description of
\texttt{ufc::finite\_element::evaluate\_dof}
below.

\section{The class \texttt{ufc::finite\_element}}

TODO: update this with mathematical notation and references to earlier equations

%%   /// This class defines the interface for a finite element.

%%   class finite_element
%%   {
%%   public:

%%     /// Constructor
%%     finite_element() {}

%%     /// Destructor
%%     virtual ~finite_element() {}

%%     /// Return a string identifying the finite element
%%     virtual const char* signature() const = 0;

\subsection{The function \texttt{signature}}
This function returns a signature string that uniquely identifies the \texttt{finite\_element} subclass.

%%     /// Return the cell shape
%%     virtual shape cell_shape() const = 0;

\subsection{The function \texttt{cell\_shape}}
This function returns the shape of the cell the finite element is defined on.

%%     /// Return the dimension of the finite element function space
%%     virtual unsigned int space_dimension() const = 0;

\subsection{The function \texttt{space\_dimension}}
This function returns the dimension of the local finite element space ($| V_h^K |$),
which is equal to the number of basis functions. This is equal to \texttt{dof\_map::local\_dimension()}
from the matching \texttt{dof\_map} object.

%%     /// Return the rank of the value space
%%     virtual unsigned int value_rank() const = 0;

%%     /// Return the dimension of the value space for axis i
%%     virtual unsigned int value_dimension(unsigned int i) const = 0;

\subsection{The functions \texttt{value\_rank} and \texttt{value\_dimension}}
A finite element can have general tensor-valued basis functions.
These functions return the rank of the value space and the dimension along each axis.
The total value size is the product of \texttt{value\_dimension(i)} for $0 \le i <$ \texttt{value\_rank()}.

To give a few examples, the rank of a scalar element is 0, while a vector element has rank 1 and size \texttt{value\_dimension(0)}, 
and for a 3 by 3 tensor element the rank is 2 and the value size is \texttt{value\_dimension(0)}*\texttt{value\_dimension(1)}=9.

%%     /// Evaluate basis function i at given point in cell
%%     virtual void evaluate_basis(unsigned int i,
%%                                 double* values,
%%                                 const double* coordinates,
%%                                 const cell& c) const = 0;

\subsection{The function \texttt{evaluate\_basis}}
This function evaluates basis function \texttt{i} at the given \texttt{coordinates}
within the given cell \texttt{c}, and stores the value components in the array \texttt{values}.
The size of this output array equals the value size (see \texttt{value\_rank} and \texttt{value\_dimension}).

%%     /// Evaluate order n derivatives of basis function i at given point in cell
%%     virtual void evaluate_basis_derivatives(unsigned int i,
%%                                             unsigned int n,
%%                                             double* values,
%%                                             const double* coordinates,
%%                                             const ufc::cell& c) const = 0;

\subsection{The function \texttt{evaluate\_basis\_derivatives}}
This function evaluates all order \texttt{n} derivatives of basis function \texttt{i}
at the given \texttt{coordinates} within the given \texttt{cell},
and stores the value components in the array \texttt{values}.

The number of derivatives equals $d^n$ where d is the geometric dimension.
For n = 1, the order of the derivatives is naturally
$\partial/\partial x$, $\partial/\partial y$, $\partial/\partial z$
in a 3D case.
For n = 2, the order of the derivatives in a 2D case is 
  $\frac{\partial^2}{\partial x\partial x}$,
  $\frac{\partial^2}{\partial x\partial y}$,
  $\frac{\partial^2}{\partial y\partial x}$,
  $\frac{\partial^2}{\partial y\partial y}$,
ie the last derivative varies the fastest similar to the standard C array ordering (TODO: does this have a better name?).

TODO: How do we know which derivatives are supported? We probably should have a function for this.

The memory layout of \texttt{values} is
\texttt{values[k*value\_size + j]},
where k is the number of the derivative,
and j is the number of the value component.
The length of this array is thus the value size times $d^n$.


%%     /// Evaluate linear functional for dof i on the function f
%%     virtual double evaluate_dof(unsigned int i,
%%                                 const function& f,
%%                                 const cell& c) const = 0;

\subsection{The function \texttt{evaluate\_dof}}
This function evaluates the degree of freedom, $L_i$,  
which in general is a linear functional 
$L_i(f)$ of the input function \texttt{f}
on the given cell. 
  
For instance, for a Lagrange element a degree of
freedom is the value of the function at point $x_i$, i.e. $L_i = f(x_i)$. 
On the other hand for the (lowest order) Raviart-Thomas element 
the degree of freedom is the integral of the normal component
on the edge $e_i$, i.e., $L_i = \int_{e_i} f\cdot n \, ds$.  

%%     /// Interpolate vertex values from dof values
%%     virtual void interpolate_vertex_values(double* vertex_values,
%%                                            const double* dof_values,
%%                                            const cell& c) const = 0;

\subsection{The function \texttt{interpolate\_vertex\_values}}
This function takes as input the dofs \texttt{dof\_values} (TODO: nodal values? TODO: reference some equations)
of a function $f(x)$ in the finite element space, as well as a cell.
It then performs a local interpolation of $f(x)$ in the vertices of the cell.

%%     /// Return the number of sub elements (for a mixed element)
%%     virtual unsigned int num_sub_elements() const = 0;

\subsection{The function \texttt{num\_sub\_elements}}
This function returns the number of sub elements for a mixed element.
See description of the sub element concept under the form class.

%%     /// Create a new finite element for sub element i (for a mixed element)
%%     virtual finite_element* create_sub_element(unsigned int i) const = 0;

\subsection{The function \texttt{num\_sub\_elements}}
This function constructs a \texttt{finite\_element} object for sub element \texttt{i}.
See description of the sub element concept under the form class.
The caller is responsible for deleting the returned object.

%%   };



\section{The class \texttt{ufc::dof\_map}}

This class represents one local-to-global mapping of degrees of freedom (dofs),
as defined in equation \eqref{eq:iota_K}.
The most central function in this interface is \texttt{tabulate\_dofs}, described below.

%%   /// This class defines the interface for a local-to-global mapping of
%%   /// degrees of freedom (dofs).

%%   class dof_map
%%   {
%%   public:

%%     /// Constructor
%%     dof_map() {}

%%     /// Destructor
%%     virtual ~dof_map() {}

%%     /// Return a string identifying the dof map
%%     virtual const char* signature() const = 0;

\subsection{The function \texttt{signature}}
This function returns a signature string that uniquely identifies the \texttt{dof\_map} subclass.
The only requirement for the signature is that it is unique, such
that a comparison of two signatures can be used by the assembly
implementer to optimize the code by not initializing and tabulating equivalent dof maps more than once.

%%     /// Return true iff mesh entities of topological dimension d are needed
%%     virtual bool needs_mesh_entities(unsigned int d) const = 0;

\subsection{The function \texttt{needs\_mesh\_entities}}
This function returns true if the \texttt{dof\_map} requires mesh entities
of topological dimension d to be filled in \texttt{ufc::cell} arguments.
This is needed because computation of some mesh entity numberings
are expensive operations which can often be skipped.

%%     /// Initialize dof map for mesh (return true iff init_cell() is needed)
%%     virtual bool init_mesh(const mesh& mesh) = 0;

\subsection{The function \texttt{init\_mesh}}
This function initializes the dof map for a given mesh.
If it returns true, initialization requires calls to \texttt{init\_cell} and \texttt{init\_cell\_finalize} to complete
After initialization is complete, the function \texttt{global\_dimension} can be called.

%%     /// Initialize dof map for given cell
%%     virtual void init_cell(const mesh& m,
%%                            const cell& c) = 0;

\subsection{The function \texttt{init\_cell}}
For dof\_map objects where init\_mesh returns true,
this function must be called for each cell in the mesh
to initialize the dof mapping.

%%     /// Finish initialization of dof map for cells
%%     virtual void init_cell_finalize() = 0;

\subsection{The function \texttt{init\_cell\_finalize}}
For dof\_map objects where init\_mesh returns true,
this function must be called after init\_cell is called for each cell in the mesh
to complete initialition of the dof mapping.

%%     /// Return the dimension of the global finite element function space
%%     virtual unsigned int global_dimension() const = 0;

\subsection{The function \texttt{global\_dimension}}
This function returns the dimension of the global finite element space on the mesh
the dof\_map has been initialized for.
The result of calling this function before initialition is complete is undefined.

%%     /// Return the dimension of the local finite element function space
%%     virtual unsigned int local_dimension() const = 0;

\subsection{The function \texttt{local\_dimension}}
This function returns the dimension of the local finite element space on a single cell.

%%     /// Return the number of dofs on each cell facet
%%     virtual unsigned int num_facet_dofs() const = 0;

\subsection{The function \texttt{num\_facet\_dofs}}
This function returns the number of dofs tied to a single facet of a cell.
This is the number of dofs that should be set if a Dirichlet boundary condition is applied to a single facet.

%%     /// Tabulate the local-to-global mapping of dofs on a cell
%%     virtual void tabulate_dofs(unsigned int* dofs,
%%                                const mesh& m,
%%                                const cell& c) const = 0;

\subsection{The function \texttt{tabulate\_dofs}}
This function tabulates the global dof indices for each dof on the given cell.
The output array \texttt{dofs} is allocated by the caller with size \texttt{local\_dimension()}.

%%     /// Tabulate the local-to-local mapping from facet dofs to cell dofs
%%     virtual void tabulate_facet_dofs(unsigned int* dofs,
%%                                      unsigned int facet) const = 0;

\subsection{The function \texttt{tabulate\_facet\_dofs}}
This function tabulates which local dof indices are tied to the local facet.
The output array \texttt{dofs} is allocated by the caller with size \texttt{num\_facet\_dofs()}

%%     /// Tabulate the coordinates of all dofs on a cell
%%     virtual void tabulate_coordinates(double **coordinates,
%%                                       const cell& c) const = 0;

\subsection{The function \texttt{tabulate\_coordinates}}
This function tabulates the coordinates for each dof on the given cell.
For elements which do not have a direct relationship between coordinates and dofs,
an attempt should be made at a sensible implementation of this function.
For example, if a dof is defined as the integral over a facet, the midpoint
of the facet can be used. If no other choice makes sense, the midpoint of the cell
can be used as a last resort. This function must thus be used with care if
non-Lagrangian elements are used.
The output array \texttt{coordinates} is allocated by the caller with size \texttt{local\_dimension()} times number of space dimensions.

%%     /// Return the number of sub dof maps (for a mixed element)
%%     virtual unsigned int num_sub_dof_maps() const = 0;

\subsection{The function \texttt{num\_sub\_dof\_maps}}
This function returns the number of sub dof maps for a mixed element.
See description of the sub element concept under the form class.

%%     /// Create a new dof_map for sub dof map i (for a mixed element)
%%     virtual dof_map* create_sub_dof_map(unsigned int i) const = 0;

\subsection{The function \texttt{create\_sub\_dof\_map}}
This factory function constructs a \texttt{dof\_map} object for sub dof map i.
See description of the sub element concept under the form class.
The caller is responsible for deleting the returned object.
TODO: Describe numbering convention for recursive sub elements with (v, p) as example.

%%   };



\section{The integral classes}

The computation of the element tensor $A^K$ on a cell $K$ is split into computation of
contributions from several integrals, as seen in equation \eqref{eq:form_integrals}.
Each of the three types of integrals is represented with its own class.
All three integral classes have a single function \texttt{tabulate\_tensor} which
computes the tensor values $A_i^K$.

For all types of integrals, the coefficient array \texttt{w[i][j]} contains the
arguments to the form. Each argument $w_i$, $0\le i<n$, is a function that resides in a 
particular finite element space. For a given argument i, the local degrees of freedom for $w_i$
is represented by \texttt{w[i][j]}, $0 \le j < d_i$, with $d_i$ being the local dimension of
the finite element space for argument i.

Note that, to support coefficient functions which should be evaluated in quadrature points
for use in a quadrature-based implementation of \texttt{tabulate\_tensor()},
an implementation of \texttt{finite\_element} and \texttt{dof\_map}
can be written were the degrees of freedom are the values of $f$ in each
quadrature point. For example, \texttt{finite\_element::evaluate\_dof(j, f, ...)}
would evaluate the function f in quadrature point j, and \texttt{w[i][j]} would contain
the value of $f=w_i$ in quadrature point $x_j$.

%See \texttt{class finite\_element}, \texttt{class dof\_map},
%\texttt{form::create\_finite\_element(i)} and \texttt{form::create\_dof\_map(i)}.

%\texttt{i}


%%\section{The class \texttt{ufc::cell\_integral}}

%%   /// This class defines the interface for the tabulation of the cell
%%   /// tensor corresponding to the local contribution to a form from
%%   /// the integral over a cell.

%%   class cell_integral
%%   {
%%   public:

%%     /// Constructor
%%     cell_integral() {}

%%     /// Destructor
%%     virtual ~cell_integral() {}

%%     /// Tabulate the tensor for the contribution from a local cell
%%     virtual void tabulate_tensor(double* A,
%%                                  const double * const * w,
%%                                  const cell& c) const = 0;

%%   };


\subsection{The class \texttt{ufc::cell\_integral}}
%%\subsection{The function \texttt{tabulate\_tensor}}
\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c) const = 0;
\end{code}
This function computes the contribution to the local element tensor
on the given cell from this cell integral.
The size of this tensor is TODO


%%\section{The class \texttt{ufc::exterior\_facet\_integral}}

%%   /// This class defines the interface for the tabulation of the
%%   /// exterior facet tensor corresponding to the local contribution to
%%   /// a form from the integral over an exterior facet.

%%   class exterior_facet_integral
%%   {
%%   public:

%%     /// Constructor
%%     exterior_facet_integral() {}

%%     /// Destructor
%%     virtual ~exterior_facet_integral() {}

%%     /// Tabulate the tensor for the contribution from a local exterior facet
%%     virtual void tabulate_tensor(double* A,
%%                                  const double * const * w,
%%                                  const cell& c,
%%                                  unsigned int facet) const = 0;

%%   };


\subsection{The class \texttt{ufc::exterior\_facet\_integral}}
%%\subsection{The function \texttt{tabulate\_tensor}}
\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c,
                             unsigned int facet) const = 0;
\end{code}
This function computes the contribution to the local element tensor
on the given cell facet from this exterior facet integral.
The size of this tensor is TODO



%%\section{The class \texttt{ufc::interior\_facet\_integral}}

%%   /// This class defines the interface for the tabulation of the
%%   /// interior facet tensor corresponding to the local contribution to
%%   /// a form from the integral over an interior facet.

%%   class interior_facet_integral
%%   {
%%   public:

%%     /// Constructor
%%     interior_facet_integral() {}

%%     /// Destructor
%%     virtual ~interior_facet_integral() {}

%%     /// Tabulate the tensor for the contribution from a local interior facet
%%     virtual void tabulate_tensor(double* A,
%%                                  const double * const * w,
%%                                  const cell& c0,
%%                                  const cell& c1,
%%                                  unsigned int facet0,
%%                                  unsigned int facet1) const = 0;

%%   };

\subsection{The class \texttt{ufc::interior\_facet\_integral}}
%%\subsection{The function \texttt{tabulate\_tensor}}
\begin{code}
virtual void tabulate_tensor(double* A,
                             const double * const * w,
                             const cell& c0,
                             const cell& c1,
                             unsigned int facet0,
                             unsigned int facet1) const = 0;
\end{code}
This function computes the contribution to the local element tensor
on the given facet between two cells from this interior facet integral.
The size of this tensor is TODO


\section{The class \texttt{ufc::form}}

This class represents the central object in any UFC implementation.
A \texttt{form} object can provide some basic information about the form,
like the rank r and number of coefficients n.
In addition, an object of this type can be used to construct matching
implementations of all the other UFC classes with the use of factory functions.
This includes an arbitrary number of integral objects,
as well as one \texttt{finite\_element} and one \texttt{dof\_map} for
each argument (r+n) to the form.

TODO: Need a separate section for the sub element concept.
Some finite elements can be seen as composite elements with a number of sub elements.
A vector element is an element with a value size larger than one,
where each value component usually resides in the same function space.
A mixed element can be seen as a vector element where each value
component may reside in a different function space.
Some times it is convenient to see these composite elements as one element,
and other times it is necessary to extract one sub element at a time.

In UFC we treat vector elements and mixed elements the same way, by allowing
an element (and dof map) to contain sub elements (and sub dof maps).
The composite element for argument i is what you get directly from
\texttt{form::create\_finite\_element(i)} and \texttt{form::create\_dof\_map(i)}.
To get access to the sub elements, see the documentation for
\texttt{finite\_element} and \texttt{dof\_map}.
TODO: Describe recursive sub elements with (v, p) as example.

%%   /// This class defines the interface for the assembly of the global
%%   /// tensor corresponding to a form with r + n arguments, that is, a
%%   /// mapping
%%   ///
%%   ///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
%%   ///
%%   /// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
%%   /// global tensor A is defined by
%%   ///
%%   ///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
%%   ///
%%   /// where each argument Vj represents the application to the
%%   /// sequence of basis functions of Vj and w1, w2, ..., wn are given
%%   /// fixed functions (coefficients).

%%   class form
%%   {
%%   public:

%%     /// Constructor
%%     form() {}

%%     /// Destructor
%%     virtual ~form() {}

%%     /// Return a string identifying the form
%%     virtual const char* signature() const = 0;

\subsection{The function \texttt{signature}}
This function returns a unique signature for the form.
TODO: Requirements for the signature.


%%     /// Return the rank of the global tensor (r)
%%     virtual unsigned int rank() const = 0;

\subsection{The function \texttt{rank}}
This function returns the rank of the element tensors created by this form.


%%     /// Return the number of coefficients (n)
%%     virtual unsigned int num_coefficients() const = 0;

\subsection{The function \texttt{num\_coefficients}}
This function returns the number of coefficients for this form.
Note that, for simplicity, all integrals in a form must have
the same coefficients, even if they don't use them.


%%     /// Return the number of cell integrals
%%     virtual unsigned int num_cell_integrals() const = 0;

\subsection{The function \texttt{num\_cell\_integrals}}
This function returns the number of different cell integrals for this form.


\subsection{The function \texttt{num\_exterior\_facet\_integrals}}
%%     /// Return the number of exterior facet integrals
\begin{code}
virtual unsigned int num_exterior_facet_integrals() const = 0;
\end{code}
This function returns the number of different exterior facet integrals for this form.


%%     /// Return the number of interior facet integrals
%%     virtual unsigned int num_interior_facet_integrals() const = 0;

\subsection{The function \texttt{num\_interior\_facet\_integrals}}
This function returns the number of different interior facet integrals for this form.


%%     /// Create a new finite element for argument function i
%%     virtual finite_element* create_finite_element(unsigned int i) const = 0;

\subsection{The function \texttt{create\_finite\_element}}
This factory function constructs a \texttt{finite\_element} object for form argument i.
A form with rank r and a number of coefficients n will have r+n arguments,
such that this function returns the finite element object for coefficient $k$ if $i=r+k$,
or for tensor axis $k$ if $i=k<r$. TODO: is axis the right word?
The caller is responsible for deleting the returned object.


%%     /// Create a new dof map for argument function i
%%     virtual dof_map* create_dof_map(unsigned int i) const = 0;

\subsection{The function \texttt{create\_dof\_map}}
This factory function constructs a \texttt{dof\_map} object for form argument i.
A form with rank r and a number of coefficients n will have r+n arguments,
such that this function returns the finite element object for coefficient $k$ if $i=r+k$,
or for tensor axis $k$ if $i=k<r$. TODO: is axis the right word?
The caller is responsible for deleting the returned object.


%%     /// Create a new cell integral on sub domain i
%%     virtual cell_integral* create_cell_integral(unsigned int i) const = 0;

\subsection{The function \texttt{create\_cell\_integral}}
This factory function constructs a \texttt{cell\_integral} object for cell domain i.
TODO: math syntax. Domain description?
The caller is responsible for deleting the returned object.


%%     /// Create a new exterior facet integral on sub domain i
%%     virtual exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const = 0;

\subsection{The function \texttt{create\_exterior\_facet\_integral}}
This factory function constructs a \texttt{exterior\_facet\_integral} object for exterior facet domain i.
TODO: math syntax. Domain description?
The caller is responsible for deleting the returned object.


%%     /// Create a new interior facet integral on sub domain i
%%     virtual interior_facet_integral* create_interior_facet_integral(unsigned int i) const = 0;

\subsection{The function \texttt{create\_interior\_facet\_integral}}
This factory function constructs a \texttt{interior\_facet\_integral} object for interior facet domain i.
TODO: math syntax. Domain description?
The caller is responsible for deleting the returned object.


%%   };

%% }

%% #endif

% Need to write about the Python utils somewhere, should be in appendix
