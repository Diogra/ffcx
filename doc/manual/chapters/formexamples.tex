\chapter{Examples}
\label{sec:formexamples}

\label{CodeGenExamples}
In Section \ref{sec:Discretization} we listed various forms to
illustrate the basic concepts and notation of the UFC interface. In
this section, we show code snippets from the corresponding generated
UFC code to illustrate the usage of the UFC interface, in particular
the central function \texttt{cell\_integral::tabulate\_tensor} which
may be used to compute the cell tensor (``element stiffness matrix'')
for the example forms.  These code listings are only shown such that
the reader may get a feeling for what the code may look like. The code
itself is probably not very meaningful other than as an illustration.
All the examples are given for elements on the 2D triangle.

\section{Taylor--Hood and the divergence matrix}

In Example \ref{example:div}, we described  
the form 
\begin{equation}
a(q, u) = \int_{\Omega} q \nabla \cdot u \dx, \quad q\in V_h^1, \quad u\in V_h^2, 
\end{equation}
where $V_h^1$ is a space of scalar-valued functions and where $V_h^2$
is a space of vector-valued functions.  We discreteize the form using
Taylor--Hood element, that is, we let $V_h^1 = P_1$ be the space of
continuous linear scalar-valued polynomials and let $V_h^2 = (P_2)^2$
be the space of continuous quadratic vector-valued polynomials.

\subsection{Code generated by FFC}

\subsection{Code generated by SyFi}

The SyFi code generated for this form can be found in \\ 
\texttt{src/syfi-demos/div\_form.py} of the SyFi source tree.

The code for \texttt{cell\_integral::tabulate\_tensor} follows below.
\begin{code}
/// Tabulate the tensor for the contribution from a local cell
void cell_itg__div_form__VectorLagrange_2__Lagrange_1_2D ::
     tabulate_tensor(double* A, const double * const * w,
                     const ufc::cell& c) const
{
  // coordinate
  double x0=c.coordinates[0][0]; double y0=c.coordinates[0][1];
  double x1=c.coordinates[1][0]; double y1=c.coordinates[1][1];
  double x2=c.coordinates[2][0]; double y2=c.coordinates[2][1];
  
  // affine map
  double G00 = x1 - x0;
  double G01 = x2 - x0;
  
  double G10 = y1 - y0;
  double G11 = y2 - y0;
  
  double detG_tmp = G00*G11-G01*G10;
  double detG = fabs(detG_tmp);
  
  double GinvT00 =  G11 / detG_tmp;
  double GinvT01 = -G10 / detG_tmp;
  double GinvT10 = -G01 / detG_tmp;
  double GinvT11 =  G00 / detG_tmp;
  
  
  memset(A, 0, sizeof(double)*36);
  
  A[3*0 + 0] = (-GinvT10/6.0-GinvT00/6.0)*detG;
  A[3*1 + 0] = (-GinvT01/6.0-GinvT11/6.0)*detG;
  A[3*2 + 0] = detG*(-GinvT10/6.0+GinvT00/6.0);
  A[3*9 + 1] = (GinvT01/6.0+GinvT11/3.0)*detG;
  .......
  A[3*9 + 2] = detG*(GinvT01/3.0+GinvT11/6.0);
  A[3*10 + 2] = (1.0/6.0)*GinvT10*detG;
  A[3*11 + 2] = (1.0/6.0)*detG*GinvT11;
}
\end{code}

First in this code, the coordinate mapping is 
computed.
This mapping relates global coordinates, $x$, to coordinates
on the reference element, $X$, by the affine relation 
\[
x = F(X) = G X + x_0. 
\]
Then, the element tensor is initialized to zero using the \texttt{memset()}
function, before its entries are computed.

The element tensor is a matrix, hence \texttt{form::rank()} returns 2.
The dimension (obtained by calling \texttt{finite\_element::space\_dimension()})
of  $(P_2)^2$ is 12 and the dimension of $P_1$ is 3.    
Hence, the dimension of the cell tensor \texttt{A} represented as a    
flat array is 36.
Furthermore, \texttt{A} is numbered as $ni + j$ where
$n$ is the number of basis functions in the pressure element, 
$i$ relates to the $i$th basis function of the velocity element and
$j$ relates to the $j$th basis function of the pressure element. 
Notice here that \texttt{w} is not in use since the form has no
coefficients. Therefore, \texttt{form::num\_coefficients()} returns zero.

\section{Nonlinear convection with variable density} 

In Example \ref{example:nonlinearconv}, we considered the
form related to nonlinear convection with variable density:
\begin{equation}
a(v,u;w,\varrho) = \int_{\Omega} v \, \varrho \, w \cdot \nabla  u \dx. 
\end{equation}
We here take $v, u \in (P_1)^2$, $w\in (P_0)^2$ and  $\varrho \in P_0$.

\subsection{Code generated by FFC}

\subsection{Code generated by SyFi}

The SyFi code generated for this form can be found in \\ 
\texttt{src/syfi-demos/conv\_form.py} of the SyFi source tree.

The code for \texttt{cell\_integral::tabulate\_tensor} follows below.
\begin{code}
void cell_itg__conv_form__VectorLagrange_1__VectorLagrange_1__\
     VectorP0__P0_2D::tabulate_tensor(double* A, 
     const double * const * w, const ufc::cell& c) const
{
  // computation of geomtry mapping and initialization of A ...
  
  A[6*0 + 0] = (-w[0][1]*GinvT11*w[1][0]/6.0 -w[0][0]*
      w[1][0]*GinvT01/6.0-w[0][1]*GinvT10*w[1][0]/6.0-
      w[0][0]*w[1][0]*GinvT00/6.0)*detG;
   ...
  A[6*5 + 5] = (w[0][1]*GinvT11*w[1][0]/6.0+w[0][0]*
      w[1][0]*GinvT01/6.0)*detG;
}
\end{code}

In this example we have two coefficients, $\varrho$ and $w$. These 
coefficients are represented by \texttt{w}, as \texttt{w[0]} and \texttt{w[1]}. The first coefficients
which is in $\P_0^2$, which is of size 2, is represented as 
\texttt{w[0][0]} and \texttt{w[0][1]}. The second coefficient 
is in $\P_0^2$, which is of size 1, and is represented by \texttt{w[1][0]}.  

\section{The right-hand side}

The next example is the computation of the right-hand side, also described in 
Example \ref{example:rhs}. The form takes two arguments and
but one of them, $f$, is a coefficient:
\begin{equation}
a(v; f) = \int_{\Omega} v f \dx.
\end{equation}
We here let $v$ and $f$ be continuous piecewise linear functions.
Notice however that $f$ may here be any function, 
but it is interpolated onto the linear Lagrange element. 
A more accurate interpolation scheme can be obtained 
by chosing interpolation onto a higher order Lagrange element. 

\subsection{Code generated by FFC}

\subsection{Code generated by SyFi}

The SyFi code generated for this form can be found in \\
\texttt{src/syfi-demos/rhs\_form.py} of the SyFi source tree.

The code for \texttt{cell\_integral::tabulate\_tensor} follows below.
\begin{code}
void cell_itg__rhs_form__Lagrange_1_2D::
     tabulate_tensor(double* A, const double * const * w,
                     const ufc::cell& c) const
{
  // computation of geomtry mapping and initialization of A ...
 
  A[0] = (w[0][1]/24.0+w[0][0]/12.0+w[0][2]/24.0)*detG;
  A[1] = (w[0][1]/12.0+w[0][0]/24.0+w[0][2]/24.0)*detG;
  A[2] = (w[0][1]/24.0+w[0][0]/24.0+w[0][2]/12.0)*detG;
}
\end{code}
The element tensor is here a vector of size 3, since $v$ is in $\P_2$. 
The coefficient $f$ is represented by \texttt{w[0][0]}\ldots\texttt{w[0][2]}. 

\section{The $H^1$-norm of the error}


\begin{equation}
a(u,u_h) = (u-u_h, u-u_h) + (\nabla (u-u_h), \nabla(u-u_h))    
\end{equation}
Here, both $u$ and $u_h$ are coefficients. However, $u_h$ is usually
represeted as a finite element solution while $u$ is the analytical 
solution represented as a function. 

\subsection{Code generated by FFC}

\subsection{Code generated by SyFi}

The SyFi code generated for this form can be found in \\
\texttt{src/syfi-demos/h1\_error\_form.py} of the SyFi source tree.

The code for \texttt{cell\_integral::tabulate\_tensor} follows below.
\begin{code}
void cell_itg__H1_error__Lagrange_1_2D::
     tabulate_tensor(double* A, const double * const * w,
                     const ufc::cell& c) const
{

  // computation of geomtry mapping and initialization of A ...

  A[0] = detG*((w[1][2]*w[1][2])/12.0+w[1][2]*w[1][0]/12.0
       +w[0][1]*w[0][0]/12.0-w[0][1]*w[1][0]/12.0-w[1][2]
       *w[0][2]/6.0+(w[1][1]*w[1][1])/12.0+w[0][1]  ... ; 
}
\end{code}
